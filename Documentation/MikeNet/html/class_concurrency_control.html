<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: ConcurrencyControl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>ConcurrencyControl Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ConcurrencyControl" -->
<p>Advanced concurrency control object.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_concurrency_control_8h_source.html">ConcurrencyControl.h</a>&gt;</code></p>

<p><a href="class_concurrency_control-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a24e5689f704351208afc2cb7b4efbcec">Construct</a> (size_t numThreads)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up object ready for use.  <a href="#a24e5689f704351208afc2cb7b4efbcec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb06df9571b135c04f5ee6e60e734d8"></a><!-- doxytag: member="ConcurrencyControl::ConcurrencyControl" ref="aafb06df9571b135c04f5ee6e60e734d8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#aafb06df9571b135c04f5ee6e60e734d8">ConcurrencyControl</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, sets variables to default and prepares object ready for use by one thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a3ef5edee9c033b9725556fd153312e22">ConcurrencyControl</a> (size_t paraThreads)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, sets variables to default and prepares object ready for use by multiple threads.  <a href="#a3ef5edee9c033b9725556fd153312e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a516fa47be5e1e196786ec77ec1909159"></a><!-- doxytag: member="ConcurrencyControl::~ConcurrencyControl" ref="a516fa47be5e1e196786ec77ec1909159" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a516fa47be5e1e196786ec77ec1909159">~ConcurrencyControl</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor, cleans up object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a3a0351a48b92570778544957dd181f17">GetNumThreads</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of threads setup to use this object.  <a href="#a3a0351a48b92570778544957dd181f17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2d6142d40a726d64148965aa9bd13fe"></a><!-- doxytag: member="ConcurrencyControl::EnterRead" ref="aa2d6142d40a726d64148965aa9bd13fe" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#aa2d6142d40a726d64148965aa9bd13fe">EnterRead</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take read control of object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98d2523a22ecac7c03e5b10e431d613d"></a><!-- doxytag: member="ConcurrencyControl::LeaveRead" ref="a98d2523a22ecac7c03e5b10e431d613d" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a98d2523a22ecac7c03e5b10e431d613d">LeaveRead</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release read control of object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#aadc7743380ba3da2385fd052de30f144">EnterWrite</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely take write control of object.  <a href="#aadc7743380ba3da2385fd052de30f144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b495ca39efffd3194c771b8c83931cd"></a><!-- doxytag: member="ConcurrencyControl::LeaveWrite" ref="a1b495ca39efffd3194c771b8c83931cd" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a1b495ca39efffd3194c771b8c83931cd">LeaveWrite</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release write control of object. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename safeReadValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">safeReadValueType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#aee7ec3509126d17541eb80dab78385c3">_safeReadValue</a> (const safeReadValueType &amp;readMe) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely reads a value using critical sections.  <a href="#aee7ec3509126d17541eb80dab78385c3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename safeWriteValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a33065392a618a5b52ac4bb40fb12baf5">_safeWriteValueNK</a> (safeWriteValueType &amp;updateMe, const safeWriteValueType *newValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely writes a value using critical sections to a non key variable.  <a href="#a33065392a618a5b52ac4bb40fb12baf5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename safeWriteValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#af11f93d42d36e6760925bb17d522e3e9">_safeWriteValueNK</a> (safeWriteValueType &amp;updateMe, safeWriteValueType newValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely writes a value using critical sections to a non key variable.  <a href="#af11f93d42d36e6760925bb17d522e3e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename safeWriteValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a3d636cd5098ec1171887d9124629a362">_safeWriteValueKEY</a> (safeWriteValueType &amp;updateMe, const safeWriteValueType *newValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely writes a value using critical sections to a key variable.  <a href="#a3d636cd5098ec1171887d9124629a362"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename safeWriteValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a0b1fd7acbdae6efd4d4b8f0a7b076eba">_safeWriteValueKEY</a> (safeWriteValueType &amp;updateMe, safeWriteValueType newValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely writes a value using critical sections to a key variable.  <a href="#a0b1fd7acbdae6efd4d4b8f0a7b076eba"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#ab3a9f4eb59ff8f5dfaecfec57d0f1d14">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#ab3a9f4eb59ff8f5dfaecfec57d0f1d14"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96de68ed0ed80870d50df60e68496af6"></a><!-- doxytag: member="ConcurrencyControl::DefaultVariables" ref="a96de68ed0ed80870d50df60e68496af6" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a96de68ed0ed80870d50df60e68496af6">DefaultVariables</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all variables to default. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a7d7dc3ba467d27bfa118d1929b5a5d90">ValidateThreadID</a> (size_t threadID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks that thread ID is in bounds, and throws an exception if it is not.  <a href="#a7d7dc3ba467d27bfa118d1929b5a5d90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#afd31026e93f3ea692eb93d638e1c643b">GetThreadID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the calling thread's manual thread ID.  <a href="#afd31026e93f3ea692eb93d638e1c643b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a03501e21a7e927dba93ed19895b407de">Cleanup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleans up object and resets variables to default.  <a href="#a03501e21a7e927dba93ed19895b407de"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a0a94abcc70c42d61b057bddeb32a6e52">threads</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of threads that can use object.  <a href="#a0a94abcc70c42d61b057bddeb32a6e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_critical_section.html">CriticalSection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a83a545f7c4a64d11dab7fd1931155182">access</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Critical section object, used to control access to object.  <a href="#a83a545f7c4a64d11dab7fd1931155182"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#af07ace0cc51f0411ac09198e106a1123">accessRead</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps a count of how many levels of read control each thread has.  <a href="#af07ace0cc51f0411ac09198e106a1123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#ab0de7910c0fb51c3843f65e8cd40ae7c">accessWrite</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps a count of how many levels of write control each thread has.  <a href="#ab0de7910c0fb51c3843f65e8cd40ae7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727f8073f764bbc193ec8bb962873bb2"></a><!-- doxytag: member="ConcurrencyControl::constructed" ref="a727f8073f764bbc193ec8bb962873bb2" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_control.html#a727f8073f764bbc193ec8bb962873bb2">constructed</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="class_concurrency_control.html#a24e5689f704351208afc2cb7b4efbcec" title="Sets up object ready for use.">ConcurrencyControl::Construct</a> has been used. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Advanced concurrency control object. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p><a class="el" href="class_concurrency_control.html" title="Advanced concurrency control object.">ConcurrencyControl</a> is an advanced concurrency control object. <br/>
 It relies on the following key multithreading principals:</p>
<ul>
<li>Data can be read by multiple threads at the same time.</li>
<li>Data cannot be written and read from at the same time.</li>
<li>Data cannot be written to &gt; once at the same time.</li>
</ul>
<p>Threads should EnterRead when reading protected data, and LeaveRead when done reading the protected data. Threads should EnterWrite when writing to a protected location, and LeaveWrite when done writing. When in write control (EnterWrite) the thread can also read from the protected location.<br/>
<br/>
</p>
<p>All threads using this object should have a manual thread ID set in their associated <a class="el" href="class_thread_single.html" title="A single thread, the thread&#39;s life time is the life time of this object.">ThreadSingle</a> object ranging from inclusive 0 to exclusive maximum number of threads. The main process is given a virtual thread ID = to the maximum number of threads. Two threads MUST NOT have the same ID, deadlock may occur otherwise.<br/>
<br/>
</p>
<p>Calling threads must have first used <a class="el" href="class_thread_single.html#a2eb55a419326e7c7d8236cf3299d2030" title="Calling thread updates its thread local storage with a pointer to its ThreadSingle object...">ThreadSingle::ThreadSetCallingThread()</a>. The main process must call AllocateThreadLocalStorage and use <a class="el" href="class_thread_single.html#a2eb55a419326e7c7d8236cf3299d2030" title="Calling thread updates its thread local storage with a pointer to its ThreadSingle object...">ThreadSingle::ThreadSetCallingThread</a> with a parameter of NULL. This is done automatically by <a class="el" href="class_net_utility.html#aa6103c1b3d6f5b366c0903ba7b22a625" title="Sets up completion port and creates threads to manage completion port.">NetUtility::SetupCompletionPort</a>.</p>
<p>You must ensure the following when using <a class="el" href="class_concurrency_control.html" title="Advanced concurrency control object.">ConcurrencyControl</a> objects:</p>
<ul>
<li>A thread must release control at some point.</li>
<li>A thread should only take control while it is using the protected objects.</li>
</ul>
<p>Note that a thread can EnterRead or EnterWrite multiple times but must call LeaveRead and LeaveWrite for each individual EnterRead or/and EnterWrite. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3ef5edee9c033b9725556fd153312e22"></a><!-- doxytag: member="ConcurrencyControl::ConcurrencyControl" ref="a3ef5edee9c033b9725556fd153312e22" args="(size_t paraThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConcurrencyControl::ConcurrencyControl </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>paraThreads</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, sets variables to default and prepares object ready for use by multiple threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paraThreads</em>&nbsp;</td><td>Number of threads that will be using object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aee7ec3509126d17541eb80dab78385c3"></a><!-- doxytag: member="ConcurrencyControl::_safeReadValue" ref="aee7ec3509126d17541eb80dab78385c3" args="(const safeReadValueType &amp;readMe) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename safeReadValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">safeReadValueType ConcurrencyControl::_safeReadValue </td>
          <td>(</td>
          <td class="paramtype">const safeReadValueType &amp;&nbsp;</td>
          <td class="paramname"> <em>readMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely reads a value using critical sections. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>readMe</em>&nbsp;</td><td>Reference to value to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d636cd5098ec1171887d9124629a362"></a><!-- doxytag: member="ConcurrencyControl::_safeWriteValueKEY" ref="a3d636cd5098ec1171887d9124629a362" args="(safeWriteValueType &amp;updateMe, const safeWriteValueType *newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename safeWriteValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::_safeWriteValueKEY </td>
          <td>(</td>
          <td class="paramtype">safeWriteValueType &amp;&nbsp;</td>
          <td class="paramname"> <em>updateMe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const safeWriteValueType *&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely writes a value using critical sections to a key variable. </p>
<p>Key means that it does require write access when changing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>updateMe</em>&nbsp;</td><td>Reference to object to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newValue</em>&nbsp;</td><td>Pointer to value to copy into <em>updateMe</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b1fd7acbdae6efd4d4b8f0a7b076eba"></a><!-- doxytag: member="ConcurrencyControl::_safeWriteValueKEY" ref="a0b1fd7acbdae6efd4d4b8f0a7b076eba" args="(safeWriteValueType &amp;updateMe, safeWriteValueType newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename safeWriteValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::_safeWriteValueKEY </td>
          <td>(</td>
          <td class="paramtype">safeWriteValueType &amp;&nbsp;</td>
          <td class="paramname"> <em>updateMe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">safeWriteValueType&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely writes a value using critical sections to a key variable. </p>
<p>Key means that it does require write access when changing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>updateMe</em>&nbsp;</td><td>Reference to object to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newValue</em>&nbsp;</td><td>Value to copy into <em>updateMe</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af11f93d42d36e6760925bb17d522e3e9"></a><!-- doxytag: member="ConcurrencyControl::_safeWriteValueNK" ref="af11f93d42d36e6760925bb17d522e3e9" args="(safeWriteValueType &amp;updateMe, safeWriteValueType newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename safeWriteValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::_safeWriteValueNK </td>
          <td>(</td>
          <td class="paramtype">safeWriteValueType &amp;&nbsp;</td>
          <td class="paramname"> <em>updateMe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">safeWriteValueType&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely writes a value using critical sections to a non key variable. </p>
<p>Non key means that it does not require write access when changing (see class description for reasoning). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>updateMe</em>&nbsp;</td><td>Reference to object to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newValue</em>&nbsp;</td><td>Value to copy into <em>updateMe</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33065392a618a5b52ac4bb40fb12baf5"></a><!-- doxytag: member="ConcurrencyControl::_safeWriteValueNK" ref="a33065392a618a5b52ac4bb40fb12baf5" args="(safeWriteValueType &amp;updateMe, const safeWriteValueType *newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename safeWriteValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::_safeWriteValueNK </td>
          <td>(</td>
          <td class="paramtype">safeWriteValueType &amp;&nbsp;</td>
          <td class="paramname"> <em>updateMe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const safeWriteValueType *&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely writes a value using critical sections to a non key variable. </p>
<p>Non key means that it does not require write access when changing (see class description for reasoning). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>updateMe</em>&nbsp;</td><td>Reference to object to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newValue</em>&nbsp;</td><td>Pointer to value to copy into <em>updateMe</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03501e21a7e927dba93ed19895b407de"></a><!-- doxytag: member="ConcurrencyControl::Cleanup" ref="a03501e21a7e927dba93ed19895b407de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::Cleanup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up object and resets variables to default. </p>
<p>Object can be reused if <code>Construct</code> is used again. </p>

</div>
</div>
<a class="anchor" id="a24e5689f704351208afc2cb7b4efbcec"></a><!-- doxytag: member="ConcurrencyControl::Construct" ref="a24e5689f704351208afc2cb7b4efbcec" args="(size_t numThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>paraThreads</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up object ready for use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paraThreads</em>&nbsp;</td><td>Number of threads that will be using object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc7743380ba3da2385fd052de30f144"></a><!-- doxytag: member="ConcurrencyControl::EnterWrite" ref="aadc7743380ba3da2385fd052de30f144" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::EnterWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely take write control of object. </p>
<p>Read control will be released before taking write control, and then retaken (to the same depth) after taking write control. This is done in order to prevent deadlock. </p>

</div>
</div>
<a class="anchor" id="a3a0351a48b92570778544957dd181f17"></a><!-- doxytag: member="ConcurrencyControl::GetNumThreads" ref="a3a0351a48b92570778544957dd181f17" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ConcurrencyControl::GetNumThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of threads setup to use this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of threads setup to use this object.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Thread ID's for this object range from inclusive 0 to exclusive number of threads. </dd></dl>

</div>
</div>
<a class="anchor" id="afd31026e93f3ea692eb93d638e1c643b"></a><!-- doxytag: member="ConcurrencyControl::GetThreadID" ref="afd31026e93f3ea692eb93d638e1c643b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ConcurrencyControl::GetThreadID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the calling thread's manual thread ID. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the calling thread's manual thread ID. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3a9f4eb59ff8f5dfaecfec57d0f1d14"></a><!-- doxytag: member="ConcurrencyControl::TestClass" ref="ab3a9f4eb59ff8f5dfaecfec57d0f1d14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConcurrencyControl::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<p>It is difficult to test for race condition but this is done by changing a pointer; if a thread does not wait for the pointer to be changed back, to point to something meaningful, the debugger will detect writing to a bad memory location. The debugger does not seem to detect two threads modifying the same variable at the same time. <br/>
<br/>
</p>
<p>When running this test you should check for:</p>
<ul>
<li>Debugger alerts.</li>
<li>Deadlock.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7dc3ba467d27bfa118d1929b5a5d90"></a><!-- doxytag: member="ConcurrencyControl::ValidateThreadID" ref="a7d7dc3ba467d27bfa118d1929b5a5d90" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcurrencyControl::ValidateThreadID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that thread ID is in bounds, and throws an exception if it is not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a83a545f7c4a64d11dab7fd1931155182"></a><!-- doxytag: member="ConcurrencyControl::access" ref="a83a545f7c4a64d11dab7fd1931155182" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_critical_section.html">CriticalSection</a>* <a class="el" href="class_concurrency_control.html#a83a545f7c4a64d11dab7fd1931155182">ConcurrencyControl::access</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Critical section object, used to control access to object. </p>
<p>Each thread will have one private critical section. </p>

</div>
</div>
<a class="anchor" id="af07ace0cc51f0411ac09198e106a1123"></a><!-- doxytag: member="ConcurrencyControl::accessRead" ref="af07ace0cc51f0411ac09198e106a1123" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t* <a class="el" href="class_concurrency_control.html#af07ace0cc51f0411ac09198e106a1123">ConcurrencyControl::accessRead</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keeps a count of how many levels of read control each thread has. </p>
<p>e.g. If a thread uses <a class="el" href="class_concurrency_control.html#aa2d6142d40a726d64148965aa9bd13fe" title="Take read control of object.">EnterRead()</a> 4 times and then <a class="el" href="class_concurrency_control.html#a98d2523a22ecac7c03e5b10e431d613d" title="Release read control of object.">LeaveRead()</a> twice, at this point it now has 2 levels of read control which is noted by this object.<br/>
<br/>
</p>
<p>Each thread will have its own private read count. </p>

</div>
</div>
<a class="anchor" id="ab0de7910c0fb51c3843f65e8cd40ae7c"></a><!-- doxytag: member="ConcurrencyControl::accessWrite" ref="ab0de7910c0fb51c3843f65e8cd40ae7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t* <a class="el" href="class_concurrency_control.html#ab0de7910c0fb51c3843f65e8cd40ae7c">ConcurrencyControl::accessWrite</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keeps a count of how many levels of write control each thread has. </p>
<p>e.g. If a thread uses <a class="el" href="class_concurrency_control.html#aadc7743380ba3da2385fd052de30f144" title="Safely take write control of object.">EnterWrite()</a> 4 times and then <a class="el" href="class_concurrency_control.html#a1b495ca39efffd3194c771b8c83931cd" title="Release write control of object.">LeaveWrite()</a> twice, at this point it now has 2 levels of write control which is noted by this object.<br/>
<br/>
</p>
<p>Each thread will have its own private write count. </p>

</div>
</div>
<a class="anchor" id="a0a94abcc70c42d61b057bddeb32a6e52"></a><!-- doxytag: member="ConcurrencyControl::threads" ref="a0a94abcc70c42d61b057bddeb32a6e52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_concurrency_control.html#a0a94abcc70c42d61b057bddeb32a6e52">ConcurrencyControl::threads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of threads that can use object. </p>
<p>Thread IDs range from 0 (inclusive) to maximum number of threads (non inclusive). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_concurrency_control_8h_source.html">ConcurrencyControl.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/ConcurrencyControl.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:18 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
