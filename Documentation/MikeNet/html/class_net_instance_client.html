<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetInstanceClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetInstanceClient Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetInstanceClient" --><!-- doxytag: inherits="NetInstanceImplementedTCP,NetInstanceUDP" -->
<p>Client instance, designed to communicate with servers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_instance_client_8h_source.html">NetInstanceClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetInstanceClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_instance_client.png" usemap="#NetInstanceClient_map" alt=""/>
  <map id="NetInstanceClient_map" name="NetInstanceClient_map">
<area href="class_net_instance_implemented_t_c_p.html" alt="NetInstanceImplementedTCP" shape="rect" coords="0,112,171,136"/>
<area href="class_net_instance_u_d_p.html" alt="NetInstanceUDP" shape="rect" coords="181,112,352,136"/>
<area href="class_net_instance_t_c_p.html" alt="NetInstanceTCP" shape="rect" coords="0,56,171,80"/>
<area href="class_net_instance.html" alt="NetInstance" shape="rect" coords="181,56,352,80"/>
<area href="class_net_instance.html" alt="NetInstance" shape="rect" coords="0,0,171,24"/>
</map>
</div>

<p><a href="class_net_instance_client-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a1cdd2b3d780fd8ef0ab9cbebedc0b6a5">GetRecvSizeMinTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the minimum TCP receive buffer size.  <a href="#a1cdd2b3d780fd8ef0ab9cbebedc0b6a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a30b1dcba17c247fabb928e5dbca54356">GetRecvSizeMinUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the minimum UDP receive buffer size.  <a href="#a30b1dcba17c247fabb928e5dbca54356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a647f159bf7881c64ee82dde6498e1a32">GetConnectTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of time in milliseconds that handshaking process should be allowed before aborting the process.  <a href="#a647f159bf7881c64ee82dde6498e1a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a7f78d5c9c831e9ffce2e4859179e0245">Connect</a> (const <a class="el" href="class_net_address.html">NetAddress</a> *addressTCP, const <a class="el" href="class_net_address.html">NetAddress</a> *addressUDP, size_t connectionTimeout, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins connecting to server.  <a href="#a7f78d5c9c831e9ffce2e4859179e0245"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a9881a9387f7e46f690e7ae65a9a951c7">ThreadHandshakeRoutine</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negotiates a connection with the server.  <a href="#a9881a9387f7e46f690e7ae65a9a951c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a9f96ef6d39ce2b6a23e3a1f7fa13599f">PollConnect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the status of handshaking process.  <a href="#a9f96ef6d39ce2b6a23e3a1f7fa13599f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#aa85847af595e3e562ba00b4ec2f2f3e0">StopConnect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels the handshaking process.  <a href="#aa85847af595e3e562ba00b4ec2f2f3e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a06bd377c8014d5d0b684db8f80fb5a06">IsConnecting</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the client is in the process of connecting to a server.  <a href="#a06bd377c8014d5d0b684db8f80fb5a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#aaf717e0f3dbe49a86b8473ad093c7176">ClientConnected</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the status of the connection with the server.  <a href="#aaf717e0f3dbe49a86b8473ad093c7176"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#ad8d5d608125edbbd11283b5b31031ea5">GetConnectionState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the state that the connection is in.  <a href="#ad8d5d608125edbbd11283b5b31031ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a55e57774e40393af927fa2a517a2a2a8">ErrorOccurred</a> (size_t <a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with errors.  <a href="#a55e57774e40393af927fa2a517a2a2a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a92a62257550ff1d2d4db8b47ed55e8b7">DoRecv</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *socket, size_t <a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a receive operation and deals with errors appropriately.  <a href="#a92a62257550ff1d2d4db8b47ed55e8b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a81244ebf13908fd198a79de50afc6a2a">CompletionError</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *completionSocket, size_t <a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the completion port when an error occurred during an operation.  <a href="#a81244ebf13908fd198a79de50afc6a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a44604d72abe620f617bf26c7fe497e70">DoRawSendUDP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a raw send operation via UDP and deals with errors in a client specific way.  <a href="#a44604d72abe620f617bf26c7fe497e70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a66e97eb71dc131728b526d911a3b8548">NetInstanceClient</a> (<a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> *<a class="el" href="class_net_instance_implemented_t_c_p.html#adb7cac7d6ca26729e2eb83ae7f6ad984">socketTCP</a>, <a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> *<a class="el" href="class_net_instance_u_d_p.html#af86e8343ddf2daf0ce3f9ea701bc7cf3">socketUDP</a>, bool <a class="el" href="class_net_instance_t_c_p.html#af13f96901d3006beeda0c161f32cbfde">handshakeEnabled</a>, unsigned int <a class="el" href="class_net_instance.html#a39ed2f4325ce50a7c374ab6253650608">sendTimeout</a>=INFINITE, const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *<a class="el" href="class_net_instance_client.html#abfd45e00771b132f08c2aea9bf582a3e">decryptKey</a>=NULL, size_t <a class="el" href="class_net_instance.html#a46bab6fc672f987ee3c52daabffe34f7">instanceID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a66e97eb71dc131728b526d911a3b8548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a0e7b8b830889578da1f5fd3d89dc08bb">NetInstanceClient</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, size_t <a class="el" href="class_net_instance.html#a46bab6fc672f987ee3c52daabffe34f7">instanceID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, using profile instead of individual parameters.  <a href="#a0e7b8b830889578da1f5fd3d89dc08bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#aa5b7843b4ca224e1f20a489050a40e19">~NetInstanceClient</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#aa5b7843b4ca224e1f20a489050a40e19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#abf711774516cb172ff615894c9d7a8e1">SendUDP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, size_t <a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via UDP to the server.  <a href="#abf711774516cb172ff615894c9d7a8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a890f6f61e7a48a642fdaa232a86f08f1">SendToUDP</a> (const <a class="el" href="class_net_address.html">NetAddress</a> &amp;address, const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via UDP to a remote address.  <a href="#a890f6f61e7a48a642fdaa232a86f08f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#abc531c75e610e232efe67d5fcbc1dae4">GetMaxClients</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves maximum number of clients that can be connected to server at any one time.  <a href="#abc531c75e610e232efe67d5fcbc1dae4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a4eb551374eb94ebd3e77e58291ed9549">GetClientID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves client ID allocated by server.  <a href="#a4eb551374eb94ebd3e77e58291ed9549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a71c2b11a56a18ae3b1c3a76390776ee9">DealCompletion</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *socket, DWORD bytes, size_t <a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When send and receive operations are completed on this instance, this method is called.  <a href="#a71c2b11a56a18ae3b1c3a76390776ee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a6d9671a1416d1de06d8013ec02d78692">CloseSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes any sockets in use by the instance.  <a href="#a6d9671a1416d1de06d8013ec02d78692"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a90bfd05103f12264ee2293ccd71081f4">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#a90bfd05103f12264ee2293ccd71081f4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667185822294a7c9f93ddd496e638a24"></a><!-- doxytag: member="NetInstanceClient::recvSizeMinUDP" ref="a667185822294a7c9f93ddd496e638a24" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a667185822294a7c9f93ddd496e638a24">recvSizeMinUDP</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum UDP buffer size necessary to maintain normal operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af35177f5736c4cc487097de91dae6df4"></a><!-- doxytag: member="NetInstanceClient::recvSizeMinTCP" ref="af35177f5736c4cc487097de91dae6df4" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#af35177f5736c4cc487097de91dae6df4">recvSizeMinTCP</a> = 33</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum TCP buffer size necessary to maintain normal operations. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a5d26a06879c6111dc12aedd7454de74c">Initialize</a> (const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *<a class="el" href="class_net_instance_client.html#abfd45e00771b132f08c2aea9bf582a3e">decryptKey</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes object.  <a href="#a5d26a06879c6111dc12aedd7454de74c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#ae59a0afcae755a2d07eefe7b4c37c689">HelperHandshakeStatus</a> (const <a class="el" href="class_timer.html">Timer</a> &amp;timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by handshaking thread to determine whether the process should be aborted.  <a href="#ae59a0afcae755a2d07eefe7b4c37c689"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd45e00771b132f08c2aea9bf582a3e"></a><!-- doxytag: member="NetInstanceClient::decryptKey" ref="abfd45e00771b132f08c2aea9bf582a3e" args="" -->
const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#abfd45e00771b132f08c2aea9bf582a3e">decryptKey</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary store to communicate with handshaking thread, which may need to know this when creating modeUDP object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10315644a2c7ffd820d8a6b2ad0f504"></a><!-- doxytag: member="NetInstanceClient::recvSizeUDP" ref="af10315644a2c7ffd820d8a6b2ad0f504" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#af10315644a2c7ffd820d8a6b2ad0f504">recvSizeUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary store to communicate with handshaking thread, which may need to know this when creating modeUDP object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3830bd923adb2bcd574a9e06edf304ce"></a><!-- doxytag: member="NetInstanceClient::timeoutMilliseconds" ref="a3830bd923adb2bcd574a9e06edf304ce" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a3830bd923adb2bcd574a9e06edf304ce">timeoutMilliseconds</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum length of time that client would wait before giving up on connection process. Exists to pass information to the handshaking thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab03cb69d1c904f442b29e1f4665c3be7"></a><!-- doxytag: member="NetInstanceClient::connectionStatus" ref="ab03cb69d1c904f442b29e1f4665c3be7" args="" -->
<a class="el" href="class_concurrent_object.html">ConcurrentObject</a><br class="typebreak"/>
&lt; <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#ab03cb69d1c904f442b29e1f4665c3be7">connectionStatus</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the state of the connection process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc188a88da7ab851bc3ac4d9287fe342"></a><!-- doxytag: member="NetInstanceClient::clientID" ref="abc188a88da7ab851bc3ac4d9287fe342" args="" -->
<a class="el" href="class_concurrent_object.html">ConcurrentObject</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#abc188a88da7ab851bc3ac4d9287fe342">clientID</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID of client (as allocated by server), filled during the handshaking process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad07bedf8749aa191a16bfd72434bd80d"></a><!-- doxytag: member="NetInstanceClient::maxClients" ref="ad07bedf8749aa191a16bfd72434bd80d" args="" -->
<a class="el" href="class_concurrent_object.html">ConcurrentObject</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#ad07bedf8749aa191a16bfd72434bd80d">maxClients</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of clients that can be connected to server (that we are connected to) at any one time, filled during the handshaking process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade1e8bb0bc0cdfefa23aa56c63dc72dd"></a><!-- doxytag: member="NetInstanceClient::handshakeThread" ref="ade1e8bb0bc0cdfefa23aa56c63dc72dd" args="" -->
<a class="el" href="class_thread_single.html">ThreadSingle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#ade1e8bb0bc0cdfefa23aa56c63dc72dd">handshakeThread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread to perform handshaking process with server. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9b110b29ed61db3c5e92e5040fcc6f"></a><!-- doxytag: member="NetInstanceClient::handshakeError" ref="a9c9b110b29ed61db3c5e92e5040fcc6f" args="" -->
<a class="el" href="class_error_report.html">ErrorReport</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a9c9b110b29ed61db3c5e92e5040fcc6f">handshakeError</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores error that occurred in handshake thread so that it can be thrown from PollConnect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b5f778d25fb1a772eae7662788ff21f"></a><!-- doxytag: member="NetInstanceClient::handshakeErrorOccurred" ref="a4b5f778d25fb1a772eae7662788ff21f" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_client.html#a4b5f778d25fb1a772eae7662788ff21f">handshakeErrorOccurred</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if an error occurred in handshake thread. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Client instance, designed to communicate with servers. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This instance uses TCP and UDP to communicate with servers. Most commonly it will be used to communicate with another entity running a <a class="el" href="class_net_instance_server.html" title="Server instance, designed to communicate with clients.">NetInstanceServer</a> instance. However, this instance can also communicate with other entities such as web servers. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a66e97eb71dc131728b526d911a3b8548"></a><!-- doxytag: member="NetInstanceClient::NetInstanceClient" ref="a66e97eb71dc131728b526d911a3b8548" args="(NetSocketTCP *socketTCP, NetSocketUDP *socketUDP, bool handshakeEnabled, unsigned int sendTimeout=INFINITE, const EncryptKey *decryptKey=NULL, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceClient::NetInstanceClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>p_sendTimeout</em> = <code>INFINITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td>
          <td class="paramname"> <em>p_decryptKey</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_socketTCP</em>&nbsp;</td><td>Socket to use to send and receive TCP data. This pointer and its data is now owned by this object and should not be used elsewhere. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_socketUDP</em>&nbsp;</td><td>Socket to use to send and receive UDP data, NULL if UDP is disabled. This pointer and its data is now owned by this object and should not be used elsewhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>True if the TCP handshaking process is enabled, false if not. For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_sendTimeout</em>&nbsp;</td><td>Length of time in milliseconds to wait for a send operation to complete before disconnecting client (optional, default INFINITE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_decryptKey</em>&nbsp;</td><td>Pointer to a <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object to be used to decrypt UDP data (optional, default NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>Unique identifier for instance (optional, default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If p_socketTCP-&gt;GetRecvBufferLength() &lt; <a class="el" href="class_net_instance_client.html#a1cdd2b3d780fd8ef0ab9cbebedc0b6a5" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e7b8b830889578da1f5fd3d89dc08bb"></a><!-- doxytag: member="NetInstanceClient::NetInstanceClient" ref="a0e7b8b830889578da1f5fd3d89dc08bb" args="(const NetInstanceProfile &amp;profile, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceClient::NetInstanceClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, using profile instead of individual parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_profile</em>&nbsp;</td><td>Instance profile containing parameters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>Unique identifier for instance (optional, default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If p_profile.GetRecvSizeTCP() &lt; <a class="el" href="class_net_instance_client.html#a1cdd2b3d780fd8ef0ab9cbebedc0b6a5" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5b7843b4ca224e1f20a489050a40e19"></a><!-- doxytag: member="NetInstanceClient::~NetInstanceClient" ref="aa5b7843b4ca224e1f20a489050a40e19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceClient::~NetInstanceClient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>CloseSockets must be used in the destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaf717e0f3dbe49a86b8473ad093c7176"></a><!-- doxytag: member="NetInstanceClient::ClientConnected" ref="aaf717e0f3dbe49a86b8473ad093c7176" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::ClientConnected </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the status of the connection with the server. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a>: Fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6daef8b7210b8ae3961e19fcde743ee08af">NetUtility::NOT_CONNECTED</a>: Not connected at all. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dad749d5c33d1f4fda670efe634f651885">NetUtility::NO_RECV</a>: Connected but new data cannot be received because <code>Shutdown</code> has been used by recipient (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da1bcc92a56bd754f0e02e33787f7f9e38">NetUtility::NO_SEND</a>: Connected but data cannot be sent because <code>Shutdown</code> has been used (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabfdb16770f1140f86d621739ffe89560">NetUtility::NO_SEND_RECV</a>: Connected but data cannot be sent or received because <code>Shutdown</code> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if graceful disconnect is enabled). </dd></dl>

</div>
</div>
<a class="anchor" id="a6d9671a1416d1de06d8013ec02d78692"></a><!-- doxytag: member="NetInstanceClient::CloseSockets" ref="a6d9671a1416d1de06d8013ec02d78692" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::CloseSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes any sockets in use by the instance. </p>
<p>Must be called in the destructor so that instance is not cleaned up until completion port is done using it. </p>

<p>Reimplemented from <a class="el" href="class_net_instance_u_d_p.html#a34eddd0dac655a1f3ec2950f6c15a456">NetInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a81244ebf13908fd198a79de50afc6a2a"></a><!-- doxytag: member="NetInstanceClient::CompletionError" ref="a81244ebf13908fd198a79de50afc6a2a" args="(NetSocket *completionSocket, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::CompletionError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>completionSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the completion port when an error occurred during an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>completionSocket</em>&nbsp;</td><td>The socket responsible for the error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Ignored (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#a6f1377ef6caee467d27288cf53619b37">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="a7f78d5c9c831e9ffce2e4859179e0245"></a><!-- doxytag: member="NetInstanceClient::Connect" ref="a7f78d5c9c831e9ffce2e4859179e0245" args="(const NetAddress *addressTCP, const NetAddress *addressUDP, size_t connectionTimeout, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>addressTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>addressUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>connectionTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins connecting to server. </p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addressTCP</em>&nbsp;</td><td>TCP IP and port of server that we should attempt to connect to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressUDP</em>&nbsp;</td><td>UDP IP and port of server that we should attempt to connect to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectionTimeout</em>&nbsp;</td><td>Length of time in milliseconds that connection attempt should last before it should abort (applies to non blocking too). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the connection attempt is done synchronously and the method will not return until the connection attempt completes or fails. If false the connection attempt is done asynchronously and the method will return straight away, PollConnect and StopConnect should then be used to manage the connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabc894c2de7a4404e353f3bcc1193e90b">NetUtility::REFUSED</a> if the server is full and so the connection attempt failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a71c2b11a56a18ae3b1c3a76390776ee9"></a><!-- doxytag: member="NetInstanceClient::DealCompletion" ref="a71c2b11a56a18ae3b1c3a76390776ee9" args="(NetSocket *socket, DWORD bytes, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::DealCompletion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When send and receive operations are completed on this instance, this method is called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>[in,out] Socket that operation was started by. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>Number of bytes of data transferred in operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Ignored (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#a77a9c992d7ab0b023de51470a3392c49">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="a44604d72abe620f617bf26c7fe497e70"></a><!-- doxytag: member="NetInstanceClient::DoRawSendUDP" ref="a44604d72abe620f617bf26c7fe497e70" args="(const Packet &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetInstanceClient::DoRawSendUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a raw send operation via UDP and deals with errors in a client specific way. </p>
<p>The packet will be sent as is with no modification, regardless of UDP mode.<br/>
<br/>
</p>
<p>Calls <a class="el" href="class_net_socket_u_d_p.html#ad05b84f0d746d2f8cdd33b36109f541b" title="Sends an unmodified packet, ignoring the UDP mode.">NetSocketUDP::RawSend</a>. Use this INSTEAD OF socketUDP-&gt;RawSend, never use socketUDP-&gt;RawSend directly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="a92a62257550ff1d2d4db8b47ed55e8b7"></a><!-- doxytag: member="NetInstanceClient::DoRecv" ref="a92a62257550ff1d2d4db8b47ed55e8b7" args="(NetSocket *socket, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::DoRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a receive operation and deals with errors appropriately. </p>
<p>Calls NetSocket***Recv. Use this INSTEAD OF socket***-&gt;Recv, never use socket***-&gt;Recv directly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>[in,out] Pointer to socket that receive operation should be started on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Ignored (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#a3c3e7a1dfd8e6c54c25f2a61aa86f183">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="a55e57774e40393af927fa2a517a2a2a8"></a><!-- doxytag: member="NetInstanceClient::ErrorOccurred" ref="a55e57774e40393af927fa2a517a2a2a8" args="(size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::ErrorOccurred </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with errors. </p>
<p>Signals instance to be shutdown, ClientConnected will do this when it is next called. The instance is not shutdown directly because it is important that instance shutdown is done by the main process and not by a worker thread (a worker thread may call this method).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Ignored (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#ab3369f37337a9de2cbefe92f0bf1d087">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="a4eb551374eb94ebd3e77e58291ed9549"></a><!-- doxytag: member="NetInstanceClient::GetClientID" ref="a4eb551374eb94ebd3e77e58291ed9549" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceClient::GetClientID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves client ID allocated by server. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>ID of client (as allocated by server), filled during the handshaking process. </p>
 </dd>
<dd>
0 if the client is not fully connected to the server. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8d5d608125edbbd11283b5b31031ea5"></a><!-- doxytag: member="NetInstanceClient::GetConnectionState" ref="ad8d5d608125edbbd11283b5b31031ea5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::GetConnectionState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the state that the connection is in. </p>
<p>Unlike <a class="el" href="class_net_instance_client.html#aaf717e0f3dbe49a86b8473ad093c7176" title="Determines the status of the connection with the server.">NetInstanceClient::ClientConnected</a>, the raw state of the connection is returned and no further action is taken.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the connection state. </dd></dl>

</div>
</div>
<a class="anchor" id="a647f159bf7881c64ee82dde6498e1a32"></a><!-- doxytag: member="NetInstanceClient::GetConnectTimeout" ref="a647f159bf7881c64ee82dde6498e1a32" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceClient::GetConnectTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Length of time in milliseconds that handshaking process should be allowed before aborting the process. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of time in milliseconds that handshaking process should be allowed before aborting the process. </dd></dl>

</div>
</div>
<a class="anchor" id="abc531c75e610e232efe67d5fcbc1dae4"></a><!-- doxytag: member="NetInstanceClient::GetMaxClients" ref="abc531c75e610e232efe67d5fcbc1dae4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceClient::GetMaxClients </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves maximum number of clients that can be connected to server at any one time. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Maximum number of clients that can be connected to server (that we are connected to) at any one time, filled during the handshaking process. </p>
 </dd>
<dd>
0 if the client is not fully connected to the server. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cdd2b3d780fd8ef0ab9cbebedc0b6a5"></a><!-- doxytag: member="NetInstanceClient::GetRecvSizeMinTCP" ref="a1cdd2b3d780fd8ef0ab9cbebedc0b6a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceClient::GetRecvSizeMinTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the minimum TCP receive buffer size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum TCP receive buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="a30b1dcba17c247fabb928e5dbca54356"></a><!-- doxytag: member="NetInstanceClient::GetRecvSizeMinUDP" ref="a30b1dcba17c247fabb928e5dbca54356" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceClient::GetRecvSizeMinUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the minimum UDP receive buffer size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum UDP receive buffer size. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_u_d_p.html#a66b09a826a620f60707158d5cb11febc">NetInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ae59a0afcae755a2d07eefe7b4c37c689"></a><!-- doxytag: member="NetInstanceClient::HelperHandshakeStatus" ref="ae59a0afcae755a2d07eefe7b4c37c689" args="(const Timer &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::HelperHandshakeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_timer.html">Timer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by handshaking thread to determine whether the process should be aborted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Object used to determine when the connection process has timed out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NetUtility::TIME_OUT if the handshaking process timed out, or if the process was terminated upon request. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred in the completion port. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9d19ff7a0b7766eb4176922a19ff44af">NetUtility::CONNECTING</a> if the process is still in progress with no critical problems. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d26a06879c6111dc12aedd7454de74c"></a><!-- doxytag: member="NetInstanceClient::Initialize" ref="a5d26a06879c6111dc12aedd7454de74c" args="(const EncryptKey *decryptKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td>
          <td class="paramname"> <em>p_decryptKey</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_decryptKey</em>&nbsp;</td><td>Pointer (casted to long long int) to a <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object to be used to decrypt UDP data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>SocketUDP Must be initialized before using this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a06bd377c8014d5d0b684db8f80fb5a06"></a><!-- doxytag: member="NetInstanceClient::IsConnecting" ref="a06bd377c8014d5d0b684db8f80fb5a06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceClient::IsConnecting </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the client is in the process of connecting to a server. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if connecting, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f96ef6d39ce2b6a23e3a1f7fa13599f"></a><!-- doxytag: member="NetInstanceClient::PollConnect" ref="a9f96ef6d39ce2b6a23e3a1f7fa13599f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::PollConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the status of handshaking process. </p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da86caa623f8ffc60da40df3c2ab17532c">NetUtility::STILL_CONNECTING</a> if the handshaking process is in progress still. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabc894c2de7a4404e353f3bcc1193e90b">NetUtility::REFUSED</a> if the server is full and so the connection attempt failed. </dd></dl>

<p><p>Start receiving UDP packets. This is done here instead of during handshaking because once thread exits operation is aborted.</p>
<p>Connect temporarily disabled the user receive function so that the handshaking process can use the packet queue system. This reverses that process now that we are done with the packet queue.</p>
<p>If handshake is enabled then we have already started receiving. TCP packets and so don't need to call DoRecvTCP.</p>
<p>If handshake is enabled then the completion port will have passed all TCP packets to the packet queue system rather than any specified user function so that the handshaking thread can receive TCP data. This means that any packets left in the queue that were received while handshaking should now be passed to the user function if one exists.</p>
<p>Starts a TCP receive operation. Must be done here because on thread exit receive operation would be canceled, since no packet is received on it first.</p>
</p>

</div>
</div>
<a class="anchor" id="a890f6f61e7a48a642fdaa232a86f08f1"></a><!-- doxytag: member="NetInstanceClient::SendToUDP" ref="a890f6f61e7a48a642fdaa232a86f08f1" args="(const NetAddress &amp;address, const Packet &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceClient::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via UDP to a remote address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Remote address to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> If the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> If the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> If the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> If the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implements <a class="el" href="class_net_instance_u_d_p.html#aab521333fd0aabf0b8343fe132494975">NetInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="abf711774516cb172ff615894c9d7a8e1"></a><!-- doxytag: member="NetInstanceClient::SendUDP" ref="abf711774516cb172ff615894c9d7a8e1" args="(const Packet &amp;packet, bool block, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceClient::SendUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via UDP to the server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implements <a class="el" href="class_net_instance_u_d_p.html#afa565c78a2549b3b21ea4b1dedd33793">NetInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="aa85847af595e3e562ba00b4ec2f2f3e0"></a><!-- doxytag: member="NetInstanceClient::StopConnect" ref="aa85847af595e3e562ba00b4ec2f2f3e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceClient::StopConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels the handshaking process. </p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. The handshaking must be in progress otherwise this command will fail.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>PollConnect should not be used after this command, it will fail . </dd></dl>

</div>
</div>
<a class="anchor" id="a90bfd05103f12264ee2293ccd71081f4"></a><!-- doxytag: member="NetInstanceClient::TestClass" ref="a90bfd05103f12264ee2293ccd71081f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceClient::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

</div>
</div>
<a class="anchor" id="a9881a9387f7e46f690e7ae65a9a951c7"></a><!-- doxytag: member="NetInstanceClient::ThreadHandshakeRoutine" ref="a9881a9387f7e46f690e7ae65a9a951c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceClient::ThreadHandshakeRoutine </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negotiates a connection with the server. </p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Receive operations are canceled when the thread who initiated them exits this means that initiating a receive operation that is not guaranteed to have completed before this thread exits is wrong. Note that if the operation completes the completion port will then initiate a new one which is not bound to this thread.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out or was manually aborted by manipulating <em>thread</em>. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd></dl>

<p><p>If TCP handshake is not enabled then we don't need to wait for a TCP packet from the server and the connection process is now complete.</p>
<p>Start receiving via TCP. When thread exits further receive operations will be canceled. It is okay to do this here because thread will receive data before exiting.</p>
<p>Send UDP packet to confirm our connection. Done in this way to get traverse Network Address Translation enabled routers. Message sending is repeated due to possibility of UDP packet loss.</p>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_instance_client_8h_source.html">NetInstanceClient.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetInstanceClient.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:19 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
