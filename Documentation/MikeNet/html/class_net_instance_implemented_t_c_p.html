<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetInstanceImplementedTCP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>NetInstanceImplementedTCP Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetInstanceImplementedTCP" --><!-- doxytag: inherits="NetInstanceTCP" -->
<p>Implements <a class="el" href="class_net_instance_t_c_p.html" title="TCP instance class responsible for managing all TCP operations on at an instance level.">NetInstanceTCP</a> with a standard setup for using a TCP socket (<a class="el" href="class_net_socket_t_c_p.html" title="Socket used for TCP data transfer.">NetSocketTCP</a>).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_instance_implemented_t_c_p_8h_source.html">NetInstanceImplementedTCP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetInstanceImplementedTCP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_instance_implemented_t_c_p.png" usemap="#NetInstanceImplementedTCP_map" alt=""/>
  <map id="NetInstanceImplementedTCP_map" name="NetInstanceImplementedTCP_map">
<area href="class_net_instance_t_c_p.html" alt="NetInstanceTCP" shape="rect" coords="90,56,261,80"/>
<area href="class_net_instance.html" alt="NetInstance" shape="rect" coords="90,0,261,24"/>
<area href="class_net_instance_client.html" alt="NetInstanceClient" shape="rect" coords="0,168,171,192"/>
<area href="class_net_server_client.html" alt="NetServerClient" shape="rect" coords="181,168,352,192"/>
</map>
</div>

<p><a href="class_net_instance_implemented_t_c_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a08d96bacc608747199f8ded78a8f4aa4">NetInstanceImplementedTCP</a> (<a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> *<a class="el" href="class_net_instance_implemented_t_c_p.html#adb7cac7d6ca26729e2eb83ae7f6ad984">socketTCP</a>, bool <a class="el" href="class_net_instance_t_c_p.html#af13f96901d3006beeda0c161f32cbfde">handshakeEnabled</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a08d96bacc608747199f8ded78a8f4aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f4f6e406c5e6502b23ce0d648e575e2"></a><!-- doxytag: member="NetInstanceImplementedTCP::~NetInstanceImplementedTCP" ref="a1f4f6e406c5e6502b23ce0d648e575e2" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a1f4f6e406c5e6502b23ce0d648e575e2">~NetInstanceImplementedTCP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#ae675735ecca9c5dc9a8502cc97cee13d">IsGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled.  <a href="#ae675735ecca9c5dc9a8502cc97cee13d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a51786db50076d9ef1499f95ef82627ff">GetMaxPacketSizeTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the size of the largest packet that can be received without resizing the receive buffer.  <a href="#a51786db50076d9ef1499f95ef82627ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a33b22ccf2a20a7fc5c40514e277a4522">GetRecvBufferLengthTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the maximum amount of data that can be received in one TCP socket receive operation.  <a href="#a33b22ccf2a20a7fc5c40514e277a4522"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aba953b84f3380ab787bfbe6283eb9ec5">GetPartialPacketCurrentSizeTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of the current partial packet that has been received in bytes.  <a href="#aba953b84f3380ab787bfbe6283eb9ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a2ca4fa7ddd6ea7e6f3b5c1515d2e34ad">GetPartialPacketPercentageTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of the current partial packet that has been received as a percentage.  <a href="#a2ca4fa7ddd6ea7e6f3b5c1515d2e34ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aa4d55c285a282ee0da229ddc28fbd814">SetMaxPacketSizeTCP</a> (size_t newMaxSize=0, size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manually changes the maximum packet size that can be received.  <a href="#aa4d55c285a282ee0da229ddc28fbd814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#ab72f32de68da213238539eed8c399bd5">GetAutoResizeTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the auto resize TCP option is enabled.  <a href="#ab72f32de68da213238539eed8c399bd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a39295cf5003406e66e8235d88bb2e282">SetAutoResizeTCP</a> (bool newAutoResizeTCP=0, size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the auto resize TCP option.  <a href="#a39295cf5003406e66e8235d88bb2e282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a2f21e2227f935bdc92aa09d1fdb4ad18">GetProtocolModeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP protocol mode in use.  <a href="#a2f21e2227f935bdc92aa09d1fdb4ad18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aa8ed75c6b08d2973ad5ab56fb33b6265">GetNagleEnabledTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the nagle algorithm is enabled.  <a href="#aa8ed75c6b08d2973ad5ab56fb33b6265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a533d763914c21bba7e70d36116e432a1">GetPostfixTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP postfix in use.  <a href="#a533d763914c21bba7e70d36116e432a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#afa6ba30d5b40f92a555bc870fd3ce118">GetLocalAddressTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP address of the instance.  <a href="#afa6ba30d5b40f92a555bc870fd3ce118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aa4b2a445f693614d4a6515886cda5148">GetConnectAddressTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP address that the instance is connected to.  <a href="#aa4b2a445f693614d4a6515886cda5148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aa8ca0a407982129948841ccf1825533b">FlushRecvTCP</a> (size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the received TCP packet queue.  <a href="#aa8ca0a407982129948841ccf1825533b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a4ac64bdf989a0b15a949b9568465b0f2">GetPacketAmountTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of packets in the received TCP packet queue.  <a href="#a4ac64bdf989a0b15a949b9568465b0f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a35cc59e1f2ad733f7f5138e4233688ba">ShutdownTCP</a> (size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the graceful disconnection process.  <a href="#a35cc59e1f2ad733f7f5138e4233688ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a6f2ba030a5543dac75864ba1e35d9398">GetPacketFromStoreTCP</a> (<a class="el" href="class_packet.html">Packet</a> *destination=0, size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a complete packet from the TCP packet store.  <a href="#a6f2ba030a5543dac75864ba1e35d9398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#ab94301400c9a2fef68292b0b75d2d626">SendTCP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block=0, size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via TCP to the server.  <a href="#ab94301400c9a2fef68292b0b75d2d626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a2ec2ee88690b8c630839e19548679aaf">GetConnectionStateTCP</a> (size_t clientID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the state that the TCP connection is in.  <a href="#a2ec2ee88690b8c630839e19548679aaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a4910059fe6604122fb51d868d1df34ef">GetUserFunctionTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP function that is executed when complete TCP packets are received.  <a href="#a4910059fe6604122fb51d868d1df34ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#aa0f2ff9557ef143a128e6be859203d69">IsUserFunctionLoadedTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a TCP function has been loaded.  <a href="#aa0f2ff9557ef143a128e6be859203d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1683ef8e0863d16dff8135f97f1e6e18"></a><!-- doxytag: member="NetInstanceImplementedTCP::CloseSockets" ref="a1683ef8e0863d16dff8135f97f1e6e18" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#a1683ef8e0863d16dff8135f97f1e6e18">CloseSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes any sockets in use by the instance. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb7cac7d6ca26729e2eb83ae7f6ad984"></a><!-- doxytag: member="NetInstanceImplementedTCP::socketTCP" ref="adb7cac7d6ca26729e2eb83ae7f6ad984" args="" -->
<a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_implemented_t_c_p.html#adb7cac7d6ca26729e2eb83ae7f6ad984">socketTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket used to communicate via TCP. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implements <a class="el" href="class_net_instance_t_c_p.html" title="TCP instance class responsible for managing all TCP operations on at an instance level.">NetInstanceTCP</a> with a standard setup for using a TCP socket (<a class="el" href="class_net_socket_t_c_p.html" title="Socket used for TCP data transfer.">NetSocketTCP</a>). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 8/19/2010. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a08d96bacc608747199f8ded78a8f4aa4"></a><!-- doxytag: member="NetInstanceImplementedTCP::NetInstanceImplementedTCP" ref="a08d96bacc608747199f8ded78a8f4aa4" args="(NetSocketTCP *socketTCP, bool handshakeEnabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceImplementedTCP::NetInstanceImplementedTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>handshakeEnabled</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socket</em>&nbsp;</td><td>Socket to use to send and receive TCP data. This pointer and its data is now owned by this object and should not be used elsewhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handshakeEnabled</em>&nbsp;</td><td>True if the <a class="el" href="handshake_page.html">TCP handshake process</a> is enabled, false if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa8ca0a407982129948841ccf1825533b"></a><!-- doxytag: member="NetInstanceImplementedTCP::FlushRecvTCP" ref="aa8ca0a407982129948841ccf1825533b" args="(size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceImplementedTCP::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the received TCP packet queue. </p>
<p>When TCP packets are received and a receive function has not been set (in the constructor), packets are put into a queue and received using GetPacketFromStoreTCP. If the queue gets too big newer packets may not be received for some time and so it can be useful to empty the queue. This command discards everything in the queue.<br/>
<br/>
</p>
<p>Has no impact on the partial packet store. <br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a545e0d5c995e0b8ac43c72c786800e0b">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ab72f32de68da213238539eed8c399bd5"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetAutoResizeTCP" ref="ab72f32de68da213238539eed8c399bd5" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceImplementedTCP::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the auto resize TCP option is enabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>when true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a59cf03453fd680e8a2a0dc4395f1f70a">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b2a445f693614d4a6515886cda5148"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetConnectAddressTCP" ref="aa4b2a445f693614d4a6515886cda5148" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceImplementedTCP::GetConnectAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP address that the instance is connected to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ac856c99e8ebf03cd3822885521274ed7">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a2ec2ee88690b8c630839e19548679aaf"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetConnectionStateTCP" ref="a2ec2ee88690b8c630839e19548679aaf" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceImplementedTCP::GetConnectionStateTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the state that the TCP connection is in. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP connection state.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>GetConnectionState() and this method are unlinked. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a635bb48421cde040f391c553c437d634">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="afa6ba30d5b40f92a555bc870fd3ce118"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetLocalAddressTCP" ref="afa6ba30d5b40f92a555bc870fd3ce118" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceImplementedTCP::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP address of the instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information. This reference should remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a01155c373c9794f98a69ac05d9a2491c">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a51786db50076d9ef1499f95ef82627ff"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetMaxPacketSizeTCP" ref="a51786db50076d9ef1499f95ef82627ff" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceImplementedTCP::GetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the size of the largest packet that can be received without resizing the receive buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#acd2529df4ee98a7b2ca144a60feb1bb2">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aa8ed75c6b08d2973ad5ab56fb33b6265"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetNagleEnabledTCP" ref="aa8ed75c6b08d2973ad5ab56fb33b6265" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceImplementedTCP::GetNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the nagle algorithm is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the nagle algorithm is enabled for the instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a797c6d8f382ae72386afd0c52b45aa48">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a4ac64bdf989a0b15a949b9568465b0f2"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetPacketAmountTCP" ref="a4ac64bdf989a0b15a949b9568465b0f2" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceImplementedTCP::GetPacketAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of packets in the received TCP packet queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of fully received UDP packets in the packet store. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ac5b7728d5152d157d6b87e60081db168">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2ba030a5543dac75864ba1e35d9398"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetPacketFromStoreTCP" ref="a6f2ba030a5543dac75864ba1e35d9398" args="(Packet *destination=0, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceImplementedTCP::GetPacketFromStoreTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a complete packet from the TCP packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination to copy retrieved packet into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a602f43e93a742836c558e5f086ce52c7">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aba953b84f3380ab787bfbe6283eb9ec5"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetPartialPacketCurrentSizeTCP" ref="aba953b84f3380ab787bfbe6283eb9ec5" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceImplementedTCP::GetPartialPacketCurrentSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of the current partial packet that has been received in bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current size of the TCP partial packet being received. i.e. The number of bytes of the packet that have been received. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ab32a5b7813c41e2f7149ef8c8adede38">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a2ca4fa7ddd6ea7e6f3b5c1515d2e34ad"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetPartialPacketPercentageTCP" ref="a2ca4fa7ddd6ea7e6f3b5c1515d2e34ad" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double NetInstanceImplementedTCP::GetPartialPacketPercentageTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of the current partial packet that has been received as a percentage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the percentage of the partial packet that has been received i.e. Between 0 and 100 where 50 indicates that half the packet has been received and we are now waiting for the second half to be received. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a2d4a7129fbe74b7f2e562d5e8a1f84cf">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a533d763914c21bba7e70d36116e432a1"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetPostfixTCP" ref="a533d763914c21bba7e70d36116e432a1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packet.html">Packet</a> &amp; NetInstanceImplementedTCP::GetPostfixTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP postfix in use. </p>
<p>If TCP mode is not <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> this command will fail. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the postfix in use by the TCP instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a5509277d168a5be5d6ebc643afe34d3e">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a2f21e2227f935bdc92aa09d1fdb4ad18"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetProtocolModeTCP" ref="a2f21e2227f935bdc92aa09d1fdb4ad18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetInstanceImplementedTCP::GetProtocolModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP protocol mode in use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>protocol mode in use by instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ad6252dc4923ef58376b2c36a5cb9cbe0">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a33b22ccf2a20a7fc5c40514e277a4522"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetRecvBufferLengthTCP" ref="a33b22ccf2a20a7fc5c40514e277a4522" args="(size_t clientID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceImplementedTCP::GetRecvBufferLengthTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the maximum amount of data that can be received in one TCP socket receive operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF used by the TCP socket. <br/>
 This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a8702bf908ad147d94b4351077c9ae599">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a4910059fe6604122fb51d868d1df34ef"></a><!-- doxytag: member="NetInstanceImplementedTCP::GetUserFunctionTCP" ref="a4910059fe6604122fb51d868d1df34ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> NetInstanceImplementedTCP::GetUserFunctionTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP function that is executed when complete TCP packets are received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the method set by the user that should be executed when data is received. </dd>
<dd>
NULL if there is no method. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a8dfdf67081405105b691c15cc867725d">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ae675735ecca9c5dc9a8502cc97cee13d"></a><!-- doxytag: member="NetInstanceImplementedTCP::IsGracefulDisconnectEnabled" ref="ae675735ecca9c5dc9a8502cc97cee13d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceImplementedTCP::IsGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is possible, where data is allowed to finish sending and receiving before the connection is closed. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#aae7db49f79eaf1fd5359c084e893f946">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f2ff9557ef143a128e6be859203d69"></a><!-- doxytag: member="NetInstanceImplementedTCP::IsUserFunctionLoadedTCP" ref="aa0f2ff9557ef143a128e6be859203d69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceImplementedTCP::IsUserFunctionLoadedTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether a TCP function has been loaded. </p>
<p>If no TCP function has been loaded received packets are put into a queue and retrieved using GetPacketFromStoreTCP.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a method to be executed when data is received has been set. </dd>
<dd>
false if no method has been set. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ad1e427866c1a3703a224131c2d46fa9d">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ab94301400c9a2fef68292b0b75d2d626"></a><!-- doxytag: member="NetInstanceImplementedTCP::SendTCP" ref="ab94301400c9a2fef68292b0b75d2d626" args="(const Packet &amp;packet, bool block=0, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceImplementedTCP::SendTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via TCP to the server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a1dd6a5b47974fc6863edde6443f75a32">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a39295cf5003406e66e8235d88bb2e282"></a><!-- doxytag: member="NetInstanceImplementedTCP::SetAutoResizeTCP" ref="a39295cf5003406e66e8235d88bb2e282" args="(bool newAutoResizeTCP=0, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceImplementedTCP::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the auto resize TCP option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, an exception will be thrown. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ab9cc381e6561444004d82ea394ccf2fe">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aa4d55c285a282ee0da229ddc28fbd814"></a><!-- doxytag: member="NetInstanceImplementedTCP::SetMaxPacketSizeTCP" ref="aa4d55c285a282ee0da229ddc28fbd814" args="(size_t newMaxSize=0, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceImplementedTCP::SetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newMaxSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manually changes the maximum packet size that can be received. </p>
<p>Note that data loss will not occur, the buffer will be decreased in size as much as possible without causing data loss in the case that <em>newMaxSize</em> &lt; current.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newMaxSize</em>&nbsp;</td><td>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If newMaxSize &lt; <a class="el" href="class_net_instance_t_c_p.html#a75e1024a7352c83b7691bd3268e24136" title="Retrieves the smallest acceptable packet size that can be received.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#afe39589a67763fc6becc79f39659c3a4">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a35cc59e1f2ad733f7f5138e4233688ba"></a><!-- doxytag: member="NetInstanceImplementedTCP::ShutdownTCP" ref="a35cc59e1f2ad733f7f5138e4233688ba" args="(size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceImplementedTCP::ShutdownTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the graceful disconnection process. </p>
<p>Stops sending on TCP socket so that all further send operations will fail. All data sent up until now will be received by recipient.<br/>
<br/>
</p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. Ignored in this implementation but derived class may use ID when overriding (optional, default = 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#abb23de43a14d5809a79871a05244d17b">NetInstanceTCP</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_instance_implemented_t_c_p_8h_source.html">NetInstanceImplementedTCP.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetInstanceImplementedTCP.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:19 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
