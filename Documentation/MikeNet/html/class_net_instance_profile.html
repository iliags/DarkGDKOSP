<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetInstanceProfile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetInstanceProfile Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetInstanceProfile" --><!-- doxytag: inherits="CriticalSection" -->
<p>Manages instance startup information.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_instance_profile_8h_source.html">NetInstanceProfile.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetInstanceProfile:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_instance_profile.png" usemap="#NetInstanceProfile_map" alt=""/>
  <map id="NetInstanceProfile_map" name="NetInstanceProfile_map">
<area href="class_critical_section.html" alt="CriticalSection" shape="rect" coords="0,0,115,24"/>
</map>
</div>

<p><a href="class_net_instance_profile-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3442dc52d4b8f43f7494df0f62be347"></a><!-- doxytag: member="NetInstanceProfile::NetInstanceProfile" ref="aa3442dc52d4b8f43f7494df0f62be347" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aa3442dc52d4b8f43f7494df0f62be347">NetInstanceProfile</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#afb388a609224bd742f6db0d0b7b1d6a7">NetInstanceProfile</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;copyMe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy constructor.  <a href="#afb388a609224bd742f6db0d0b7b1d6a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#adb152f79d06708b6f557c8d2a86cd424">operator=</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;copyMe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep assignment operator.  <a href="#adb152f79d06708b6f557c8d2a86cd424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a8bfa833d397c682b21eedd7b345b497d">operator==</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;compare) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this object with another instance profile.  <a href="#a8bfa833d397c682b21eedd7b345b497d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55b654936fc693d7a4ab2e25f69413aa"></a><!-- doxytag: member="NetInstanceProfile::~NetInstanceProfile" ref="a55b654936fc693d7a4ab2e25f69413aa" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a55b654936fc693d7a4ab2e25f69413aa">~NetInstanceProfile</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aea8ecf597e31112af7d8e10217063caa">SetRecvFuncUDP</a> (<a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> newRecvFuncUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the UDP receive function that should be called when an incoming UDP packet is received.  <a href="#aea8ecf597e31112af7d8e10217063caa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a2bd3bbd81542f5a006e88fc45091c8e1">SetHandshakeEnabled</a> (bool newhandshakeEnabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the handshake process.  <a href="#a2bd3bbd81542f5a006e88fc45091c8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a0108f46983695c115e2765f37cfda734">SetWsaRecvSizeTCP</a> (size_t newWsaRecvSizeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the WSA winsock buffer size i.e. The amount of TCP data that can be received in one winsock TCP receive operation.  <a href="#a0108f46983695c115e2765f37cfda734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a79577ee788215ec47931ae3599e5a824">SetRecvSizeTCP</a> (size_t newRecvSizeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error or needing the buffer to be increased in size.  <a href="#a79577ee788215ec47931ae3599e5a824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a862741f4e82fd603e27d7d6fc683cc8d">SetRecvSizeUDP</a> (size_t newRecvSizeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the UDP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error.  <a href="#a862741f4e82fd603e27d7d6fc683cc8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad3f5d1c25fb1dce3b1c2f692d4e2a0fa">SetLocalAddrTCP</a> (const <a class="el" href="class_net_address.html">NetAddress</a> &amp;newLocalAddrTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local TCP address that the instance should be bound to.  <a href="#ad3f5d1c25fb1dce3b1c2f692d4e2a0fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a8299e23979c397f8d75a71212ba240c9">SetLocalAddrUDP</a> (const <a class="el" href="class_net_address.html">NetAddress</a> &amp;newLocalAddrUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local UDP address that the instance should be bound to.  <a href="#a8299e23979c397f8d75a71212ba240c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a902105c1a8743cce62e3df9c9a022700">SetEnabledUDP</a> (bool newEnabledUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables UDP.  <a href="#a902105c1a8743cce62e3df9c9a022700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a73cc53b7890131ee645288ef5ec728ff">SetDecryptKeyUDP</a> (const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *newDecryptKeyUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pointer to the decryption key used to decrypt incoming UDP packets.  <a href="#a73cc53b7890131ee645288ef5ec728ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae962a48359066ff383f459dad140d1b2">SetRecvFuncTCP</a> (<a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> newRecvFuncTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP receive function that should be called when an incoming TCP packet is received.  <a href="#ae962a48359066ff383f459dad140d1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a8fb33cbbfb7f5caf9eb8545c38775eeb">SetModeTCP</a> (<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> newModeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP mode that should be used by the instance.  <a href="#a8fb33cbbfb7f5caf9eb8545c38775eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aa0df09d0393d0021f20c9a134a035de1">SetModeUDP</a> (<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> newModeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the UDP mode that should be used by the instance.  <a href="#aa0df09d0393d0021f20c9a134a035de1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aa7f2196d4a36a242d2a5e588d19ab8d4">SetAutoResizeTCP</a> (bool newAutoResizeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the auto resize option is enabled. If it is enabled then if a packet larger than the TCP receive buffer size is received, then the buffer will automatically increase in size.  <a href="#aa7f2196d4a36a242d2a5e588d19ab8d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad9e42f02af634309b946e3ed585afe2e">SetSendTimeout</a> (unsigned int newSendTimeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of milliseconds that send operations will be allowed to complete before they are canceled and the entity that initiated the operation is forcefully disconnected.  <a href="#ad9e42f02af634309b946e3ed585afe2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#af18b9b5d71dcc3eb25a4da7d1ece6d4a">SetGracefulDisconnectEnabled</a> (bool newGracefulDisconnect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables graceful disconnection.  <a href="#af18b9b5d71dcc3eb25a4da7d1ece6d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ac83c91e34f442dbc25e83d21bbeff8e2">SetNagleEnabled</a> (bool newNagleEnabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the nagle algorithm.  <a href="#ac83c91e34f442dbc25e83d21bbeff8e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#afd7d56b3d087a5c2ea9d202a705fc2e1">SetPostFixTCP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;newPostFixTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP postfix in use in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetModeTcp::TCP_POSTFIX</a> TCP mode.  <a href="#afd7d56b3d087a5c2ea9d202a705fc2e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a29e19e0f4a542cc105c50ff7f7169102">SetReusableUDP</a> (bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the reusable UDP option. If reusable other applications, instances and sockets can bind to the same UDP address as this instance.  <a href="#a29e19e0f4a542cc105c50ff7f7169102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a66b8793bf17d64b8ef9080b2ebd03d47">SetConnectionToServerTimeout</a> (size_t newConnectionToServerTimeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of milliseconds that a client is allowed to handshake with the server before it is forcefully disconnected.  <a href="#a66b8793bf17d64b8ef9080b2ebd03d47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a24e097e1c072358163fa00998d33e0fd">SetNumOperations</a> (size_t newNumOperations)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>.  <a href="#a24e097e1c072358163fa00998d33e0fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a89f3243d78963e4eb890d5fda63877b9">GetWsaRecvSizeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the WSA winsock buffer size i.e. The amount of TCP data that can be received in one winsock TCP receive operation.  <a href="#a89f3243d78963e4eb890d5fda63877b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a34189e13e8b5a89800f0aa512c80fdb1">GetRecvSizeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error or needing the buffer to be increased in size.  <a href="#a34189e13e8b5a89800f0aa512c80fdb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ac93208f09c1034d1ff7b9b4318f60b21">GetRecvSizeUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error.  <a href="#ac93208f09c1034d1ff7b9b4318f60b21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a584ba16218e7d6340eebfefaba180477">GetLocalAddrTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP address that the instance should be bound to.  <a href="#a584ba16218e7d6340eebfefaba180477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a6a74c2b832b5662de13b5e23370129f8">GetLocalAddrUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP address that the instance should be bound to.  <a href="#a6a74c2b832b5662de13b5e23370129f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aa5a2c1ea8752efc51c70a41bb3ecbb20">IsEnabledUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP is enabled.  <a href="#aa5a2c1ea8752efc51c70a41bb3ecbb20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae7b72771c67facf3e4b5893b71f82b64">IsDecryptKeyLoadedUDP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a decryption key has been set.  <a href="#ae7b72771c67facf3e4b5893b71f82b64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a67ebfeeeae376870b959b6f6655cf330">GetDecryptKeyUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the decryption key used to decrypt incoming UDP packets.  <a href="#a67ebfeeeae376870b959b6f6655cf330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ac69cc1c6258261af12d7397ecb4e2839">IsHandshakeEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the handshake process is enabled.  <a href="#ac69cc1c6258261af12d7397ecb4e2839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a33d0b363560c97904e1e1b764f49a5c5">GetModeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP mode that should be used by the instance.  <a href="#a33d0b363560c97904e1e1b764f49a5c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a58a1289d1dbd339a1ac58a745f78060c">GetModeUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP mode that should be used by the instance.  <a href="#a58a1289d1dbd339a1ac58a745f78060c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a3138ff491860a299c87cc45f17f193bf">GetAutoResizeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the auto resize option is enabled. If it is then if a packet larger than the TCP receive buffer size is received, then the buffer will automatically increase in size.  <a href="#a3138ff491860a299c87cc45f17f193bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad4ed7a0ee24cf165e639fead2ec3e940">GetSendTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of milliseconds that send operations will be allowed to complete before they are canceled and the entity that initiated the operation is forcefully disconnected.  <a href="#ad4ed7a0ee24cf165e639fead2ec3e940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aafc19d5c04af571aa711ad5f306e2686">IsGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether graceful disconnection is enabled.  <a href="#aafc19d5c04af571aa711ad5f306e2686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#acb8b8c3655ce8abbd79867130222bd20">IsNagleEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the nagle algorithm is enabled or disabled.  <a href="#acb8b8c3655ce8abbd79867130222bd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a1b41a8d54a6fe70d9ac3cf0dbe20ef3a">GetPostFixTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP postfix in use in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetModeTcp::TCP_POSTFIX</a> TCP mode.  <a href="#a1b41a8d54a6fe70d9ac3cf0dbe20ef3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a57b4bca1eac3896118011edecd961ee1">IsReusableUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP should be reusable. If reusable other applications, instances and sockets can bind to the same UDP address as this instance.  <a href="#a57b4bca1eac3896118011edecd961ee1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ab2f53e23e75a13104855efb4f8b4c063">GetConnectionToServerTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of milliseconds that a client is allowed to handshake with the server before it is forcefully disconnected.  <a href="#ab2f53e23e75a13104855efb4f8b4c063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae4d9e03d9700d57b01921027459c477f">GetNumOperations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>.  <a href="#ae4d9e03d9700d57b01921027459c477f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#af498bede8c8e0029db0f26c3ef796dc0">GetRecvFuncTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP receive function that should be called when an incoming TCP packet is received.  <a href="#af498bede8c8e0029db0f26c3ef796dc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a63584bbc071271a73cc422e7e075b518">GetRecvFuncUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP receive function that should be called when an incoming UDP packet is received.  <a href="#a63584bbc071271a73cc422e7e075b518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode_udp.html">NetModeUdp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae6ad441d78eb208534e1321521345f93">GenerateObjectModeUDP</a> (size_t numClients, size_t <a class="el" href="class_net_instance_profile.html#acfc20340749f35543345f8b6c00fef4a">numOperations</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a <a class="el" href="class_net_mode_udp.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">NetModeUdp</a> object based on local variables.  <a href="#ae6ad441d78eb208534e1321521345f93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a51acbcfcbd4920688fa4ac69dc654d99">GenerateObjectModeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a> object based on local variables.  <a href="#a51acbcfcbd4920688fa4ac69dc654d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a5620819c1e617258b5abb939d1df8dd8">GenerateObjectSocketUDP</a> (size_t bufferLength, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;localAddr, bool reusable, <a class="el" href="class_net_mode_udp.html">NetModeUdp</a> *udpMode, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a normal UDP socket.  <a href="#a5620819c1e617258b5abb939d1df8dd8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3">DEFAULT_BUFFER_SIZE</a> = 1024</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default number of bytes to allocate to receive buffers.  <a href="#a285d88534b9936cc603e778aa70d8ec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceaa7353038094829951787fcb7ce2b8"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_ENABLED_UDP" ref="aceaa7353038094829951787fcb7ce2b8" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8">DEFAULT_ENABLED_UDP</a> = true</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#add7906378b2fe3ebc0fed461b0e02395" title="If true UDP is enabled.">NetInstanceProfile::enabledUDP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3468dd5fa20f1c13888bf1d6eed1736a"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_DECRYPT_KEY_UDP" ref="a3468dd5fa20f1c13888bf1d6eed1736a" args="" -->
static const __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a3468dd5fa20f1c13888bf1d6eed1736a">DEFAULT_DECRYPT_KEY_UDP</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a0909a6a77030a97700cef25384df37b0" title="Pointer to EncryptKey object used when decrypting UDP packets.">NetInstanceProfile::decryptKeyUDP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51f05ca66c76fdc588d34455d5185f6b"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_RECV_FUNC" ref="a51f05ca66c76fdc588d34455d5185f6b" args="" -->
static const <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b">DEFAULT_RECV_FUNC</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a879b3034d521919570637748adefb6d8" title="This function will be called whenever TCP data is received on the instance.">NetInstanceProfile::tcpRecvFunc</a> and <a class="el" href="class_net_instance_profile.html#a2825db403a006e006f4f0b6b4b50c0bb" title="This function will be called whenever UDP data is received on the instance.">NetInstanceProfile::udpRecvFunc</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c3283c29676e4dfbc7ea2428df32b5"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED" ref="a28c3283c29676e4dfbc7ea2428df32b5" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5">DEFAULT_HANDSHAKE_ENABLED</a> = true</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#aaeba0fb41f3972711b0d789d13d74c0f" title="If true the TCP handshaking process is enabled. If false the TCP handshaking process is disabled and ...">NetInstanceProfile::handshakeEnabled</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1d027ea1d01003564961be529fd5766"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_MODE_TCP" ref="ad1d027ea1d01003564961be529fd5766" args="" -->
static const <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766">DEFAULT_MODE_TCP</a> = NetMode::TCP_PREFIX_SIZE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#acfc65e0440c83e5e5fa35f3480d8db3e" title="TCP mode in use.">NetInstanceProfile::modeTCP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0797a8d2fdfb3f67a7b67a103a99fcb"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP" ref="ae0797a8d2fdfb3f67a7b67a103a99fcb" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb">DEFAULT_AUTO_RESIZE_TCP</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a9c10389be76ce558cdaad5e5847d7d96" title="If true maximum size of incoming TCP packet will increase if necessary to store an incoming packet...">NetInstanceProfile::autoResizeTCP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a3abeb53ed94ac5a75c408f2684e909"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_SEND_TIMEOUT" ref="a7a3abeb53ed94ac5a75c408f2684e909" args="" -->
static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909">DEFAULT_SEND_TIMEOUT</a> = INFINITE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a6cc36534bcb31e4411e2698e55908c18" title="Length of time that send operation will wait before canceling and disconnecting.">NetInstanceProfile::sendTimeout</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada7dfa96aa2fd6c205dc1137f2aad30d"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT" ref="ada7dfa96aa2fd6c205dc1137f2aad30d" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d">DEFAULT_GRACEFUL_DISCONNECT</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a73dbd928100dce63697399d8e21058eb" title="If true graceful disconnecting is enabled.">NetInstanceProfile::gracefulDisconnect</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f709c306b12e5572df975b10d6c748f"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_NAGLE_ENABLED" ref="a0f709c306b12e5572df975b10d6c748f" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f">DEFAULT_NAGLE_ENABLED</a> = true</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a959f0b77c0e19d4f425c5c36b601ec8c" title="If true the nagle algorithm is enabled.">NetInstanceProfile::nagleEnabled</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309f6b2f32bd9dcbb9bd5e15e7381de2"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_POSTFIX_TCP" ref="a309f6b2f32bd9dcbb9bd5e15e7381de2" args="" -->
static const <a class="el" href="class_packet.html">Packet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2">DEFAULT_POSTFIX_TCP</a> = &quot;\r\n&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a6d540756a8887426bdff2cd7fa82e349" title="The postfix to apply in TCP mode NetMode::TCP_POSTFIX.">NetInstanceProfile::postFixTCP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a899fa95f6ada0deb60f43dae6935976f"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_REUSABLE_UDP" ref="a899fa95f6ada0deb60f43dae6935976f" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a899fa95f6ada0deb60f43dae6935976f">DEFAULT_REUSABLE_UDP</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#ad73bd8106b0993d4f8c89f2293c7a4e2" title="True if UDP should be reusable. When reusable other applications (including this one) may bind to the...">NetInstanceProfile::reusableUDP</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23a92f33275c72e9f999e80a9acfe8e3"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_NUM_OPERATIONS" ref="a23a92f33275c72e9f999e80a9acfe8e3" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a23a92f33275c72e9f999e80a9acfe8e3">DEFAULT_NUM_OPERATIONS</a> = 1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#acfc20340749f35543345f8b6c00fef4a" title="In NetMode::UDP_PER_CLIENT_PER_OPERATION this variable is used, describing the number of operations...">NetInstanceProfile::numOperations</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a247c5f6aeb339edcb8f01a66a592bf3c"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_MODE_UDP" ref="a247c5f6aeb339edcb8f01a66a592bf3c" args="" -->
static const <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c">DEFAULT_MODE_UDP</a> = NetMode::UDP_CATCH_ALL_NO</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#a959f0b77c0e19d4f425c5c36b601ec8c" title="If true the nagle algorithm is enabled.">NetInstanceProfile::nagleEnabled</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a650e1a57d7229fab6a4a9295a8145f79"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_CONNECTION_TO_SERVER_TIMEOUT" ref="a650e1a57d7229fab6a4a9295a8145f79" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a650e1a57d7229fab6a4a9295a8145f79">DEFAULT_CONNECTION_TO_SERVER_TIMEOUT</a> = 10000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for <a class="el" href="class_net_instance_profile.html#aa9aa810da463cdab017ab864515527c9" title="Time in milliseconds that a connection attempt will be waited on before giving up.">NetInstanceProfile::connectionToServerTimeout</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b2533bc5540e7beb22abf25fb18dcc1"></a><!-- doxytag: member="NetInstanceProfile::DefaultVariables" ref="a0b2533bc5540e7beb22abf25fb18dcc1" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a0b2533bc5540e7beb22abf25fb18dcc1">DefaultVariables</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all variables to default. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a06dc28fba6ad7f3f9e91fe37b475f31f">Copy</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;copyMe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of the specified instance profile.  <a href="#a06dc28fba6ad7f3f9e91fe37b475f31f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad83ca6291444ecb7e1138f336952afc7">wsaRecvSizeTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum amount of data that can be received via TCP in one operation.  <a href="#ad83ca6291444ecb7e1138f336952afc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a399872e7c3f23fbee9f2283d1ac8fc04">recvSizeTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size an incoming TCP packet can be.  <a href="#a399872e7c3f23fbee9f2283d1ac8fc04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ae24b078e006a395092d9256ab5947e95">recvSizeUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size an incoming UDP packet can be.  <a href="#ae24b078e006a395092d9256ab5947e95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad8c7a728119a1e74e44fdbeb9dba3392">localAddrTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local TCP address of instance.  <a href="#ad8c7a728119a1e74e44fdbeb9dba3392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad68155dc7f50c06688b8adae226626eb">localAddrUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local UDP address of instance.  <a href="#ad68155dc7f50c06688b8adae226626eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#add7906378b2fe3ebc0fed461b0e02395">enabledUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true UDP is enabled.  <a href="#add7906378b2fe3ebc0fed461b0e02395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a0909a6a77030a97700cef25384df37b0">decryptKeyUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object used when decrypting UDP packets.  <a href="#a0909a6a77030a97700cef25384df37b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a879b3034d521919570637748adefb6d8">tcpRecvFunc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will be called whenever TCP data is received on the instance.  <a href="#a879b3034d521919570637748adefb6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a2825db403a006e006f4f0b6b4b50c0bb">udpRecvFunc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will be called whenever UDP data is received on the instance.  <a href="#a2825db403a006e006f4f0b6b4b50c0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aaeba0fb41f3972711b0d789d13d74c0f">handshakeEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true the TCP handshaking process is enabled. If false the TCP handshaking process is disabled and so connection will occur with no additional data transfer.  <a href="#aaeba0fb41f3972711b0d789d13d74c0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#acfc65e0440c83e5e5fa35f3480d8db3e">modeTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TCP mode in use.  <a href="#acfc65e0440c83e5e5fa35f3480d8db3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a9c10389be76ce558cdaad5e5847d7d96">autoResizeTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true maximum size of incoming TCP packet will increase if necessary to store an incoming packet. If false an error will occur when a TCP packet that is too large is receive.  <a href="#a9c10389be76ce558cdaad5e5847d7d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a6cc36534bcb31e4411e2698e55908c18">sendTimeout</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of time that send operation will wait before canceling and disconnecting.  <a href="#a6cc36534bcb31e4411e2698e55908c18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a73dbd928100dce63697399d8e21058eb">gracefulDisconnect</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true graceful disconnecting is enabled.  <a href="#a73dbd928100dce63697399d8e21058eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a959f0b77c0e19d4f425c5c36b601ec8c">nagleEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true the nagle algorithm is enabled.  <a href="#a959f0b77c0e19d4f425c5c36b601ec8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a6d540756a8887426bdff2cd7fa82e349">postFixTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The postfix to apply in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>.  <a href="#a6d540756a8887426bdff2cd7fa82e349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#ad73bd8106b0993d4f8c89f2293c7a4e2">reusableUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if UDP should be reusable. When reusable other applications (including this one) may bind to the local port in use.  <a href="#ad73bd8106b0993d4f8c89f2293c7a4e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#acfc20340749f35543345f8b6c00fef4a">numOperations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> this variable is used, describing the number of operations.  <a href="#acfc20340749f35543345f8b6c00fef4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#a6f7dcc6d649e11ab2f9c9cf99dd74313">modeUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UDP mode to use.  <a href="#a6f7dcc6d649e11ab2f9c9cf99dd74313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_profile.html#aa9aa810da463cdab017ab864515527c9">connectionToServerTimeout</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time in milliseconds that a connection attempt will be waited on before giving up.  <a href="#aa9aa810da463cdab017ab864515527c9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Manages instance startup information. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/5/2010.</dd></dl>
<p>Part of the instance system. <br/>
<br/>
</p>
<p>An instance profile is an object that contains a variety of options specific to instances. Any instance can have an instance profile loaded into it during initialization. Each option has a default value, which often does not need to be changed. By using instance profiles lengthy constructors are avoided. As well as this, similar profiles with similar settings can use the same profile; this is a neat way of sharing options between instances.<br/>
<br/>
</p>
<p>This class is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb388a609224bd742f6db0d0b7b1d6a7"></a><!-- doxytag: member="NetInstanceProfile::NetInstanceProfile" ref="afb388a609224bd742f6db0d0b7b1d6a7" args="(const NetInstanceProfile &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceProfile::NetInstanceProfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep copy constructor. </p>
<p>Copies contents of <em>copyMe</em> into this object (deep). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a06dc28fba6ad7f3f9e91fe37b475f31f"></a><!-- doxytag: member="NetInstanceProfile::Copy" ref="a06dc28fba6ad7f3f9e91fe37b475f31f" args="(const NetInstanceProfile &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the contents of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51acbcfcbd4920688fa4ac69dc654d99"></a><!-- doxytag: member="NetInstanceProfile::GenerateObjectModeTCP" ref="a51acbcfcbd4920688fa4ac69dc654d99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> * NetInstanceProfile::GenerateObjectModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a> object based on local variables. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6ad441d78eb208534e1321521345f93"></a><!-- doxytag: member="NetInstanceProfile::GenerateObjectModeUDP" ref="ae6ad441d78eb208534e1321521345f93" args="(size_t numClients, size_t numOperations) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode_udp.html">NetModeUdp</a> * NetInstanceProfile::GenerateObjectModeUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numOperations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a <a class="el" href="class_net_mode_udp.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">NetModeUdp</a> object based on local variables. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numClients</em>&nbsp;</td><td>Number of clients that data may be received for (optional, default 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numOperations</em>&nbsp;</td><td>Number of operations that data may be received for (optional, default 1). Ignored in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a158ce5f833cde150d209f480936b2b0a">NetMode::UDP_CATCH_ALL</a> and <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964ad4582c7d9e25f9fbd2cec99e4455386f">NetMode::UDP_CATCH_ALL_NO</a> UDP modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>object.</dd>
<dd>
netModeUdp object if UDP is enabled. </dd>
<dd>
NULL if UDP is disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a5620819c1e617258b5abb939d1df8dd8"></a><!-- doxytag: member="NetInstanceProfile::GenerateObjectSocketUDP" ref="a5620819c1e617258b5abb939d1df8dd8" args="(size_t bufferLength, const NetAddress &amp;localAddr, bool reusable, NetModeUdp *udpMode, NetSocket::RecvFunc recvFunc=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> * NetInstanceProfile::GenerateObjectSocketUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reusable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode_udp.html">NetModeUdp</a> *&nbsp;</td>
          <td class="paramname"> <em>udpMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a normal UDP socket. </p>
<p>The purpose of this method is for class constructors. If UDP is disabled NULL needs to be set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localAddr</em>&nbsp;</td><td>Local address to bind to, if IP or port is set to 0 then winsock will automatically find one. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reusable</em>&nbsp;</td><td>If true socket local address can be reused. See. <a class="el" href="class_net_socket_simple.html#a0921fd02f526c403ce5143d8fdec77fa" title="True if the socket is reusable.">NetSocketSimple::reusable</a> for more information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpMode</em>&nbsp;</td><td>Describes how received data should be dealt with and how sent data should be modified. If NULL, LoadMode() must later be used. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Function that any received packets will be passed to. (optional, default NULL). Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>. If NULL then packets will not be passed to a function, and instead will be put into a queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a dynamically allocated socketUDP object. </dd>
<dd>
NULL if UDP is disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a3138ff491860a299c87cc45f17f193bf"></a><!-- doxytag: member="NetInstanceProfile::GetAutoResizeTCP" ref="a3138ff491860a299c87cc45f17f193bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the auto resize option is enabled. If it is then if a packet larger than the TCP receive buffer size is received, then the buffer will automatically increase in size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>If true maximum size of incoming TCP packet will increase if necessary to store an incoming packet. If false an error will occur when a TCP packet that is too large is receive. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb" title="Default value for NetInstanceProfile::autoResizeTCP.">NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ab2f53e23e75a13104855efb4f8b4c063"></a><!-- doxytag: member="NetInstanceProfile::GetConnectionToServerTimeout" ref="ab2f53e23e75a13104855efb4f8b4c063" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceProfile::GetConnectionToServerTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of milliseconds that a client is allowed to handshake with the server before it is forcefully disconnected. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Time in milliseconds that a connection attempt will be waited on before giving up. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a650e1a57d7229fab6a4a9295a8145f79" title="Default value for NetInstanceProfile::connectionToServerTimeout.">NetInstanceProfile::DEFAULT_CONNECTION_TO_SERVER_TIMEOUT</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a67ebfeeeae376870b959b6f6655cf330"></a><!-- doxytag: member="NetInstanceProfile::GetDecryptKeyUDP" ref="a67ebfeeeae376870b959b6f6655cf330" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> * NetInstanceProfile::GetDecryptKeyUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a pointer to the decryption key used to decrypt incoming UDP packets. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Pointer to <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object used when decrypting UDP packets. </p>
<p>NULL if no key exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a3468dd5fa20f1c13888bf1d6eed1736a" title="Default value for NetInstanceProfile::decryptKeyUDP.">NetInstanceProfile::DEFAULT_DECRYPT_KEY_UDP</a>. <br/>
<br/>
</p>
<p>Note that the key is not necessarily used by. UDP instances, only if the mode in use specifically specifies in its documentation will the key ever be used. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a584ba16218e7d6340eebfefaba180477"></a><!-- doxytag: member="NetInstanceProfile::GetLocalAddrTCP" ref="a584ba16218e7d6340eebfefaba180477" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceProfile::GetLocalAddrTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP address that the instance should be bound to. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Local TCP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>
 </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a74c2b832b5662de13b5e23370129f8"></a><!-- doxytag: member="NetInstanceProfile::GetLocalAddrUDP" ref="a6a74c2b832b5662de13b5e23370129f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceProfile::GetLocalAddrUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP address that the instance should be bound to. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Local UDP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>
 </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a33d0b363560c97904e1e1b764f49a5c5"></a><!-- doxytag: member="NetInstanceProfile::GetModeTCP" ref="a33d0b363560c97904e1e1b764f49a5c5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetInstanceProfile::GetModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP mode that should be used by the instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>TCP mode in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a58a1289d1dbd339a1ac58a745f78060c"></a><!-- doxytag: member="NetInstanceProfile::GetModeUDP" ref="a58a1289d1dbd339a1ac58a745f78060c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetInstanceProfile::GetModeUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP mode that should be used by the instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>UDP mode to use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4d9e03d9700d57b01921027459c477f"></a><!-- doxytag: member="NetInstanceProfile::GetNumOperations" ref="ae4d9e03d9700d57b01921027459c477f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceProfile::GetNumOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>In <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> this variable is used, describing the number of operations. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a23a92f33275c72e9f999e80a9acfe8e3" title="Default value for NetInstanceProfile::numOperations.">NetInstanceProfile::DEFAULT_NUM_OPERATIONS</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b41a8d54a6fe70d9ac3cf0dbe20ef3a"></a><!-- doxytag: member="NetInstanceProfile::GetPostFixTCP" ref="a1b41a8d54a6fe70d9ac3cf0dbe20ef3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> NetInstanceProfile::GetPostFixTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP postfix in use in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetModeTcp::TCP_POSTFIX</a> TCP mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>The postfix to apply in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="af498bede8c8e0029db0f26c3ef796dc0"></a><!-- doxytag: member="NetInstanceProfile::GetRecvFuncTCP" ref="af498bede8c8e0029db0f26c3ef796dc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> NetInstanceProfile::GetRecvFuncTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP receive function that should be called when an incoming TCP packet is received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>This function will be called whenever TCP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a63584bbc071271a73cc422e7e075b518"></a><!-- doxytag: member="NetInstanceProfile::GetRecvFuncUDP" ref="a63584bbc071271a73cc422e7e075b518" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> NetInstanceProfile::GetRecvFuncUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP receive function that should be called when an incoming UDP packet is received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>This function will be called whenever UDP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a34189e13e8b5a89800f0aa512c80fdb1"></a><!-- doxytag: member="NetInstanceProfile::GetRecvSizeTCP" ref="a34189e13e8b5a89800f0aa512c80fdb1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceProfile::GetRecvSizeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error or needing the buffer to be increased in size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Maximum size an incoming TCP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a> + <a class="el" href="class_net_instance_profile.html#ad83ca6291444ecb7e1138f336952afc7" title="Maximum amount of data that can be received via TCP in one operation.">NetInstanceProfile::wsaRecvSizeTCP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ac93208f09c1034d1ff7b9b4318f60b21"></a><!-- doxytag: member="NetInstanceProfile::GetRecvSizeUDP" ref="ac93208f09c1034d1ff7b9b4318f60b21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceProfile::GetRecvSizeUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Maximum size an incoming UDP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ad4ed7a0ee24cf165e639fead2ec3e940"></a><!-- doxytag: member="NetInstanceProfile::GetSendTimeout" ref="ad4ed7a0ee24cf165e639fead2ec3e940" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NetInstanceProfile::GetSendTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of milliseconds that send operations will be allowed to complete before they are canceled and the entity that initiated the operation is forcefully disconnected. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Length of time that send operation will wait before canceling and disconnecting. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a89f3243d78963e4eb890d5fda63877b9"></a><!-- doxytag: member="NetInstanceProfile::GetWsaRecvSizeTCP" ref="a89f3243d78963e4eb890d5fda63877b9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceProfile::GetWsaRecvSizeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the WSA winsock buffer size i.e. The amount of TCP data that can be received in one winsock TCP receive operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>Maximum amount of data that can be received via TCP in one operation. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ae7b72771c67facf3e4b5893b71f82b64"></a><!-- doxytag: member="NetInstanceProfile::IsDecryptKeyLoadedUDP" ref="ae7b72771c67facf3e4b5893b71f82b64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsDecryptKeyLoadedUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether a decryption key has been set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if decrypt key UDP is loaded, default = false. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a2c1ea8752efc51c70a41bb3ecbb20"></a><!-- doxytag: member="NetInstanceProfile::IsEnabledUDP" ref="aa5a2c1ea8752efc51c70a41bb3ecbb20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsEnabledUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>If true UDP is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="aafc19d5c04af571aa711ad5f306e2686"></a><!-- doxytag: member="NetInstanceProfile::IsGracefulDisconnectEnabled" ref="aafc19d5c04af571aa711ad5f306e2686" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether graceful disconnection is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>If true graceful disconnecting is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ac69cc1c6258261af12d7397ecb4e2839"></a><!-- doxytag: member="NetInstanceProfile::IsHandshakeEnabled" ref="ac69cc1c6258261af12d7397ecb4e2839" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsHandshakeEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the handshake process is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>If true the TCP handshaking process is enabled. If false the TCP handshaking process is disabled and so connection will occur with no additional data transfer. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="acb8b8c3655ce8abbd79867130222bd20"></a><!-- doxytag: member="NetInstanceProfile::IsNagleEnabled" ref="acb8b8c3655ce8abbd79867130222bd20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsNagleEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the nagle algorithm is enabled or disabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>If true the nagle algorithm is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a57b4bca1eac3896118011edecd961ee1"></a><!-- doxytag: member="NetInstanceProfile::IsReusableUDP" ref="a57b4bca1eac3896118011edecd961ee1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::IsReusableUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP should be reusable. If reusable other applications, instances and sockets can bind to the same UDP address as this instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>True if UDP should be reusable. When reusable other applications (including this one) may bind to the local port in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a899fa95f6ada0deb60f43dae6935976f" title="Default value for NetInstanceProfile::reusableUDP.">NetInstanceProfile::DEFAULT_REUSABLE_UDP</a>. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="adb152f79d06708b6f557c8d2a86cd424"></a><!-- doxytag: member="NetInstanceProfile::operator=" ref="adb152f79d06708b6f557c8d2a86cd424" args="(const NetInstanceProfile &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp; NetInstanceProfile::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep assignment operator. </p>
<p>Copies contents of <em>copyMe</em> into this object (deep). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bfa833d397c682b21eedd7b345b497d"></a><!-- doxytag: member="NetInstanceProfile::operator==" ref="a8bfa833d397c682b21eedd7b345b497d" args="(const NetInstanceProfile &amp;compare) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceProfile::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares this object with another instance profile. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>a</em> is identical to this object. </dd>
<dd>
false if <em>a</em> is different in any way to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7f2196d4a36a242d2a5e588d19ab8d4"></a><!-- doxytag: member="NetInstanceProfile::SetAutoResizeTCP" ref="aa7f2196d4a36a242d2a5e588d19ab8d4" args="(bool newAutoResizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the auto resize option is enabled. If it is enabled then if a packet larger than the TCP receive buffer size is received, then the buffer will automatically increase in size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td><p>If true maximum size of incoming TCP packet will increase if necessary to store an incoming packet. If false an error will occur when a TCP packet that is too large is receive. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb" title="Default value for NetInstanceProfile::autoResizeTCP.">NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66b8793bf17d64b8ef9080b2ebd03d47"></a><!-- doxytag: member="NetInstanceProfile::SetConnectionToServerTimeout" ref="a66b8793bf17d64b8ef9080b2ebd03d47" args="(size_t newConnectionToServerTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetConnectionToServerTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newConnectionToServerTimeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the number of milliseconds that a client is allowed to handshake with the server before it is forcefully disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newConnectionToServerTimeout</em>&nbsp;</td><td><p>Time in milliseconds that a connection attempt will be waited on before giving up. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a650e1a57d7229fab6a4a9295a8145f79" title="Default value for NetInstanceProfile::connectionToServerTimeout.">NetInstanceProfile::DEFAULT_CONNECTION_TO_SERVER_TIMEOUT</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73cc53b7890131ee645288ef5ec728ff"></a><!-- doxytag: member="NetInstanceProfile::SetDecryptKeyUDP" ref="a73cc53b7890131ee645288ef5ec728ff" args="(const EncryptKey *newDecryptKeyUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetDecryptKeyUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td>
          <td class="paramname"> <em>newDecryptKeyUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the pointer to the decryption key used to decrypt incoming UDP packets. </p>
<p>Note that the contents of <em>newDecryptKeyUDP</em> is copied into this object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newDecryptKeyUDP</em>&nbsp;</td><td><p>Pointer to <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object used when decrypting UDP packets. </p>
<p>NULL if no key exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a3468dd5fa20f1c13888bf1d6eed1736a" title="Default value for NetInstanceProfile::decryptKeyUDP.">NetInstanceProfile::DEFAULT_DECRYPT_KEY_UDP</a>. <br/>
<br/>
</p>
<p>Note that the key is not necessarily used by. UDP instances, only if the mode in use specifically specifies in its documentation will the key ever be used. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a902105c1a8743cce62e3df9c9a022700"></a><!-- doxytag: member="NetInstanceProfile::SetEnabledUDP" ref="a902105c1a8743cce62e3df9c9a022700" args="(bool newEnabledUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetEnabledUDP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newEnabledUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables UDP. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newEnabledUDP</em>&nbsp;</td><td><p>If true UDP is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af18b9b5d71dcc3eb25a4da7d1ece6d4a"></a><!-- doxytag: member="NetInstanceProfile::SetGracefulDisconnectEnabled" ref="af18b9b5d71dcc3eb25a4da7d1ece6d4a" args="(bool newGracefulDisconnect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newGracefulDisconnect</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables graceful disconnection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newGracefulDisconnect</em>&nbsp;</td><td><p>If true graceful disconnecting is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bd3bbd81542f5a006e88fc45091c8e1"></a><!-- doxytag: member="NetInstanceProfile::SetHandshakeEnabled" ref="a2bd3bbd81542f5a006e88fc45091c8e1" args="(bool newhandshakeEnabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetHandshakeEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newhandshakeEnabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the handshake process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newhandshakeEnabled</em>&nbsp;</td><td><p>If true the TCP handshaking process is enabled. If false the TCP handshaking process is disabled and so connection will occur with no additional data transfer. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3f5d1c25fb1dce3b1c2f692d4e2a0fa"></a><!-- doxytag: member="NetInstanceProfile::SetLocalAddrTCP" ref="ad3f5d1c25fb1dce3b1c2f692d4e2a0fa" args="(const NetAddress &amp;newLocalAddrTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetLocalAddrTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newLocalAddrTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local TCP address that the instance should be bound to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newLocalAddrTCP</em>&nbsp;</td><td><p>Local TCP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8299e23979c397f8d75a71212ba240c9"></a><!-- doxytag: member="NetInstanceProfile::SetLocalAddrUDP" ref="a8299e23979c397f8d75a71212ba240c9" args="(const NetAddress &amp;newLocalAddrUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetLocalAddrUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newLocalAddrUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local UDP address that the instance should be bound to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newLocalAddrUDP</em>&nbsp;</td><td><p>Local UDP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fb33cbbfb7f5caf9eb8545c38775eeb"></a><!-- doxytag: member="NetInstanceProfile::SetModeTCP" ref="a8fb33cbbfb7f5caf9eb8545c38775eeb" args="(NetMode::ProtocolMode newModeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetModeTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>newModeTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP mode that should be used by the instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newModeTCP</em>&nbsp;</td><td><p>TCP mode in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>newModeUDP</em> is not a valid TCP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0df09d0393d0021f20c9a134a035de1"></a><!-- doxytag: member="NetInstanceProfile::SetModeUDP" ref="aa0df09d0393d0021f20c9a134a035de1" args="(NetMode::ProtocolMode newModeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetModeUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>newModeUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the UDP mode that should be used by the instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newModeUDP</em>&nbsp;</td><td><p>UDP mode to use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>newModeUDP</em> is not a valid UDP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac83c91e34f442dbc25e83d21bbeff8e2"></a><!-- doxytag: member="NetInstanceProfile::SetNagleEnabled" ref="ac83c91e34f442dbc25e83d21bbeff8e2" args="(bool newNagleEnabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetNagleEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newNagleEnabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the nagle algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newNagleEnabled</em>&nbsp;</td><td><p>If true the nagle algorithm is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24e097e1c072358163fa00998d33e0fd"></a><!-- doxytag: member="NetInstanceProfile::SetNumOperations" ref="a24e097e1c072358163fa00998d33e0fd" args="(size_t newNumOperations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetNumOperations </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newNumOperations</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newNumOperations</em>&nbsp;</td><td><p>In <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> this variable is used, describing the number of operations. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a23a92f33275c72e9f999e80a9acfe8e3" title="Default value for NetInstanceProfile::numOperations.">NetInstanceProfile::DEFAULT_NUM_OPERATIONS</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd7d56b3d087a5c2ea9d202a705fc2e1"></a><!-- doxytag: member="NetInstanceProfile::SetPostFixTCP" ref="afd7d56b3d087a5c2ea9d202a705fc2e1" args="(const Packet &amp;newPostFixTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetPostFixTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newPostFixTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP postfix in use in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetModeTcp::TCP_POSTFIX</a> TCP mode. </p>
<p>This command changes the postfix option and has no impact on instances not in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newPostFixTCP</em>&nbsp;</td><td><p>The postfix to apply in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae962a48359066ff383f459dad140d1b2"></a><!-- doxytag: member="NetInstanceProfile::SetRecvFuncTCP" ref="ae962a48359066ff383f459dad140d1b2" args="(NetSocket::RecvFunc newRecvFuncTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetRecvFuncTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>newRecvFuncTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP receive function that should be called when an incoming TCP packet is received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newRecvFuncTCP</em>&nbsp;</td><td><p>This function will be called whenever TCP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea8ecf597e31112af7d8e10217063caa"></a><!-- doxytag: member="NetInstanceProfile::SetRecvFuncUDP" ref="aea8ecf597e31112af7d8e10217063caa" args="(NetSocket::RecvFunc newRecvFuncUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetRecvFuncUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>newRecvFuncUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the UDP receive function that should be called when an incoming UDP packet is received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newRecvFuncUDP</em>&nbsp;</td><td><p>This function will be called whenever UDP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79577ee788215ec47931ae3599e5a824"></a><!-- doxytag: member="NetInstanceProfile::SetRecvSizeTCP" ref="a79577ee788215ec47931ae3599e5a824" args="(size_t newRecvSizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetRecvSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newRecvSizeTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error or needing the buffer to be increased in size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newRecvSizeTCP</em>&nbsp;</td><td><p>Maximum size an incoming TCP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a> + <a class="el" href="class_net_instance_profile.html#ad83ca6291444ecb7e1138f336952afc7" title="Maximum amount of data that can be received via TCP in one operation.">NetInstanceProfile::wsaRecvSizeTCP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a862741f4e82fd603e27d7d6fc683cc8d"></a><!-- doxytag: member="NetInstanceProfile::SetRecvSizeUDP" ref="a862741f4e82fd603e27d7d6fc683cc8d" args="(size_t newRecvSizeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetRecvSizeUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newRecvSizeUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the UDP receive buffer size i.e. The maximum size a packet can be for it to be received without causing an error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newRecvSizeUDP</em>&nbsp;</td><td><p>Maximum size an incoming UDP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29e19e0f4a542cc105c50ff7f7169102"></a><!-- doxytag: member="NetInstanceProfile::SetReusableUDP" ref="a29e19e0f4a542cc105c50ff7f7169102" args="(bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetReusableUDP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newReusableUDP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the reusable UDP option. If reusable other applications, instances and sockets can bind to the same UDP address as this instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newReusableUDP</em>&nbsp;</td><td><p>True if UDP should be reusable. When reusable other applications (including this one) may bind to the local port in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a899fa95f6ada0deb60f43dae6935976f" title="Default value for NetInstanceProfile::reusableUDP.">NetInstanceProfile::DEFAULT_REUSABLE_UDP</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9e42f02af634309b946e3ed585afe2e"></a><!-- doxytag: member="NetInstanceProfile::SetSendTimeout" ref="ad9e42f02af634309b946e3ed585afe2e" args="(unsigned int newSendTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetSendTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>newSendTimeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the number of milliseconds that send operations will be allowed to complete before they are canceled and the entity that initiated the operation is forcefully disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newSendTimeout</em>&nbsp;</td><td><p>Length of time that send operation will wait before canceling and disconnecting. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0108f46983695c115e2765f37cfda734"></a><!-- doxytag: member="NetInstanceProfile::SetWsaRecvSizeTCP" ref="a0108f46983695c115e2765f37cfda734" args="(size_t newWsaRecvSizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceProfile::SetWsaRecvSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newWsaRecvSizeTCP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the WSA winsock buffer size i.e. The amount of TCP data that can be received in one winsock TCP receive operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newWsaRecvSizeTCP</em>&nbsp;</td><td><p>Maximum amount of data that can be received via TCP in one operation. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9c10389be76ce558cdaad5e5847d7d96"></a><!-- doxytag: member="NetInstanceProfile::autoResizeTCP" ref="a9c10389be76ce558cdaad5e5847d7d96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#a9c10389be76ce558cdaad5e5847d7d96">NetInstanceProfile::autoResizeTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true maximum size of incoming TCP packet will increase if necessary to store an incoming packet. If false an error will occur when a TCP packet that is too large is receive. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb" title="Default value for NetInstanceProfile::autoResizeTCP.">NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP</a>. </p>

</div>
</div>
<a class="anchor" id="aa9aa810da463cdab017ab864515527c9"></a><!-- doxytag: member="NetInstanceProfile::connectionToServerTimeout" ref="aa9aa810da463cdab017ab864515527c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_instance_profile.html#aa9aa810da463cdab017ab864515527c9">NetInstanceProfile::connectionToServerTimeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time in milliseconds that a connection attempt will be waited on before giving up. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a650e1a57d7229fab6a4a9295a8145f79" title="Default value for NetInstanceProfile::connectionToServerTimeout.">NetInstanceProfile::DEFAULT_CONNECTION_TO_SERVER_TIMEOUT</a>. </p>

</div>
</div>
<a class="anchor" id="a0909a6a77030a97700cef25384df37b0"></a><!-- doxytag: member="NetInstanceProfile::decryptKeyUDP" ref="a0909a6a77030a97700cef25384df37b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_encrypt_key.html">EncryptKey</a>* <a class="el" href="class_net_instance_profile.html#a0909a6a77030a97700cef25384df37b0">NetInstanceProfile::decryptKeyUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object used when decrypting UDP packets. </p>
<p>NULL if no key exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a3468dd5fa20f1c13888bf1d6eed1736a" title="Default value for NetInstanceProfile::decryptKeyUDP.">NetInstanceProfile::DEFAULT_DECRYPT_KEY_UDP</a>. <br/>
<br/>
</p>
<p>Note that the key is not necessarily used by. UDP instances, only if the mode in use specifically specifies in its documentation will the key ever be used. </p>

</div>
</div>
<a class="anchor" id="a285d88534b9936cc603e778aa70d8ec3"></a><!-- doxytag: member="NetInstanceProfile::DEFAULT_BUFFER_SIZE" ref="a285d88534b9936cc603e778aa70d8ec3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a> = 1024<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default number of bytes to allocate to receive buffers. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must be &gt;= minimum of any instance. </dd></dl>

</div>
</div>
<a class="anchor" id="add7906378b2fe3ebc0fed461b0e02395"></a><!-- doxytag: member="NetInstanceProfile::enabledUDP" ref="add7906378b2fe3ebc0fed461b0e02395" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#add7906378b2fe3ebc0fed461b0e02395">NetInstanceProfile::enabledUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true UDP is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>. </p>

</div>
</div>
<a class="anchor" id="a73dbd928100dce63697399d8e21058eb"></a><!-- doxytag: member="NetInstanceProfile::gracefulDisconnect" ref="a73dbd928100dce63697399d8e21058eb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#a73dbd928100dce63697399d8e21058eb">NetInstanceProfile::gracefulDisconnect</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true graceful disconnecting is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>. </p>

</div>
</div>
<a class="anchor" id="aaeba0fb41f3972711b0d789d13d74c0f"></a><!-- doxytag: member="NetInstanceProfile::handshakeEnabled" ref="aaeba0fb41f3972711b0d789d13d74c0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#aaeba0fb41f3972711b0d789d13d74c0f">NetInstanceProfile::handshakeEnabled</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true the TCP handshaking process is enabled. If false the TCP handshaking process is disabled and so connection will occur with no additional data transfer. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>. </p>

</div>
</div>
<a class="anchor" id="ad8c7a728119a1e74e44fdbeb9dba3392"></a><!-- doxytag: member="NetInstanceProfile::localAddrTCP" ref="ad8c7a728119a1e74e44fdbeb9dba3392" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> <a class="el" href="class_net_instance_profile.html#ad8c7a728119a1e74e44fdbeb9dba3392">NetInstanceProfile::localAddrTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Local TCP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>

</div>
</div>
<a class="anchor" id="ad68155dc7f50c06688b8adae226626eb"></a><!-- doxytag: member="NetInstanceProfile::localAddrUDP" ref="ad68155dc7f50c06688b8adae226626eb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> <a class="el" href="class_net_instance_profile.html#ad68155dc7f50c06688b8adae226626eb">NetInstanceProfile::localAddrUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Local UDP address of instance. </p>
<p>Default initialized using <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> default constructor. </p>

</div>
</div>
<a class="anchor" id="acfc65e0440c83e5e5fa35f3480d8db3e"></a><!-- doxytag: member="NetInstanceProfile::modeTCP" ref="acfc65e0440c83e5e5fa35f3480d8db3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> <a class="el" href="class_net_instance_profile.html#acfc65e0440c83e5e5fa35f3480d8db3e">NetInstanceProfile::modeTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCP mode in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>. </p>

</div>
</div>
<a class="anchor" id="a6f7dcc6d649e11ab2f9c9cf99dd74313"></a><!-- doxytag: member="NetInstanceProfile::modeUDP" ref="a6f7dcc6d649e11ab2f9c9cf99dd74313" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> <a class="el" href="class_net_instance_profile.html#a6f7dcc6d649e11ab2f9c9cf99dd74313">NetInstanceProfile::modeUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UDP mode to use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>. </p>

</div>
</div>
<a class="anchor" id="a959f0b77c0e19d4f425c5c36b601ec8c"></a><!-- doxytag: member="NetInstanceProfile::nagleEnabled" ref="a959f0b77c0e19d4f425c5c36b601ec8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#a959f0b77c0e19d4f425c5c36b601ec8c">NetInstanceProfile::nagleEnabled</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true the nagle algorithm is enabled. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>. </p>

</div>
</div>
<a class="anchor" id="acfc20340749f35543345f8b6c00fef4a"></a><!-- doxytag: member="NetInstanceProfile::numOperations" ref="acfc20340749f35543345f8b6c00fef4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_instance_profile.html#acfc20340749f35543345f8b6c00fef4a">NetInstanceProfile::numOperations</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> this variable is used, describing the number of operations. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a23a92f33275c72e9f999e80a9acfe8e3" title="Default value for NetInstanceProfile::numOperations.">NetInstanceProfile::DEFAULT_NUM_OPERATIONS</a>. </p>

</div>
</div>
<a class="anchor" id="a6d540756a8887426bdff2cd7fa82e349"></a><!-- doxytag: member="NetInstanceProfile::postFixTCP" ref="a6d540756a8887426bdff2cd7fa82e349" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> <a class="el" href="class_net_instance_profile.html#a6d540756a8887426bdff2cd7fa82e349">NetInstanceProfile::postFixTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The postfix to apply in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>. </p>

</div>
</div>
<a class="anchor" id="a399872e7c3f23fbee9f2283d1ac8fc04"></a><!-- doxytag: member="NetInstanceProfile::recvSizeTCP" ref="a399872e7c3f23fbee9f2283d1ac8fc04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_instance_profile.html#a399872e7c3f23fbee9f2283d1ac8fc04">NetInstanceProfile::recvSizeTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum size an incoming TCP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a> + <a class="el" href="class_net_instance_profile.html#ad83ca6291444ecb7e1138f336952afc7" title="Maximum amount of data that can be received via TCP in one operation.">NetInstanceProfile::wsaRecvSizeTCP</a>. </p>

</div>
</div>
<a class="anchor" id="ae24b078e006a395092d9256ab5947e95"></a><!-- doxytag: member="NetInstanceProfile::recvSizeUDP" ref="ae24b078e006a395092d9256ab5947e95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_instance_profile.html#ae24b078e006a395092d9256ab5947e95">NetInstanceProfile::recvSizeUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum size an incoming UDP packet can be. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>

</div>
</div>
<a class="anchor" id="ad73bd8106b0993d4f8c89f2293c7a4e2"></a><!-- doxytag: member="NetInstanceProfile::reusableUDP" ref="ad73bd8106b0993d4f8c89f2293c7a4e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_instance_profile.html#ad73bd8106b0993d4f8c89f2293c7a4e2">NetInstanceProfile::reusableUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>True if UDP should be reusable. When reusable other applications (including this one) may bind to the local port in use. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a899fa95f6ada0deb60f43dae6935976f" title="Default value for NetInstanceProfile::reusableUDP.">NetInstanceProfile::DEFAULT_REUSABLE_UDP</a>. </p>

</div>
</div>
<a class="anchor" id="a6cc36534bcb31e4411e2698e55908c18"></a><!-- doxytag: member="NetInstanceProfile::sendTimeout" ref="a6cc36534bcb31e4411e2698e55908c18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_net_instance_profile.html#a6cc36534bcb31e4411e2698e55908c18">NetInstanceProfile::sendTimeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Length of time that send operation will wait before canceling and disconnecting. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>. </p>

</div>
</div>
<a class="anchor" id="a879b3034d521919570637748adefb6d8"></a><!-- doxytag: member="NetInstanceProfile::tcpRecvFunc" ref="a879b3034d521919570637748adefb6d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> <a class="el" href="class_net_instance_profile.html#a879b3034d521919570637748adefb6d8">NetInstanceProfile::tcpRecvFunc</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will be called whenever TCP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists. <br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>

</div>
</div>
<a class="anchor" id="a2825db403a006e006f4f0b6b4b50c0bb"></a><!-- doxytag: member="NetInstanceProfile::udpRecvFunc" ref="a2825db403a006e006f4f0b6b4b50c0bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> <a class="el" href="class_net_instance_profile.html#a2825db403a006e006f4f0b6b4b50c0bb">NetInstanceProfile::udpRecvFunc</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will be called whenever UDP data is received on the instance. </p>
<p>Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>.<br/>
<br/>
</p>
<p>NULL if no function exists.<br/>
<br/>
</p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>. </p>

</div>
</div>
<a class="anchor" id="ad83ca6291444ecb7e1138f336952afc7"></a><!-- doxytag: member="NetInstanceProfile::wsaRecvSizeTCP" ref="ad83ca6291444ecb7e1138f336952afc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_instance_profile.html#ad83ca6291444ecb7e1138f336952afc7">NetInstanceProfile::wsaRecvSizeTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum amount of data that can be received via TCP in one operation. </p>
<p>Default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_instance_profile_8h_source.html">NetInstanceProfile.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetInstanceProfile.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:19 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
