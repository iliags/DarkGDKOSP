<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetInstanceServer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetInstanceServer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetInstanceServer" --><!-- doxytag: inherits="NetInstanceUDP,NetInstanceTCP" -->
<p>Server instance, designed to communicate with clients.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_instance_server_8h_source.html">NetInstanceServer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetInstanceServer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_instance_server.png" usemap="#NetInstanceServer_map" alt=""/>
  <map id="NetInstanceServer_map" name="NetInstanceServer_map">
<area href="class_net_instance_u_d_p.html" alt="NetInstanceUDP" shape="rect" coords="0,56,117,80"/>
<area href="class_net_instance_t_c_p.html" alt="NetInstanceTCP" shape="rect" coords="127,56,244,80"/>
<area href="class_net_instance.html" alt="NetInstance" shape="rect" coords="0,0,117,24"/>
<area href="class_net_instance.html" alt="NetInstance" shape="rect" coords="127,0,244,24"/>
</map>
</div>

<p><a href="class_net_instance_server-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a9763425c0e0489e4eea07b72ea1e7fc2">GetRecvSizeMinUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the minimum UDP receive buffer size.  <a href="#a9763425c0e0489e4eea07b72ea1e7fc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a6c809f671ccc29e9c688545ac12eb0fc">GetRecvSizeMinTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the minimum TCP receive buffer size.  <a href="#a6c809f671ccc29e9c688545ac12eb0fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a39f8de86af491972f0c99c82dc9f9772">NetInstanceServer</a> (size_t <a class="el" href="class_net_instance_server.html#ae08f9f216c652168e54dc0f86dff2416">maxClients</a>, <a class="el" href="class_net_socket_listening.html">NetSocketListening</a> *listeningSocket, <a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> *<a class="el" href="class_net_instance_u_d_p.html#af86e8343ddf2daf0ce3f9ea701bc7cf3">socketUDP</a>, bool <a class="el" href="class_net_instance_t_c_p.html#af13f96901d3006beeda0c161f32cbfde">handshakeEnabled</a>, unsigned int <a class="el" href="class_net_instance.html#a39ed2f4325ce50a7c374ab6253650608">sendTimeout</a>=INFINITE, size_t connectionTimeout=<a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397">DEFAULT_CONNECTION_TIMEOUT</a>, size_t <a class="el" href="class_net_instance.html#a46bab6fc672f987ee3c52daabffe34f7">instanceID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a39f8de86af491972f0c99c82dc9f9772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad339320c92e5ea5ab9b0b6f572db30ee">NetInstanceServer</a> (size_t <a class="el" href="class_net_instance_server.html#ae08f9f216c652168e54dc0f86dff2416">maxClients</a>, const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, size_t <a class="el" href="class_net_instance.html#a46bab6fc672f987ee3c52daabffe34f7">instanceID</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, using profile instead of individual parameters.  <a href="#ad339320c92e5ea5ab9b0b6f572db30ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a6f6c3fb0a639d85d251fe746838df2d8">Initialize</a> (size_t <a class="el" href="class_net_instance_server.html#ae08f9f216c652168e54dc0f86dff2416">maxClients</a>, bool <a class="el" href="class_net_instance_t_c_p.html#af13f96901d3006beeda0c161f32cbfde">handshakeEnabled</a>, size_t connectionTimeout, <a class="el" href="class_net_socket_listening.html">NetSocketListening</a> *<a class="el" href="class_net_instance_server.html#a5c00d75b589e62553821f7278d0e851e">socketListening</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes object.  <a href="#a6f6c3fb0a639d85d251fe746838df2d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#aea6efa8d9213d060c8976a776030bd64">~NetInstanceServer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#aea6efa8d9213d060c8976a776030bd64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad3ddeb6490be9a07235582b221b1f4aa">AddDisconnect</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a client to the disconnect list, indicating that it has recently been disconnected.  <a href="#ad3ddeb6490be9a07235582b221b1f4aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a263c1e81f7f756f2102da0c01abffc62">GetDisconnect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a client from the disconnect list, this client has been recently disconnected.  <a href="#a263c1e81f7f756f2102da0c01abffc62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ab436ece5c02fa04fe425cfcfd6656656">GetMaxClients</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the maximum number of clients that can be connected to the server at any one time.  <a href="#ab436ece5c02fa04fe425cfcfd6656656"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a2f6d9df5a672c6f94892e11d41101756">GetServerTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From the moment that a client first communicates with the server, it is allowed 'server timeout' number of milliseconds to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected.  <a href="#a2f6d9df5a672c6f94892e11d41101756"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a1b7871958d05e1e0e9f3e683dcc8162b">SetServerTimeout</a> (size_t milliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From the moment that a client first communicates with the server, it is allowed 'server timeout' number of milliseconds to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected.  <a href="#a1b7871958d05e1e0e9f3e683dcc8162b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ae9f855ae23ae42a4c648957ca1a6107b">SetAutoResize</a> (bool autoResize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the auto resize option for all clients.  <a href="#ae9f855ae23ae42a4c648957ca1a6107b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a1df65dc8572fc44730e5dd76e5aeabfe">DoRecv</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *socket, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="class_net_socket_t_c_p.html#a11891910910477cf1eba5fffef8bda52" title="Starts a receive operation via TCP.">NetSocketTCP::Recv</a> or <a class="el" href="class_net_socket_u_d_p.html#a5b7438968a34510997e9db862e00139b" title="Starts a receive operation via TCP.">NetSocketUDP::Recv</a> and deals with errors in a server specific way.  <a href="#a1df65dc8572fc44730e5dd76e5aeabfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a6a1425669efcbb0e36bddb6394e79f57">CompletionError</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *completionSocket, size_t clientID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the completion port when an error occurred during an operation.  <a href="#a6a1425669efcbb0e36bddb6394e79f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#aa230090218577e35109d61e87b560877">ErrorOccurred</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with errors.  <a href="#aa230090218577e35109d61e87b560877"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a610b8f09cd7cb4a2f725a62324045fbb">ClientConnected</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the status of a clients connection.  <a href="#a610b8f09cd7cb4a2f725a62324045fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a7d81f328dd5c332a4f9e81fceb3cde86">ClientJoined</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This command manages incoming connections from clients.  <a href="#a7d81f328dd5c332a4f9e81fceb3cde86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad3d7ccec1d7685e6066903e4b1c42eb7">DisconnectClient</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnects specified client.  <a href="#ad3d7ccec1d7685e6066903e4b1c42eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a6b916758db66bfd3af882043637d329d">GetServerInfo</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that is sent to clients during the handshaking process, containing information about the server.  <a href="#a6b916758db66bfd3af882043637d329d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#afa2693699a9e7a6fdd0b9195d9d90c06">IsEnabledUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP is enabled.  <a href="#afa2693699a9e7a6fdd0b9195d9d90c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a70cdb75d88690871c7734b6ede603dc6">GetModeUDP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the protocol mode in use.  <a href="#a70cdb75d88690871c7734b6ede603dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad29f6ddf3371384372a16220e701fc23">GetRecvBufferLengthTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of data that can be received in one winsock receive operation.  <a href="#ad29f6ddf3371384372a16220e701fc23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a0cace5b7658e0b77d9238ed2ed6c27a3">GetPartialPacketCurrentSizeTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of the current partial packet that has been received in bytes.  <a href="#a0cace5b7658e0b77d9238ed2ed6c27a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#abff9523871ba3f7b633cf52f6be9e2ed">GetMaxPacketSizeTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the largest TCP packet that can be received without error or increase in buffer size.  <a href="#abff9523871ba3f7b633cf52f6be9e2ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ae1d11752a5764fc2b5ba5ac201c4d25a">SetMaxPacketSizeTCP</a> (size_t newMaxSize, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the maximum packet size that can be received.  <a href="#ae1d11752a5764fc2b5ba5ac201c4d25a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a686365235a9ec94764d237c889f14b43">GetAutoResizeTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether auto resize is enabled, if enabled the TCP receive buffer size will increase as necessary to accommodate large packets.  <a href="#a686365235a9ec94764d237c889f14b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#aff5d113ed49b9260903d50d832ea62dd">SetAutoResizeTCP</a> (bool newAutoResizeTCP, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables auto resize, if enabled the TCP receive buffer size will increase as necessary to accommodate large packets.  <a href="#aff5d113ed49b9260903d50d832ea62dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad96584152bac1eae1103a98f90556fa4">IsGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether graceful disconnection is enabled.  <a href="#ad96584152bac1eae1103a98f90556fa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a545676597d34fabc02a6d896d9c69d3d">GetProtocolModeTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP mode in use by the instance. Clients connecting must use the same TCP mode to connect successfully.  <a href="#a545676597d34fabc02a6d896d9c69d3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a360d85df2f48ca7964816bc95ed9ad98">GetClientLocalAddressTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the local TCP address in use by the specified client.  <a href="#a360d85df2f48ca7964816bc95ed9ad98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ae1b6038671d198ce1f26da38661c397f">GetLocalAddressTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the local TCP address in use by the server. Connecting clients should attempt to connect to this address.  <a href="#ae1b6038671d198ce1f26da38661c397f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a3c59e50787e9899cbe28704311ab6c8d">GetConnectAddressTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the TCP address that the specified client is connected to.  <a href="#a3c59e50787e9899cbe28704311ab6c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a3ffa00319b256d1b9e510a52b1a160f7">GetConnectAddressUDP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UDP address that the specified client is connected to.  <a href="#a3ffa00319b256d1b9e510a52b1a160f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a117f03d0c5b49d72eb9967a008e4d337">FlushRecvTCP</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the TCP received packet queue.  <a href="#a117f03d0c5b49d72eb9967a008e4d337"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ac15dcd9a67405e2a13caf4d22177044e">GetPacketAmountTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of packets in the received TCP packet queue.  <a href="#ac15dcd9a67405e2a13caf4d22177044e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a6fc8b2758df2f359efbd6100e8f6fd24">ShutdownTCP</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the graceful disconnection process.  <a href="#a6fc8b2758df2f359efbd6100e8f6fd24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a8b804b04c6ef8cd9dec91e715b55073d">GetPacketFromStoreTCP</a> (<a class="el" href="class_packet.html">Packet</a> *destination, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a complete packet from the TCP packet store.  <a href="#a8b804b04c6ef8cd9dec91e715b55073d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#afeec2cbabcb1b21ec634506a91712d61">SendTCP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via TCP to specified client.  <a href="#afeec2cbabcb1b21ec634506a91712d61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a29f1868afb448ee9f6aa2aacdfbc34d2">SendAllTCP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, size_t clientExclude)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via TCP to all connected clients.  <a href="#a29f1868afb448ee9f6aa2aacdfbc34d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#af8e4f5fcae8def947487282b5d217d5d">SendUDP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via UDP to the specified client.  <a href="#af8e4f5fcae8def947487282b5d217d5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#afe73616d1530e5fb6a440a80c5649f5d">SendAllUDP</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, size_t clientExclude)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via UDP to all connected clients.  <a href="#afe73616d1530e5fb6a440a80c5649f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a7447476c3b949378488c3b5c6cb11a5b">SendToUDP</a> (const <a class="el" href="class_net_address.html">NetAddress</a> &amp;address, const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet via UDP to specified address.  <a href="#a7447476c3b949378488c3b5c6cb11a5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#add6aa270fbd6d83ad17183053f11dc2d">GetPacketAmountUDP</a> (size_t clientID, size_t operationID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of packets in the UDP received packet queue.  <a href="#add6aa270fbd6d83ad17183053f11dc2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a8cfa932ed98a1c99fceb358c3e776d52">FlushRecvUDP</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the UDP received packet queue.  <a href="#a8cfa932ed98a1c99fceb358c3e776d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a39e375bce512ed9f8730bf7df0157752">GetPacketFromStoreUDP</a> (<a class="el" href="class_packet.html">Packet</a> *destination, size_t clientID, size_t operationID=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a complete packet from the TCP received packet queue.  <a href="#a39e375bce512ed9f8730bf7df0157752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ab2a3180190619f8125fe678845da7431">GetPartialPacketPercentageTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the percentage of the partial packet that has been received.  <a href="#ab2a3180190619f8125fe678845da7431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a417e35aab0663c39d49f777271d5e219">GetNagleEnabledTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the nagle algorithm is enabled or disabled.  <a href="#a417e35aab0663c39d49f777271d5e219"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#aaacfcc13696bf11dd8e4fc11d4eb15b5">GetPostfixTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP postfix in use in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>.  <a href="#aaacfcc13696bf11dd8e4fc11d4eb15b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ae7ce00865c6b1224deb6ea7c29efff4f">DealCompletion</a> (<a class="el" href="class_net_socket.html">NetSocket</a> *socket, DWORD bytes, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When send and receive operations are completed on this instance, this method is called. When data is received from an unlisted UDP address, i.e. An address that is not stored under any connected client ID, this method performs part of the <a class="el" href="handshake_page.html">handshaking process</a>.  <a href="#ae7ce00865c6b1224deb6ea7c29efff4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a130905df8ecd72b55f44cf0c650abfd7">GetConnectionStateTCP</a> (size_t clientID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the state that the specified client's TCP connection is in.  <a href="#a130905df8ecd72b55f44cf0c650abfd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#afc0c9da88cbcee8d440ee56327c95073">GetUserFunctionTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP function that is executed when complete TCP packets are received.  <a href="#afc0c9da88cbcee8d440ee56327c95073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a737e649eb26f28c1273a5ef1b6d783fa">IsUserFunctionLoadedTCP</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a TCP function has been loaded.  <a href="#a737e649eb26f28c1273a5ef1b6d783fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#aa0f96225d448f4b35a8a09dcbd0232ab">CloseSockets</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes any sockets in use by the instance.  <a href="#aa0f96225d448f4b35a8a09dcbd0232ab"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a1fcda8d3abed6eb0861121beac3a5d27">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#a1fcda8d3abed6eb0861121beac3a5d27"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696823c10d42a6fd99014fd3f60c13db"></a><!-- doxytag: member="NetInstanceServer::recvSizeMinUDP" ref="a696823c10d42a6fd99014fd3f60c13db" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a696823c10d42a6fd99014fd3f60c13db">recvSizeMinUDP</a> = 20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum UDP buffer size necessary to maintain normal operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a510912085bc79be443909904ee727b64"></a><!-- doxytag: member="NetInstanceServer::recvSizeMinTCP" ref="a510912085bc79be443909904ee727b64" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a510912085bc79be443909904ee727b64">recvSizeMinTCP</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum TCP buffer size necessary to maintain normal operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace7e83c6a82f0810cee2c7c638bb9397"></a><!-- doxytag: member="NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT" ref="ace7e83c6a82f0810cee2c7c638bb9397" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397">DEFAULT_CONNECTION_TIMEOUT</a> = 10000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default time in milliseconds that a connection attempt will be waited on before giving up. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a5d897df5cbe7e4aa3f2c0b963479f38d">ValidateClientID</a> (size_t clientID, size_t line, const char *file) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks that client ID is within range and throws an exception if it is not.  <a href="#a5d897df5cbe7e4aa3f2c0b963479f38d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ab2c52af8d0d42b385ebb17f02a8e8645">FindClientByAddressUDP</a> (const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches all connected clients and determines if the specified address a remote UDP address belonging to one of them. If it is then the client can be deemed connected via UDP.  <a href="#ab2c52af8d0d42b385ebb17f02a8e8645"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c00d75b589e62553821f7278d0e851e"></a><!-- doxytag: member="NetInstanceServer::socketListening" ref="a5c00d75b589e62553821f7278d0e851e" args="" -->
<a class="el" href="class_net_socket_listening.html">NetSocketListening</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a5c00d75b589e62553821f7278d0e851e">socketListening</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket used to accept TCP connections from clients. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_counter.html">Counter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a2f71d29128ad06c912dbf7d3cb5a1fe9">recvFailCounterUDP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counter that keeps track of UDP receive failures.  <a href="#a2f71d29128ad06c912dbf7d3cb5a1fe9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92484b7365cfad05ead9b44ed4a8ea17"></a><!-- doxytag: member="NetInstanceServer::client" ref="a92484b7365cfad05ead9b44ed4a8ea17" args="" -->
<a class="el" href="class_store_vector.html">StoreVector</a>&lt; <a class="el" href="class_net_server_client.html">NetServerClient</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a92484b7365cfad05ead9b44ed4a8ea17">client</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08f9f216c652168e54dc0f86dff2416"></a><!-- doxytag: member="NetInstanceServer::maxClients" ref="ae08f9f216c652168e54dc0f86dff2416" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ae08f9f216c652168e54dc0f86dff2416">maxClients</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of clients that can be connected to server at any one time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af628c8f03d1e55cc7a26ad309ac62418"></a><!-- doxytag: member="NetInstanceServer::disconnected" ref="af628c8f03d1e55cc7a26ad309ac62418" args="" -->
<a class="el" href="class_store_queue.html">StoreQueue</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#af628c8f03d1e55cc7a26ad309ac62418">disconnected</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of recently disconnected clients to be used by ClientLeft. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e079318790eb164ba2f52d80fcbd86"></a><!-- doxytag: member="NetInstanceServer::timeout" ref="ad8e079318790eb164ba2f52d80fcbd86" args="" -->
<a class="el" href="class_concurrent_object.html">ConcurrentObject</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#ad8e079318790eb164ba2f52d80fcbd86">timeout</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time in milliseconds that a connection attempt will be waited on before giving up. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b65e49e2bc9b65f269e43e46ad87635"></a><!-- doxytag: member="NetInstanceServer::serverInfo" ref="a4b65e49e2bc9b65f269e43e46ad87635" args="" -->
<a class="el" href="class_packet.html">Packet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_instance_server.html#a4b65e49e2bc9b65f269e43e46ad87635">serverInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet contains data that is sent to clients upon connection. The data describes key characteristics of the server. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Server instance, designed to communicate with clients. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This instance uses TCP and UDP to communicate with clients. Most commonly it will be used to communicate with another entity running a <a class="el" href="class_net_instance_client.html" title="Client instance, designed to communicate with servers.">NetInstanceClient</a> instance. However, this instance can also communicate with non DarkNet entities such as web clients. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a39f8de86af491972f0c99c82dc9f9772"></a><!-- doxytag: member="NetInstanceServer::NetInstanceServer" ref="a39f8de86af491972f0c99c82dc9f9772" args="(size_t maxClients, NetSocketListening *listeningSocket, NetSocketUDP *socketUDP, bool handshakeEnabled, unsigned int sendTimeout=INFINITE, size_t connectionTimeout=DEFAULT_CONNECTION_TIMEOUT, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceServer::NetInstanceServer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket_listening.html">NetSocketListening</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketListening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket_u_d_p.html">NetSocketUDP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>p_sendTimeout</em> = <code>INFINITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectionTimeout</em> = <code><a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397">DEFAULT_CONNECTION_TIMEOUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>Maximum number of clients that can be connected to server at any one time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketListening</em>&nbsp;</td><td>Socket to use to listen for new TCP connections. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketUDP</em>&nbsp;</td><td>Socket to use to send and receive UDP data, NULL if UDP is disabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>True if the TCP handshaking process is enabled, false if not. For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_sendTimeout</em>&nbsp;</td><td>Length of time in milliseconds to wait for a send operation to complete before disconnecting client (optional, default INFINITE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_connectionTimeout</em>&nbsp;</td><td>Time in milliseconds that a connection attempt will be waited on before giving up (optional, default DEFAULT_CONNECTION_TIMEOUT). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>Unique identifier for instance (optional, default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="class_net_instance_server.html#a6c809f671ccc29e9c688545ac12eb0fc" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad339320c92e5ea5ab9b0b6f572db30ee"></a><!-- doxytag: member="NetInstanceServer::NetInstanceServer" ref="ad339320c92e5ea5ab9b0b6f572db30ee" args="(size_t maxClients, const NetInstanceProfile &amp;profile, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceServer::NetInstanceServer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, using profile instead of individual parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>Maximum number of clients that can be connected to server at any one time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_profile</em>&nbsp;</td><td>Instance profile containing parameters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>Unique identifier for instance (optional, default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="class_net_instance_server.html#a6c809f671ccc29e9c688545ac12eb0fc" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea6efa8d9213d060c8976a776030bd64"></a><!-- doxytag: member="NetInstanceServer::~NetInstanceServer" ref="aea6efa8d9213d060c8976a776030bd64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetInstanceServer::~NetInstanceServer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>CloseSockets must be used in the destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad3ddeb6490be9a07235582b221b1f4aa"></a><!-- doxytag: member="NetInstanceServer::AddDisconnect" ref="ad3ddeb6490be9a07235582b221b1f4aa" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::AddDisconnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>client</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a client to the disconnect list, indicating that it has recently been disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>client</em>&nbsp;</td><td>Client ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a610b8f09cd7cb4a2f725a62324045fbb"></a><!-- doxytag: member="NetInstanceServer::ClientConnected" ref="a610b8f09cd7cb4a2f725a62324045fbb" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceServer::ClientConnected </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the status of a clients connection. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client who's connection status should be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a>: Fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6daef8b7210b8ae3961e19fcde743ee08af">NetUtility::NOT_CONNECTED</a>: Not connected at all. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dad749d5c33d1f4fda670efe634f651885">NetUtility::NO_RECV</a>: Connected but new data cannot be received because <code>Shutdown</code> has been used by recipient (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da1bcc92a56bd754f0e02e33787f7f9e38">NetUtility::NO_SEND</a>: Connected but data cannot be sent because <code>Shutdown</code> has been used (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabfdb16770f1140f86d621739ffe89560">NetUtility::NO_SEND_RECV</a>: Connected but data cannot be sent or received because <code>Shutdown</code> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if graceful disconnect is enabled). </dd></dl>

</div>
</div>
<a class="anchor" id="a7d81f328dd5c332a4f9e81fceb3cde86"></a><!-- doxytag: member="NetInstanceServer::ClientJoined" ref="a7d81f328dd5c332a4f9e81fceb3cde86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::ClientJoined </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command manages incoming connections from clients. </p>
<p>For a client to connect, this command must have been called several times during the handshaking process. It is best to call this continuously in a loop that runs this networking module. <br/>
<br/>
</p>
<p>Connection requests will be rejected if the maximum number of clients has been reached.<br/>
<br/>
</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no new clients joined during the method call. </dd>
<dd>
&gt;0 if a new client joined, this number is the ID of the client. </dd></dl>

<p><p>When a TCP connection is accepted, an unused client ID needs to be found. It is more efficient only to have one loop checking the status of clients and this loop occurs before WSAAccept. The loop will fill unusedClientID with the first unused client ID that it finds, so that a new client can be given the ID.</p>
<p>If unusedClientID remains 0 then no free client ID was found.</p>
</p>

</div>
</div>
<a class="anchor" id="aa0f96225d448f4b35a8a09dcbd0232ab"></a><!-- doxytag: member="NetInstanceServer::CloseSockets" ref="aa0f96225d448f4b35a8a09dcbd0232ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::CloseSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes any sockets in use by the instance. </p>
<p>Must be called in the destructor so that instance is not cleaned up until completion port is done using it. </p>

<p>Implements <a class="el" href="class_net_instance.html#ac66260d17fe4b07c2f01aefee8a2b480">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="a6a1425669efcbb0e36bddb6394e79f57"></a><!-- doxytag: member="NetInstanceServer::CompletionError" ref="a6a1425669efcbb0e36bddb6394e79f57" args="(NetSocket *completionSocket, size_t clientID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::CompletionError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>completionSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the completion port when an error occurred during an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>completionSocket</em>&nbsp;</td><td>The socket responsible for the error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>The client ID responsible for the error. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#a6f1377ef6caee467d27288cf53619b37">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ce00865c6b1224deb6ea7c29efff4f"></a><!-- doxytag: member="NetInstanceServer::DealCompletion" ref="ae7ce00865c6b1224deb6ea7c29efff4f" args="(NetSocket *socket, DWORD bytes, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::DealCompletion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When send and receive operations are completed on this instance, this method is called. When data is received from an unlisted UDP address, i.e. An address that is not stored under any connected client ID, this method performs part of the <a class="el" href="handshake_page.html">handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>[in,out] Socket that operation was started by. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>Number of bytes of data transferred in operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that owns socket. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Discard prefix.</p>
<p>We do this because after connection there may be connection UDP packets that are received. The prefix is always 0 which allows us to differentiate between connection packets and normal packets.</p>
</p>

<p>Implements <a class="el" href="class_net_instance.html#a77a9c992d7ab0b023de51470a3392c49">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d7ccec1d7685e6066903e4b1c42eb7"></a><!-- doxytag: member="NetInstanceServer::DisconnectClient" ref="ad3d7ccec1d7685e6066903e4b1c42eb7" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::DisconnectClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects specified client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1df65dc8572fc44730e5dd76e5aeabfe"></a><!-- doxytag: member="NetInstanceServer::DoRecv" ref="a1df65dc8572fc44730e5dd76e5aeabfe" args="(NetSocket *socket, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::DoRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_socket.html">NetSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls <a class="el" href="class_net_socket_t_c_p.html#a11891910910477cf1eba5fffef8bda52" title="Starts a receive operation via TCP.">NetSocketTCP::Recv</a> or <a class="el" href="class_net_socket_u_d_p.html#a5b7438968a34510997e9db862e00139b" title="Starts a receive operation via TCP.">NetSocketUDP::Recv</a> and deals with errors in a server specific way. </p>
<p>Use this INSTEAD OF socket***-&gt;Recv, never use socket***-&gt;Recv directly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>Pointer to socket that receive operation should be started on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that receive operation should apply to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#a3c3e7a1dfd8e6c54c25f2a61aa86f183">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="aa230090218577e35109d61e87b560877"></a><!-- doxytag: member="NetInstanceServer::ErrorOccurred" ref="aa230090218577e35109d61e87b560877" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::ErrorOccurred </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with errors. </p>
<p>Client <em>clientID</em> is disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to disconnected, if 0 then no action is taken. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance.html#ab3369f37337a9de2cbefe92f0bf1d087">NetInstance</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c52af8d0d42b385ebb17f02a8e8645"></a><!-- doxytag: member="NetInstanceServer::FindClientByAddressUDP" ref="ab2c52af8d0d42b385ebb17f02a8e8645" args="(const NetAddress &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::FindClientByAddressUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches all connected clients and determines if the specified address a remote UDP address belonging to one of them. If it is then the client can be deemed connected via UDP. </p>
<p>This method is used as part of the <a class="el" href="handshake_page.html">handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no client was found. </dd>
<dd>
&gt;0 if client was found, this is the client ID of the client. </dd></dl>

</div>
</div>
<a class="anchor" id="a117f03d0c5b49d72eb9967a008e4d337"></a><!-- doxytag: member="NetInstanceServer::FlushRecvTCP" ref="a117f03d0c5b49d72eb9967a008e4d337" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the TCP received packet queue. </p>
<p>When TCP packets are received and a receive function has not been set (in the constructor), packets are put into a queue and received using GetPacketFromStoreTCP. If the queue gets too big newer packets may not be received for some time and so it can be useful to empty the queue. This command discards everything in the queue.<br/>
<br/>
</p>
<p>Has no impact on the partial packet store. <br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a545e0d5c995e0b8ac43c72c786800e0b">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfa932ed98a1c99fceb358c3e776d52"></a><!-- doxytag: member="NetInstanceServer::FlushRecvUDP" ref="a8cfa932ed98a1c99fceb358c3e776d52" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::FlushRecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the UDP received packet queue. </p>
<p>When UDP packets are received and a receive function has not been set (in the constructor), packets are put into a queue and received using GetPacketFromStoreUDP. If the queue gets too big newer packets may not be received for some time and so it can be useful to empty the queue. This command discards everything in the queue.<br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Reimplemented to enforce multithreaded control rules. </dd></dl>

</div>
</div>
<a class="anchor" id="a686365235a9ec94764d237c889f14b43"></a><!-- doxytag: member="NetInstanceServer::GetAutoResizeTCP" ref="a686365235a9ec94764d237c889f14b43" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether auto resize is enabled, if enabled the TCP receive buffer size will increase as necessary to accommodate large packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>when true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a59cf03453fd680e8a2a0dc4395f1f70a">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a360d85df2f48ca7964816bc95ed9ad98"></a><!-- doxytag: member="NetInstanceServer::GetClientLocalAddressTCP" ref="a360d85df2f48ca7964816bc95ed9ad98" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceServer::GetClientLocalAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the local TCP address in use by the specified client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c59e50787e9899cbe28704311ab6c8d"></a><!-- doxytag: member="NetInstanceServer::GetConnectAddressTCP" ref="a3c59e50787e9899cbe28704311ab6c8d" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceServer::GetConnectAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the TCP address that the specified client is connected to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ac856c99e8ebf03cd3822885521274ed7">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a3ffa00319b256d1b9e510a52b1a160f7"></a><!-- doxytag: member="NetInstanceServer::GetConnectAddressUDP" ref="a3ffa00319b256d1b9e510a52b1a160f7" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceServer::GetConnectAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the UDP address that the specified client is connected to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a130905df8ecd72b55f44cf0c650abfd7"></a><!-- doxytag: member="NetInstanceServer::GetConnectionStateTCP" ref="a130905df8ecd72b55f44cf0c650abfd7" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetInstanceServer::GetConnectionStateTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the state that the specified client's TCP connection is in. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>connection state of client purely looking at the TCP socket.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>GetConnectionState() and this method are unlinked. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a635bb48421cde040f391c553c437d634">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a263c1e81f7f756f2102da0c01abffc62"></a><!-- doxytag: member="NetInstanceServer::GetDisconnect" ref="a263c1e81f7f756f2102da0c01abffc62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetDisconnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a client from the disconnect list, this client has been recently disconnected. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>client ID. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b6038671d198ce1f26da38661c397f"></a><!-- doxytag: member="NetInstanceServer::GetLocalAddressTCP" ref="ae1b6038671d198ce1f26da38661c397f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; NetInstanceServer::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the local TCP address in use by the server. Connecting clients should attempt to connect to this address. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Is okay to return reference because <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> is thread safe. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a01155c373c9794f98a69ac05d9a2491c">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ab436ece5c02fa04fe425cfcfd6656656"></a><!-- doxytag: member="NetInstanceServer::GetMaxClients" ref="ab436ece5c02fa04fe425cfcfd6656656" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetMaxClients </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the maximum number of clients that can be connected to the server at any one time. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum number of clients that can be connected to the server at any one time (<code>maxClients</code>). Client IDs range from 1 inclusive to this value inclusive, client ID 0 is not used. </dd></dl>

</div>
</div>
<a class="anchor" id="abff9523871ba3f7b633cf52f6be9e2ed"></a><!-- doxytag: member="NetInstanceServer::GetMaxPacketSizeTCP" ref="abff9523871ba3f7b633cf52f6be9e2ed" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the largest TCP packet that can be received without error or increase in buffer size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#acd2529df4ee98a7b2ca144a60feb1bb2">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a70cdb75d88690871c7734b6ede603dc6"></a><!-- doxytag: member="NetInstanceServer::GetModeUDP" ref="a70cdb75d88690871c7734b6ede603dc6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetInstanceServer::GetModeUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the protocol mode in use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the UDP protocol mode in use, describing how data is manipulated during sending and receiving. </dd></dl>

</div>
</div>
<a class="anchor" id="a417e35aab0663c39d49f777271d5e219"></a><!-- doxytag: member="NetInstanceServer::GetNagleEnabledTCP" ref="a417e35aab0663c39d49f777271d5e219" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::GetNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the nagle algorithm is enabled or disabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the nagle algorithm is enabled for the instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a797c6d8f382ae72386afd0c52b45aa48">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ac15dcd9a67405e2a13caf4d22177044e"></a><!-- doxytag: member="NetInstanceServer::GetPacketAmountTCP" ref="ac15dcd9a67405e2a13caf4d22177044e" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetPacketAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of packets in the received TCP packet queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of fully received TCP packets in the packet store. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ac5b7728d5152d157d6b87e60081db168">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="add6aa270fbd6d83ad17183053f11dc2d"></a><!-- doxytag: member="NetInstanceServer::GetPacketAmountUDP" ref="add6aa270fbd6d83ad17183053f11dc2d" args="(size_t clientID, size_t operationID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetPacketAmountUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of packets in the UDP received packet queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in the packet store. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>Operation ID of operation to use, may be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Reimplemented to enforce multithreaded control rules. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b804b04c6ef8cd9dec91e715b55073d"></a><!-- doxytag: member="NetInstanceServer::GetPacketFromStoreTCP" ref="a8b804b04c6ef8cd9dec91e715b55073d" args="(Packet *destination, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetPacketFromStoreTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a complete packet from the TCP packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination to copy into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a602f43e93a742836c558e5f086ce52c7">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a39e375bce512ed9f8730bf7df0157752"></a><!-- doxytag: member="NetInstanceServer::GetPacketFromStoreUDP" ref="a39e375bce512ed9f8730bf7df0157752" args="(Packet *destination, size_t clientID, size_t operationID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetPacketFromStoreUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a complete packet from the TCP received packet queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination to copy into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to use (optional, default 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Reimplemented to enforce multithreaded control rules. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cace5b7658e0b77d9238ed2ed6c27a3"></a><!-- doxytag: member="NetInstanceServer::GetPartialPacketCurrentSizeTCP" ref="a0cace5b7658e0b77d9238ed2ed6c27a3" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetPartialPacketCurrentSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of the current partial packet that has been received in bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current size of the TCP partial packet being received. i.e. The number of bytes of the packet that have been received. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ab32a5b7813c41e2f7149ef8c8adede38">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ab2a3180190619f8125fe678845da7431"></a><!-- doxytag: member="NetInstanceServer::GetPartialPacketPercentageTCP" ref="ab2a3180190619f8125fe678845da7431" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double NetInstanceServer::GetPartialPacketPercentageTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the percentage of the partial packet that has been received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use, may be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the percentage of the partial packet that has been received i.e. Between 0 and 100 where 50 indicates that half the packet has been received and we are now waiting for the second half to be received. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a2d4a7129fbe74b7f2e562d5e8a1f84cf">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aaacfcc13696bf11dd8e4fc11d4eb15b5"></a><!-- doxytag: member="NetInstanceServer::GetPostfixTCP" ref="aaacfcc13696bf11dd8e4fc11d4eb15b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packet.html">Packet</a> &amp; NetInstanceServer::GetPostfixTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP postfix in use in TCP mode <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a>. </p>
<p>If TCP mode is not <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> this command will fail.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the postfix in use by the TCP instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a5509277d168a5be5d6ebc643afe34d3e">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a545676597d34fabc02a6d896d9c69d3d"></a><!-- doxytag: member="NetInstanceServer::GetProtocolModeTCP" ref="a545676597d34fabc02a6d896d9c69d3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetInstanceServer::GetProtocolModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP mode in use by the instance. Clients connecting must use the same TCP mode to connect successfully. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>protocol mode in use by instance. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ad6252dc4923ef58376b2c36a5cb9cbe0">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ad29f6ddf3371384372a16220e701fc23"></a><!-- doxytag: member="NetInstanceServer::GetRecvBufferLengthTCP" ref="ad29f6ddf3371384372a16220e701fc23" args="(size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetRecvBufferLengthTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of data that can be received in one winsock receive operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF used by the TCP socket. This is the maximum amount of data that can be received with one winsock receive operation. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a8702bf908ad147d94b4351077c9ae599">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a6c809f671ccc29e9c688545ac12eb0fc"></a><!-- doxytag: member="NetInstanceServer::GetRecvSizeMinTCP" ref="a6c809f671ccc29e9c688545ac12eb0fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetRecvSizeMinTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the minimum TCP receive buffer size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum TCP receive buffer size. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a75e1024a7352c83b7691bd3268e24136">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a9763425c0e0489e4eea07b72ea1e7fc2"></a><!-- doxytag: member="NetInstanceServer::GetRecvSizeMinUDP" ref="a9763425c0e0489e4eea07b72ea1e7fc2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetRecvSizeMinUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the minimum UDP receive buffer size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum UDP receive buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b916758db66bfd3af882043637d329d"></a><!-- doxytag: member="NetInstanceServer::GetServerInfo" ref="a6b916758db66bfd3af882043637d329d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packet.html">Packet</a> &amp; NetInstanceServer::GetServerInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that is sent to clients during the handshaking process, containing information about the server. </p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Packet containing information about the server. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f6d9df5a672c6f94892e11d41101756"></a><!-- doxytag: member="NetInstanceServer::GetServerTimeout" ref="a2f6d9df5a672c6f94892e11d41101756" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetInstanceServer::GetServerTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the moment that a client first communicates with the server, it is allowed 'server timeout' number of milliseconds to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. </p>
<p>Note that ClientLeft will not receive notification since ClientJoined will not have.<br/>
<br/>
</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of milliseconds that connection attempt should be allowed to complete before entity is forcefully disconnected. /n/n. </dd></dl>

</div>
</div>
<a class="anchor" id="afc0c9da88cbcee8d440ee56327c95073"></a><!-- doxytag: member="NetInstanceServer::GetUserFunctionTCP" ref="afc0c9da88cbcee8d440ee56327c95073" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> NetInstanceServer::GetUserFunctionTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP function that is executed when complete TCP packets are received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the method set by the user that should be executed when data is received. </dd>
<dd>
NULL if there is no method. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a8dfdf67081405105b691c15cc867725d">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a6f6c3fb0a639d85d251fe746838df2d8"></a><!-- doxytag: member="NetInstanceServer::Initialize" ref="a6f6c3fb0a639d85d251fe746838df2d8" args="(size_t maxClients, bool handshakeEnabled, size_t connectionTimeout, NetSocketListening *socketListening)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::Initialize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectionTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket_listening.html">NetSocketListening</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketListening</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>Maximum number of clients that can be connected to server at any one time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>True if the TCP handshaking process is enabled, false if not. For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_connectionTimeout</em>&nbsp;</td><td>Time in milliseconds that a connection attempt will be waited on before giving up (optional, default DEFAULT_CONNECTION_TIMEOUT). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketListening</em>&nbsp;</td><td>Socket to use to listen for new TCP connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>SocketUDP Must be initialized before using this method (is done in super class constructor). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="class_net_instance_server.html#a6c809f671ccc29e9c688545ac12eb0fc" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Server info packet contains: 1: Maximum number of clients. 2: Number of operations (UDP only). 3: UDP Mode (UDP only).</p>
</p>

</div>
</div>
<a class="anchor" id="afa2693699a9e7a6fdd0b9195d9d90c06"></a><!-- doxytag: member="NetInstanceServer::IsEnabledUDP" ref="afa2693699a9e7a6fdd0b9195d9d90c06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::IsEnabledUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if UDP is enabled, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ad96584152bac1eae1103a98f90556fa4"></a><!-- doxytag: member="NetInstanceServer::IsGracefulDisconnectEnabled" ref="ad96584152bac1eae1103a98f90556fa4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::IsGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether graceful disconnection is enabled. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if true graceful disconnection is possible, where data is allowed to finish sending and receiving before the connection is closed. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#aae7db49f79eaf1fd5359c084e893f946">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a737e649eb26f28c1273a5ef1b6d783fa"></a><!-- doxytag: member="NetInstanceServer::IsUserFunctionLoadedTCP" ref="a737e649eb26f28c1273a5ef1b6d783fa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::IsUserFunctionLoadedTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether a TCP function has been loaded. </p>
<p>If no TCP function has been loaded received packets are put into a queue and retrieved using GetPacketFromStoreTCP.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a method to be executed when data is received has been set. </dd>
<dd>
false if no method has been set. </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ad1e427866c1a3703a224131c2d46fa9d">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a29f1868afb448ee9f6aa2aacdfbc34d2"></a><!-- doxytag: member="NetInstanceServer::SendAllTCP" ref="a29f1868afb448ee9f6aa2aacdfbc34d2" args="(const Packet &amp;packet, bool block, size_t clientExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SendAllTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>excludeClient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via TCP to all connected clients. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>excludeClient</em>&nbsp;</td><td>Client ID of client not to send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe73616d1530e5fb6a440a80c5649f5d"></a><!-- doxytag: member="NetInstanceServer::SendAllUDP" ref="afe73616d1530e5fb6a440a80c5649f5d" args="(const Packet &amp;packet, bool block, size_t clientExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SendAllUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>excludeClient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via UDP to all connected clients. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>excludeClient</em>&nbsp;</td><td>ClientID of client not to send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afeec2cbabcb1b21ec634506a91712d61"></a><!-- doxytag: member="NetInstanceServer::SendTCP" ref="afeec2cbabcb1b21ec634506a91712d61" args="(const Packet &amp;packet, bool block, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceServer::SendTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via TCP to specified client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to send to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#a1dd6a5b47974fc6863edde6443f75a32">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a7447476c3b949378488c3b5c6cb11a5b"></a><!-- doxytag: member="NetInstanceServer::SendToUDP" ref="a7447476c3b949378488c3b5c6cb11a5b" args="(const NetAddress &amp;address, const Packet &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceServer::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via UDP to specified address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Remote address to send to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="af8e4f5fcae8def947487282b5d217d5d"></a><!-- doxytag: member="NetInstanceServer::SendUDP" ref="af8e4f5fcae8def947487282b5d217d5d" args="(const Packet &amp;packet, bool block, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetInstanceServer::SendUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet via UDP to the specified client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to send to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f855ae23ae42a4c648957ca1a6107b"></a><!-- doxytag: member="NetInstanceServer::SetAutoResize" ref="ae9f855ae23ae42a4c648957ca1a6107b" args="(bool autoResize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SetAutoResize </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>paraAutoResize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the auto resize option for all clients. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paraAutoResize</em>&nbsp;</td><td>If true then if a packet larger than the maximum is received, the maximum will be increased silently. <br/>
 if false then an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff5d113ed49b9260903d50d832ea62dd"></a><!-- doxytag: member="NetInstanceServer::SetAutoResizeTCP" ref="aff5d113ed49b9260903d50d832ea62dd" args="(bool newAutoResizeTCP, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables auto resize, if enabled the TCP receive buffer size will increase as necessary to accommodate large packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#ab9cc381e6561444004d82ea394ccf2fe">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ae1d11752a5764fc2b5ba5ac201c4d25a"></a><!-- doxytag: member="NetInstanceServer::SetMaxPacketSizeTCP" ref="ae1d11752a5764fc2b5ba5ac201c4d25a" args="(size_t newMaxSize, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newMaxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the maximum packet size that can be received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newMaxSize</em>&nbsp;</td><td>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If newMaxSize &lt; <a class="el" href="class_net_instance_server.html#a6c809f671ccc29e9c688545ac12eb0fc" title="Retrieves the minimum TCP receive buffer size.">GetRecvSizeMinTCP()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#afe39589a67763fc6becc79f39659c3a4">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a1b7871958d05e1e0e9f3e683dcc8162b"></a><!-- doxytag: member="NetInstanceServer::SetServerTimeout" ref="a1b7871958d05e1e0e9f3e683dcc8162b" args="(size_t milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::SetServerTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the moment that a client first communicates with the server, it is allowed 'server timeout' number of milliseconds to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. </p>
<p>Note that ClientLeft will not receive notification since ClientJoined will not have. <br/>
<br/>
</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. <br/>
<br/>
</p>
<p>This method is part of a security precaution. If the server is spammed with connection attempts that never complete it would eventually throw an error due to running out of memory. <br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>milliseconds</em>&nbsp;</td><td>Number of milliseconds that connection attempt should be allowed to complete before entity is forcefully disconnected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fc8b2758df2f359efbd6100e8f6fd24"></a><!-- doxytag: member="NetInstanceServer::ShutdownTCP" ref="a6fc8b2758df2f359efbd6100e8f6fd24" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::ShutdownTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the graceful disconnection process. </p>
<p>Stops sending on TCP socket so that all further send operations will fail. All data sent up till now will be received by recipient. This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_instance_t_c_p.html#abb23de43a14d5809a79871a05244d17b">NetInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a1fcda8d3abed6eb0861121beac3a5d27"></a><!-- doxytag: member="NetInstanceServer::TestClass" ref="a1fcda8d3abed6eb0861121beac3a5d27" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetInstanceServer::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d897df5cbe7e4aa3f2c0b963479f38d"></a><!-- doxytag: member="NetInstanceServer::ValidateClientID" ref="a5d897df5cbe7e4aa3f2c0b963479f38d" args="(size_t clientID, size_t line, const char *file) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetInstanceServer::ValidateClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that client ID is within range and throws an exception if it is not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Client ID to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>Line number that method was called at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>File that method was called in. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If clientID &gt; maxClients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2f71d29128ad06c912dbf7d3cb5a1fe9"></a><!-- doxytag: member="NetInstanceServer::recvFailCounterUDP" ref="a2f71d29128ad06c912dbf7d3cb5a1fe9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_counter.html">Counter</a> <a class="el" href="class_net_instance_server.html#a2f71d29128ad06c912dbf7d3cb5a1fe9">NetInstanceServer::recvFailCounterUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Counter that keeps track of UDP receive failures. </p>
<p>WSARecv can sometimes fail for reasons that should not result in catastrophic failure of the instance e.g. A WSASendTo operation to a remote address failed. For this reason we retry receive operations a number of times, when to give up is managed by this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_instance_server_8h_source.html">NetInstanceServer.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetInstanceServer.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:20 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
