<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetMode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>NetMode Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetMode" -->
<p>Base class for net modes such as <a class="el" href="class_net_mode_udp.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">NetModeUdp</a> and <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_mode_8h_source.html">NetMode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetMode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_mode.png" usemap="#NetMode_map" alt=""/>
  <map id="NetMode_map" name="NetMode_map">
<area href="class_net_mode_tcp.html" alt="NetModeTcp" shape="rect" coords="159,56,308,80"/>
<area href="class_net_mode_udp.html" alt="NetModeUdp" shape="rect" coords="556,56,705,80"/>
<area href="class_net_mode_tcp_postfix.html" alt="NetModeTcpPostfix" shape="rect" coords="0,112,149,136"/>
<area href="class_net_mode_tcp_prefix_size.html" alt="NetModeTcpPrefixSize" shape="rect" coords="159,112,308,136"/>
<area href="class_test_class_net_mode_tcp.html" alt="TestClassNetModeTcp" shape="rect" coords="318,112,467,136"/>
<area href="class_net_mode_udp_catch_all.html" alt="NetModeUdpCatchAll" shape="rect" coords="477,112,626,136"/>
<area href="class_net_mode_udp_per_client.html" alt="NetModeUdpPerClient" shape="rect" coords="636,112,785,136"/>
<area href="class_net_mode_udp_catch_all_no.html" alt="NetModeUdpCatchAllNo" shape="rect" coords="477,168,626,192"/>
</map>
</div>

<p><a href="class_net_mode-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a> { <br/>
&nbsp;&nbsp;<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a5fc5653d3c2a1e1b5a4306e7060b41c9">TCP_PREFIX_SIZE</a> =  1, 
<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">TCP_POSTFIX</a> =  2, 
<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45">UDP_PER_CLIENT</a> =  1, 
<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">UDP_PER_CLIENT_PER_OPERATION</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a158ce5f833cde150d209f480936b2b0a">UDP_CATCH_ALL</a> =  3, 
<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964ad4582c7d9e25f9fbd2cec99e4455386f">UDP_CATCH_ALL_NO</a> =  4
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Describes the protocol mode in use. </p>
 <a href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_send.html">NetSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a2a44f68cb6dccbeff90cabbdede0b54e">GetSendObject</a> (const <a class="el" href="class_packet.html">Packet</a> *packet, bool block)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a <a class="el" href="class_net_send.html" title="Base class for sendable objects which can be used in conjunction with winsock WSASend.">NetSend</a> object based on protocol mode specific criteria.  <a href="#a2a44f68cb6dccbeff90cabbdede0b54e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a955c73991a8f13465e509f3841071455">GetProtocolMode</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the protocol mode in use.  <a href="#a955c73991a8f13465e509f3841071455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a5e5d20657ffc037022adc4b81fe2df6d">GetPacketAmount</a> (size_t clientID, size_t operationID) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the number of packets in the specified packet store.  <a href="#a5e5d20657ffc037022adc4b81fe2df6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a7231dcd15fc1896f61d7ac80c3e9b4ba">GetPacketFromStore</a> (<a class="el" href="class_packet.html">Packet</a> *destination, size_t clientID, size_t operationID)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a packet from the specified packet store.  <a href="#a7231dcd15fc1896f61d7ac80c3e9b4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a6dfa7ab2954246efda52867ef345a6bb">PacketDone</a> (<a class="el" href="class_packet.html">Packet</a> *completePacket, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> udpRecvFunc)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with a complete packet.  <a href="#a6dfa7ab2954246efda52867ef345a6bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a075020ac61bedee59eb7b0dcb6754847">DealWithData</a> (const WSABUF &amp;buffer, size_t completionBytes, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc, size_t clientID, size_t instanceID)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with newly received data.  <a href="#a075020ac61bedee59eb7b0dcb6754847"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a825e005771020dac6f89367f04c0b792">ConvertToProtocolModeTCP</a> (int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts integer into enum for ProtocolMode.  <a href="#a825e005771020dac6f89367f04c0b792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#ac2c76177611b178f10d0ba777f026038">ConvertToProtocolModeUDP</a> (int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts integer into enum for ProtocolMode.  <a href="#ac2c76177611b178f10d0ba777f026038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#ac5373607d50d5601c3dd214e22641d25">ValidateProtocolModeTCP</a> (<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the specified protocol mode is TCP based.  <a href="#ac5373607d50d5601c3dd214e22641d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#a5ec4cf1b0571a74ed746d8d8fbabe986">ValidateProtocolModeUDP</a> (<a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the specified protocol mode is UDP based.  <a href="#a5ec4cf1b0571a74ed746d8d8fbabe986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode.html#af062e2de6fe5afa57061632715a5c0ad">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#af062e2de6fe5afa57061632715a5c0ad"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for net modes such as <a class="el" href="class_net_mode_udp.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">NetModeUdp</a> and <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>Makes up the skeleton of a net mode, providing virtual methods that are common to all modes. <a class="el" href="class_net_mode.html" title="Base class for net modes such as NetModeUdp and NetModeTcp.">NetMode</a> objects describe modifications made to data when sent and received, and how they are transferred to the application. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964"></a><!-- doxytag: member="NetMode::ProtocolMode" ref="a43cfa55ee6a4db66a8d7d6c27f766964" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes the protocol mode in use. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964a5fc5653d3c2a1e1b5a4306e7060b41c9"></a><!-- doxytag: member="TCP_PREFIX_SIZE" ref="a43cfa55ee6a4db66a8d7d6c27f766964a5fc5653d3c2a1e1b5a4306e7060b41c9" args="" -->TCP_PREFIX_SIZE</em>&nbsp;</td><td>
<p>A prefix of type size_t is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix indicates the amount of additional data (not including the prefix) that is in the packet. The prefix is not included as part of received packets. e.g. If the prefix of size_t is of value 10, then the actual packet's size is 10 + 8 which is 18. <br/>
<br/>
</p>
<p>Packets received are put into a queue and none are discarded.<br/>
<br/>
</p>
<p>Value of 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4"></a><!-- doxytag: member="TCP_POSTFIX" ref="a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4" args="" -->TCP_POSTFIX</em>&nbsp;</td><td>
<p>A postfix which can consist of any data is automatically appended to the end of all packets being sent. Packets being received are expected to have this postfix and problems will occur if they don't. The postfix indicates the end of the packet and is not included as part of received packets.<br/>
<br/>
</p>
<p>Packets received are put into a queue and none are discarded.<br/>
<br/>
</p>
<p>Value of 2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45"></a><!-- doxytag: member="UDP_PER_CLIENT" ref="a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45" args="" -->UDP_PER_CLIENT</em>&nbsp;</td><td>
<p>A prefix of clock() is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is used to determine the age of the packet. clock() increments every millisecond and therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>In addition to this, the server (and only the server) must manually add the following prefix to the start of each packet:</p>
<ul>
<li>size_t: Indicates the client that the packet is referring to. On the receiving end, the packet will then appear in that client's packet store without this prefix.<br/>
<br/>
</li>
</ul>
<p>On the client and server side there is a packet store for each client which stores the newest packet received from that client (in the case of server state) or referring to that client (in the case of client state). Each store contains only one packet, reducing the overhead of a queue.<br/>
<br/>
</p>
<p>This UDP mode is good where data can be organized into a per client basis and can be more efficient than. UDP_CATCH_ALL or UDP_CATCH_ALL_NO due to there being no queue. Note that some in order packets may be discarded since there is no queue.<br/>
<br/>
</p>
<p>Value of 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27"></a><!-- doxytag: member="UDP_PER_CLIENT_PER_OPERATION" ref="a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27" args="" -->UDP_PER_CLIENT_PER_OPERATION</em>&nbsp;</td><td>
<p>A prefix of clock() is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is used to determine the age of the packet. clock() increments every millisecond and therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>In addition to this, the server (and only the server) must manually add the following prefix to the start of each packet in the below order:</p>
<ul>
<li>size_t: Client ID indicating the client that the packet is referring to. On the receiving end, the packet will then appear in that client's packet store without this part of the prefix.</li>
<li>size_t: Operation ID indicating the operation that the packet applies to. On the receiving end, the packet will then appear in the packet store for that operation without this part of the prefix.<br/>
<br/>
</li>
</ul>
<p>The client (and only the client) must manually add the following prefix to the start of each packet in the below order:</p>
<ul>
<li>size_t: Operation ID indicating the operation that the packet applies to. On the receiving end, the packet will then appear in the packet store for that operation without this prefix.<br/>
<br/>
</li>
</ul>
<p>On the client and server side there is a packet store for each client and each operation which stores the newest packet received from that client for that operation (in the case of server state) or referring to that client for that operation (in the case of client state). Each store contains only one packet, reducing the overhead of a queue. The packet store can be thought of as a 2D array which looks like: packetStore[maxClients][numOperations].<br/>
<br/>
</p>
<p>This UDP mode is good where data can be organized into a per client, per operation basis and can be more efficient than. UDP_CATCH_ALL or UDP_CATCH_ALL_NO due to there being no queue. Note that some in order packets may be discarded since there is no queue.<br/>
<br/>
</p>
<p>Value of 2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964a158ce5f833cde150d209f480936b2b0a"></a><!-- doxytag: member="UDP_CATCH_ALL" ref="a43cfa55ee6a4db66a8d7d6c27f766964a158ce5f833cde150d209f480936b2b0a" args="" -->UDP_CATCH_ALL</em>&nbsp;</td><td>
<p>The packet is sent unmodified and packets received are transfered straight to the application. This is unmodified UDP transfer and so out of order packets may be received. In addition this connection packets may be received in server state, as the client blasts UDP packets to the server which may arrive late, after the connection has completed. These packets always have a prefix of size_t of value 0. You can use this to single them out and discard them. For more information see the <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Value of 3. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a43cfa55ee6a4db66a8d7d6c27f766964ad4582c7d9e25f9fbd2cec99e4455386f"></a><!-- doxytag: member="UDP_CATCH_ALL_NO" ref="a43cfa55ee6a4db66a8d7d6c27f766964ad4582c7d9e25f9fbd2cec99e4455386f" args="" -->UDP_CATCH_ALL_NO</em>&nbsp;</td><td>
<p>A prefix of size_t is added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is a counter which increments by 1 with every send operation. Therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>Received packets are put into a queue and no in order packets are discarded.<br/>
<br/>
</p>
<p>Value of 4. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a825e005771020dac6f89367f04c0b792"></a><!-- doxytag: member="NetMode::ConvertToProtocolModeTCP" ref="a825e005771020dac6f89367f04c0b792" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetMode::ConvertToProtocolModeTCP </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts integer into enum for ProtocolMode. </p>
<p>This is useful for compatibility with languages other than C++.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Integer to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum equivalent of <em>mode</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2c76177611b178f10d0ba777f026038"></a><!-- doxytag: member="NetMode::ConvertToProtocolModeUDP" ref="ac2c76177611b178f10d0ba777f026038" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetMode::ConvertToProtocolModeUDP </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts integer into enum for ProtocolMode. </p>
<p>This is useful for compatibility with languages other than C++.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Integer to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum equivalent of <em>mode</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a075020ac61bedee59eb7b0dcb6754847"></a><!-- doxytag: member="NetMode::DealWithData" ref="a075020ac61bedee59eb7b0dcb6754847" args="(const WSABUF &amp;buffer, size_t completionBytes, NetSocket::RecvFunc recvFunc, size_t clientID, size_t instanceID)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void NetMode::DealWithData </td>
          <td>(</td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with newly received data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Newly received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>Number of bytes of new data stored in <em>buffer</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance that data was received on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that data was received from, set to 0 if not applicable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_test_class_net_mode_tcp.html#aaf6e498b154805343b3206f7b4f61edf">TestClassNetModeTcp</a>, <a class="el" href="class_net_mode_tcp_postfix.html#a3e350f1ef706f2dbc7dabae0491b3797">NetModeTcpPostfix</a>, <a class="el" href="class_net_mode_tcp_prefix_size.html#ae3b7be4877c44df177bc771ea5cae4df">NetModeTcpPrefixSize</a>, <a class="el" href="class_net_mode_udp_catch_all.html#adc52011adf841020e996d6c50f6fb7c1">NetModeUdpCatchAll</a>, <a class="el" href="class_net_mode_udp_catch_all_no.html#a9a7e511a9c813ae4889ee4afa1e840ba">NetModeUdpCatchAllNo</a>, and <a class="el" href="class_net_mode_udp_per_client.html#a0d7d2c68e11b088b743069d3848a13f0">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5d20657ffc037022adc4b81fe2df6d"></a><!-- doxytag: member="NetMode::GetPacketAmount" ref="a5e5d20657ffc037022adc4b81fe2df6d" args="(size_t clientID, size_t operationID) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t NetMode::GetPacketAmount </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the number of packets in the specified packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use, may be ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>Operation ID of operation to use, may be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in the packet store. </dd></dl>

<p>Implemented in <a class="el" href="class_net_mode_tcp.html#ac2aaad8fa89939a1204e5f0a5ef9522f">NetModeTcp</a>, <a class="el" href="class_net_mode_udp_catch_all.html#a56defc6f6d09211a49cc5c110cfb3fcf">NetModeUdpCatchAll</a>, and <a class="el" href="class_net_mode_udp_per_client.html#ac4e6ad2bcfa272cabb43a13d7baef626">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="a7231dcd15fc1896f61d7ac80c3e9b4ba"></a><!-- doxytag: member="NetMode::GetPacketFromStore" ref="a7231dcd15fc1896f61d7ac80c3e9b4ba" args="(Packet *destination, size_t clientID, size_t operationID)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t NetMode::GetPacketFromStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a packet from the specified packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination to copy packet into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use, may be ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to use, may be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in packet queue before this method was called. </dd></dl>

<p>Implemented in <a class="el" href="class_net_mode_tcp.html#aa9ac5206e18d0c824daffccccfbc9f61">NetModeTcp</a>, <a class="el" href="class_net_mode_udp_catch_all.html#a79fa50275b49fed4af9cce8756a81394">NetModeUdpCatchAll</a>, and <a class="el" href="class_net_mode_udp_per_client.html#a37e093c98724f8a8e652360664a6c9e4">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="a955c73991a8f13465e509f3841071455"></a><!-- doxytag: member="NetMode::GetProtocolMode" ref="a955c73991a8f13465e509f3841071455" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a> NetMode::GetProtocolMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the protocol mode in use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the protocol mode in use, describing how data is manipulated during sending and receiving. </dd></dl>

<p>Implemented in <a class="el" href="class_test_class_net_mode_tcp.html#ad51dc21b38ba3446a76929ab35233076">TestClassNetModeTcp</a>, <a class="el" href="class_net_mode_tcp_postfix.html#aa0c16b044df85608508a33a8b224f16c">NetModeTcpPostfix</a>, <a class="el" href="class_net_mode_tcp_prefix_size.html#a632cf5d27fd0c77f3f9db74c2b4e2415">NetModeTcpPrefixSize</a>, <a class="el" href="class_net_mode_udp_catch_all.html#a84cd8b30de444fa8dbd699fdae416a84">NetModeUdpCatchAll</a>, <a class="el" href="class_net_mode_udp_catch_all_no.html#a29a144e8ac3263b8ea2d8efb3ca6d657">NetModeUdpCatchAllNo</a>, and <a class="el" href="class_net_mode_udp_per_client.html#ad179a96106a20668f1dd1fe5c37e5034">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="a2a44f68cb6dccbeff90cabbdede0b54e"></a><!-- doxytag: member="NetMode::GetSendObject" ref="a2a44f68cb6dccbeff90cabbdede0b54e" args="(const Packet *packet, bool block)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_send.html">NetSend</a>* NetMode::GetSendObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a <a class="el" href="class_net_send.html" title="Base class for sendable objects which can be used in conjunction with winsock WSASend.">NetSend</a> object based on protocol mode specific criteria. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>True if sending should be synchronous, false if sending should be asynchronous.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a send object formatted for the specific protocol and mode. </dd></dl>

<p>Implemented in <a class="el" href="class_test_class_net_mode_tcp.html#af8de69cfdd1b8ff8f88857b5f43c035a">TestClassNetModeTcp</a>, <a class="el" href="class_net_mode_tcp_postfix.html#af283745349e833f6c053203036c99c7d">NetModeTcpPostfix</a>, <a class="el" href="class_net_mode_tcp_prefix_size.html#ab1c734f295e365dce076f68a162d169a">NetModeTcpPrefixSize</a>, <a class="el" href="class_net_mode_udp_catch_all.html#a31fc998bff9b19d93f7437ae7f03d7ef">NetModeUdpCatchAll</a>, <a class="el" href="class_net_mode_udp_catch_all_no.html#a32447c9f1e407a509e3b0179f50fab5c">NetModeUdpCatchAllNo</a>, and <a class="el" href="class_net_mode_udp_per_client.html#a6a6a8cd7ebf9d72760b2f328a64e5a0e">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="a6dfa7ab2954246efda52867ef345a6bb"></a><!-- doxytag: member="NetMode::PacketDone" ref="a6dfa7ab2954246efda52867ef345a6bb" args="(Packet *completePacket, NetSocket::RecvFunc udpRecvFunc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void NetMode::PacketDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>completePacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>udpRecvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with a complete packet. </p>
<p>The class deals with it in one of two ways:</p>
<ul>
<li>Passes it to a user function specified by <em>udpRecvFunc</em> parameter.</li>
<li>If no user function is defined then it is dealt with by the object.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completePacket</em>&nbsp;</td><td>The complete packet that should be dealt with. The packet is now owned by this object and should not be referenced elsewhere. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpRecvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_net_mode_tcp.html#ae031c101bb0bc3c974879ab41e034ebd">NetModeTcp</a>, <a class="el" href="class_net_mode_udp_catch_all.html#acfc10ca9c1b4204fdbb021bf755e4e55">NetModeUdpCatchAll</a>, and <a class="el" href="class_net_mode_udp_per_client.html#a1c3fb35fb139bb8aeeedb79db890fa28">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="af062e2de6fe5afa57061632715a5c0ad"></a><!-- doxytag: member="NetMode::TestClass" ref="af062e2de6fe5afa57061632715a5c0ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetMode::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

<p>Reimplemented in <a class="el" href="class_net_mode_tcp.html#ad3f11796c2db6af88ff4fc3f4e820323">NetModeTcp</a>, <a class="el" href="class_net_mode_tcp_postfix.html#a53d84feec3968804317e581529f192c6">NetModeTcpPostfix</a>, <a class="el" href="class_net_mode_tcp_prefix_size.html#a9fc90706e6690880307714fbc917108f">NetModeTcpPrefixSize</a>, <a class="el" href="class_net_mode_udp.html#a2d4e3b8aede50899cb756392c48a8bcd">NetModeUdp</a>, <a class="el" href="class_net_mode_udp_catch_all.html#abf7feda18651d7fc4638da1a75841ad9">NetModeUdpCatchAll</a>, <a class="el" href="class_net_mode_udp_catch_all_no.html#a479484b12ab0700640a8caaefb13f33f">NetModeUdpCatchAllNo</a>, and <a class="el" href="class_net_mode_udp_per_client.html#a490edbb5bd9886e5a308e8d7333c7b54">NetModeUdpPerClient</a>.</p>

</div>
</div>
<a class="anchor" id="ac5373607d50d5601c3dd214e22641d25"></a><!-- doxytag: member="NetMode::ValidateProtocolModeTCP" ref="ac5373607d50d5601c3dd214e22641d25" args="(ProtocolMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetMode::ValidateProtocolModeTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the specified protocol mode is TCP based. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Protocol mode to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if protocol mode is a valid TCP mode, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec4cf1b0571a74ed746d8d8fbabe986"></a><!-- doxytag: member="NetMode::ValidateProtocolModeUDP" ref="a5ec4cf1b0571a74ed746d8d8fbabe986" args="(ProtocolMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetMode::ValidateProtocolModeUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the specified protocol mode is UDP based. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Protocol mode to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if protocol mode is a valid UDP mode, false if not. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_mode_8h_source.html">NetMode.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetMode.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:20 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
