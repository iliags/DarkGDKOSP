<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetModeUdpPerClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetModeUdpPerClient Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetModeUdpPerClient" --><!-- doxytag: inherits="NetModeUdp" -->
<p>UDP mode where only in order packets are received, some in order packets may be discarded however.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_mode_udp_per_client_8h_source.html">NetModeUdpPerClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetModeUdpPerClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_mode_udp_per_client.png" usemap="#NetModeUdpPerClient_map" alt=""/>
  <map id="NetModeUdpPerClient_map" name="NetModeUdpPerClient_map">
<area href="class_net_mode_udp.html" alt="NetModeUdp" shape="rect" coords="0,56,137,80"/>
<area href="class_net_mode.html" alt="NetMode" shape="rect" coords="0,0,137,24"/>
</map>
</div>

<p><a href="class_net_mode_udp_per_client-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#aa3313f3ac3e65b4807d0ebe122ac3b40">NetModeUdpPerClient</a> (size_t recvSize, size_t numClients, size_t numOperations, bool <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7">perOperation</a>, const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *<a class="el" href="class_net_mode_udp_per_client.html#a6526b99fd75abe001e6e92e1e8bcd1e3">decryptKey</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#aa3313f3ac3e65b4807d0ebe122ac3b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2002c87f02fb59e232dea6889cb06308"></a><!-- doxytag: member="NetModeUdpPerClient::~NetModeUdpPerClient" ref="a2002c87f02fb59e232dea6889cb06308" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a2002c87f02fb59e232dea6889cb06308">~NetModeUdpPerClient</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#ad2a548a659865d79e946c38b1a32c6f9">NetModeUdpPerClient</a> (const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy constructor.  <a href="#ad2a548a659865d79e946c38b1a32c6f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a5597847c3bea6af583c3b72eaa722cc8">operator=</a> (const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep assignment operator.  <a href="#a5597847c3bea6af583c3b72eaa722cc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a41f1ee8314171e36a91e17d9e24420ae">Clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a deep copy of this object.  <a href="#a41f1ee8314171e36a91e17d9e24420ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#aa036644d4e71e779032f6cef6959f826">Reset</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets data of specified client.  <a href="#aa036644d4e71e779032f6cef6959f826"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a503ba4e03ba1766070561a27fd59c628"></a><!-- doxytag: member="NetModeUdpPerClient::Reset" ref="a503ba4e03ba1766070561a27fd59c628" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a503ba4e03ba1766070561a27fd59c628">Reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset data of all clients. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a0d7d2c68e11b088b743069d3848a13f0">DealWithData</a> (const WSABUF &amp;buffer, size_t completionBytes, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> udpRecvFunc, size_t clientID, size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with newly received data.  <a href="#a0d7d2c68e11b088b743069d3848a13f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#ac4e6ad2bcfa272cabb43a13d7baef626">GetPacketAmount</a> (size_t clientID, size_t operationID) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the number of packets in the specified packet store.  <a href="#ac4e6ad2bcfa272cabb43a13d7baef626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a37e093c98724f8a8e652360664a6c9e4">GetPacketFromStore</a> (<a class="el" href="class_packet.html">Packet</a> *destination, size_t clientID, size_t operationID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a packet from the specified packet store.  <a href="#a37e093c98724f8a8e652360664a6c9e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">clock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a73732a27744817cdccebfef4d7b53aa7">GetRecvCounter</a> (size_t clientID, size_t operationID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the clock() value for the currently stored packet for the specified client and operation.  <a href="#a73732a27744817cdccebfef4d7b53aa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a6f4bc37fafcb1affa58c4b9820189d81">SetRecvCounter</a> (size_t clientID, size_t operationID, clock_t newCounter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manually changes the stored counter value for the specified client and operation.  <a href="#a6f4bc37fafcb1affa58c4b9820189d81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_send.html">NetSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a6a6a8cd7ebf9d72760b2f328a64e5a0e">GetSendObject</a> (const <a class="el" href="class_packet.html">Packet</a> *packet, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a <a class="el" href="class_net_send.html" title="Base class for sendable objects which can be used in conjunction with winsock WSASend.">NetSend</a> object.  <a href="#a6a6a8cd7ebf9d72760b2f328a64e5a0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#ad179a96106a20668f1dd1fe5c37e5034">GetProtocolMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the protocol mode in use.  <a href="#ad179a96106a20668f1dd1fe5c37e5034"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a4756d963af49213282ebfe90c63cd1ba">GetNumOperations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of operations that this object can manage.  <a href="#a4756d963af49213282ebfe90c63cd1ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a7c53b77684eb18b997182f7c8c861b8f">GetNumClients</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of clients that this object can manage.  <a href="#a7c53b77684eb18b997182f7c8c861b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a1c3fb35fb139bb8aeeedb79db890fa28">PacketDone</a> (<a class="el" href="class_packet.html">Packet</a> *completePacket, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> udpRecvFunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with a complete packet.  <a href="#a1c3fb35fb139bb8aeeedb79db890fa28"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a490edbb5bd9886e5a308e8d7333c7b54">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#a490edbb5bd9886e5a308e8d7333c7b54"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#aba1429095bd80cb401f15c9400b119bd">Copy</a> (const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;copyMe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor / assignment operator helper method.  <a href="#aba1429095bd80cb401f15c9400b119bd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4ba9cc15c6cf4fe6bd00bd3396a8251"></a><!-- doxytag: member="NetModeUdpPerClient::packetStore" ref="ae4ba9cc15c6cf4fe6bd00bd3396a8251" args="" -->
<a class="el" href="class_store_vector.html">StoreVector</a>&lt; <a class="el" href="class_store_vector.html">StoreVector</a><br class="typebreak"/>
&lt; <a class="el" href="class_packet.html">Packet</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#ae4ba9cc15c6cf4fe6bd00bd3396a8251">packetStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D vector that stores received packets by client and operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08a0bc34d06354add6d22f504ccfdaf7"></a><!-- doxytag: member="NetModeUdpPerClient::perOperation" ref="a08a0bc34d06354add6d22f504ccfdaf7" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7">perOperation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if object is used in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> UDP mode, false if object is used in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45">NetMode::UDP_PER_CLIENT</a> UDP mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6526b99fd75abe001e6e92e1e8bcd1e3"></a><!-- doxytag: member="NetModeUdpPerClient::decryptKey" ref="a6526b99fd75abe001e6e92e1e8bcd1e3" args="" -->
const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_mode_udp_per_client.html#a6526b99fd75abe001e6e92e1e8bcd1e3">decryptKey</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to decryption key used to decrypt incoming packets before reading them. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>UDP mode where only in order packets are received, some in order packets may be discarded however. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>A prefix of clock() is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is used to determine the age of the packet. clock() increments every millisecond and therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order.<br/>
<br/>
</p>
<p>The prefix is not included as part of received packets that are passed to the user; the prefix is dealt with behind the scenes.<br/>
<br/>
</p>
<p>In addition to this, the server (and only the server) must manually add the following prefix to the start of each packet:</p>
<ul>
<li>size_t: Indicates the client that the packet is referring to. On the receiving end, the packet will then appear in that client's packet store without this prefix.<br/>
<br/>
</li>
</ul>
<p>If perOperation is set to true in the constructor, then on both the server and client side an additional prefix should be added (after the client prefix):</p>
<ul>
<li>size_t: Indicates the operation that the packet is referring to. On the receiving end, the packet will then appear in that operation IDs store without this prefix.<br/>
<br/>
</li>
</ul>
<p>For details on how to implement this system in a custom instance see <a class="el" href="class_net_mode_udp_per_client.html#a0d7d2c68e11b088b743069d3848a13f0" title="Deals with newly received data.">DealWithData()</a>.<br/>
<br/>
</p>
<p>On the client and server side there is a packet store for each client which stores the newest packet received from that client (in the case of server state) or referring to that client (in the case of client state). Each store contains only one packet, reducing the overhead of a queue.<br/>
<br/>
</p>
<p>This UDP mode is good where data can be organized into a per client basis and can be more efficient than <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a158ce5f833cde150d209f480936b2b0a">NetMode::UDP_CATCH_ALL</a> and <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964ad4582c7d9e25f9fbd2cec99e4455386f">NetMode::UDP_CATCH_ALL_NO</a> due to there being no queue. Note that some in order packets may be discarded since there is no queue.<br/>
<br/>
</p>
<p>This class is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa3313f3ac3e65b4807d0ebe122ac3b40"></a><!-- doxytag: member="NetModeUdpPerClient::NetModeUdpPerClient" ref="aa3313f3ac3e65b4807d0ebe122ac3b40" args="(size_t recvSize, size_t numClients, size_t numOperations, bool perOperation, const EncryptKey *decryptKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetModeUdpPerClient::NetModeUdpPerClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numOperations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_encrypt_key.html">EncryptKey</a> *&nbsp;</td>
          <td class="paramname"> <em>decryptKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>recvSize</em>&nbsp;</td><td>Maximum size of UDP packet that can be received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numClients</em>&nbsp;</td><td>Number of clients that object needs to store received packets for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numOperations</em>&nbsp;</td><td>Number of operations per client that object needs to store received packets for, ignored if <em>perOperation</em> is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perOperation</em>&nbsp;</td><td>If true operation ID will be extracted from packet and object is used in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> UDP mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decryptKey</em>&nbsp;</td><td>Ignored if NULL, otherwise represents memory address of <a class="el" href="class_encrypt_key.html" title="Encryption key which is used in conjunction with the Packet class to encrypt and decrypt packets...">EncryptKey</a> object used to decrypt incoming packets before reading them. Contents of <em>decryptKey</em> is copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2a548a659865d79e946c38b1a32c6f9"></a><!-- doxytag: member="NetModeUdpPerClient::NetModeUdpPerClient" ref="ad2a548a659865d79e946c38b1a32c6f9" args="(const NetModeUdpPerClient &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetModeUdpPerClient::NetModeUdpPerClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a41f1ee8314171e36a91e17d9e24420ae"></a><!-- doxytag: member="NetModeUdpPerClient::Clone" ref="a41f1ee8314171e36a91e17d9e24420ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> * NetModeUdpPerClient::Clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a deep copy of this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a deep copy of this object. </dd></dl>

<p>Implements <a class="el" href="class_net_mode_udp.html#ae0160135a69173309701952b9bdf7488">NetModeUdp</a>.</p>

</div>
</div>
<a class="anchor" id="aba1429095bd80cb401f15c9400b119bd"></a><!-- doxytag: member="NetModeUdpPerClient::Copy" ref="aba1429095bd80cb401f15c9400b119bd" args="(const NetModeUdpPerClient &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetModeUdpPerClient::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor / assignment operator helper method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy into this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d7d2c68e11b088b743069d3848a13f0"></a><!-- doxytag: member="NetModeUdpPerClient::DealWithData" ref="a0d7d2c68e11b088b743069d3848a13f0" args="(const WSABUF &amp;buffer, size_t completionBytes, NetSocket::RecvFunc udpRecvFunc, size_t clientID, size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetModeUdpPerClient::DealWithData </td>
          <td>(</td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>udpRecvFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with newly received data. </p>
<p>If <em>clientID</em> is 0 then an integer of size_t type will be extracted from the data and that will be used to determine what client ID this packet refers to.<br/>
<br/>
</p>
<p>Afterwards, if 'per operation' is enabled then a further integer of size_t type will be extracted and its data will indicate the operation ID that the packet refers to.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Newly received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>Number of bytes of new data stored in <em>buffer</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpRecvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance that data was received on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that data was received from, set to 0 if not applicable. If 0 then the client ID will be extracted from the packet directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_mode.html#a075020ac61bedee59eb7b0dcb6754847">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="a7c53b77684eb18b997182f7c8c861b8f"></a><!-- doxytag: member="NetModeUdpPerClient::GetNumClients" ref="a7c53b77684eb18b997182f7c8c861b8f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetModeUdpPerClient::GetNumClients </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of clients that this object can manage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of clients that this object can manage. </dd></dl>

<p>Implements <a class="el" href="class_net_mode_udp.html#a2ec3aa4ddf8d531d1754f8be2a1d87ba">NetModeUdp</a>.</p>

</div>
</div>
<a class="anchor" id="a4756d963af49213282ebfe90c63cd1ba"></a><!-- doxytag: member="NetModeUdpPerClient::GetNumOperations" ref="a4756d963af49213282ebfe90c63cd1ba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetModeUdpPerClient::GetNumOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of operations that this object can manage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is true then the number of operations that this object can manage. </dd>
<dd>
if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is false then 1. </dd></dl>

<p>Implements <a class="el" href="class_net_mode_udp.html#a36a62c7bf9df7c7d7f2a3ad5cfb79b42">NetModeUdp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e6ad2bcfa272cabb43a13d7baef626"></a><!-- doxytag: member="NetModeUdpPerClient::GetPacketAmount" ref="ac4e6ad2bcfa272cabb43a13d7baef626" args="(size_t clientID, size_t operationID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetModeUdpPerClient::GetPacketAmount </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the number of packets in the specified packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>Ignored (optional, default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if a newly received packet exists in the packet queue. </dd>
<dd>
0 if no new packet exists. </dd></dl>

<p>Implements <a class="el" href="class_net_mode.html#a5e5d20657ffc037022adc4b81fe2df6d">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="a37e093c98724f8a8e652360664a6c9e4"></a><!-- doxytag: member="NetModeUdpPerClient::GetPacketFromStore" ref="a37e093c98724f8a8e652360664a6c9e4" args="(Packet *destination, size_t clientID, size_t operationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetModeUdpPerClient::GetPacketFromStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a packet from the specified packet store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination to copy packet into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to use, may be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 because there will always be only one packet in the store. </dd></dl>

<p>Implements <a class="el" href="class_net_mode.html#a7231dcd15fc1896f61d7ac80c3e9b4ba">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="ad179a96106a20668f1dd1fe5c37e5034"></a><!-- doxytag: member="NetModeUdpPerClient::GetProtocolMode" ref="ad179a96106a20668f1dd1fe5c37e5034" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> NetModeUdpPerClient::GetProtocolMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the protocol mode in use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is true then <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a>. </dd>
<dd>
if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is false then <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45">NetMode::UDP_PER_CLIENT</a>. </dd></dl>

<p>Implements <a class="el" href="class_net_mode.html#a955c73991a8f13465e509f3841071455">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="a73732a27744817cdccebfef4d7b53aa7"></a><!-- doxytag: member="NetModeUdpPerClient::GetRecvCounter" ref="a73732a27744817cdccebfef4d7b53aa7" args="(size_t clientID, size_t operationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_t NetModeUdpPerClient::GetRecvCounter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the clock() value for the currently stored packet for the specified client and operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>Operation ID of operation to use, ignored if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>age of specified packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a6a8cd7ebf9d72760b2f328a64e5a0e"></a><!-- doxytag: member="NetModeUdpPerClient::GetSendObject" ref="a6a6a8cd7ebf9d72760b2f328a64e5a0e" args="(const Packet *packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_send.html">NetSend</a> * NetModeUdpPerClient::GetSendObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a <a class="el" href="class_net_send.html" title="Base class for sendable objects which can be used in conjunction with winsock WSASend.">NetSend</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>True if sending should be synchronous, false if sending should be asynchronous.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a send object. </dd></dl>

<p>Implements <a class="el" href="class_net_mode.html#a2a44f68cb6dccbeff90cabbdede0b54e">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="a5597847c3bea6af583c3b72eaa722cc8"></a><!-- doxytag: member="NetModeUdpPerClient::operator=" ref="a5597847c3bea6af583c3b72eaa722cc8" args="(const NetModeUdpPerClient &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp; NetModeUdpPerClient::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_mode_udp_per_client.html">NetModeUdpPerClient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c3fb35fb139bb8aeeedb79db890fa28"></a><!-- doxytag: member="NetModeUdpPerClient::PacketDone" ref="a1c3fb35fb139bb8aeeedb79db890fa28" args="(Packet *completePacket, NetSocket::RecvFunc udpRecvFunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetModeUdpPerClient::PacketDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>completePacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>udpRecvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with a complete packet. </p>
<p>The class deals with it in one of two ways:</p>
<ul>
<li>Passes it to a user function specified by <em>udpRecvFunc</em> parameter.</li>
<li>If no user function is defined then it is put into a queue to be retrieved using <a class="el" href="class_net_mode_udp_per_client.html#a37e093c98724f8a8e652360664a6c9e4" title="Retrieves a packet from the specified packet store.">GetPacketFromStore()</a>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is not called by <a class="el" href="class_net_mode_udp_per_client.html#a0d7d2c68e11b088b743069d3848a13f0" title="Deals with newly received data.">DealWithData()</a> but is included for completion.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If the packet is passed to a user function this is done synchronously, so this method will not return until the user function returns.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completePacket</em>&nbsp;</td><td>The complete packet that should be dealt with. The packet is now owned by this object and should not be referenced elsewhere. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpRecvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_mode.html#a6dfa7ab2954246efda52867ef345a6bb">NetMode</a>.</p>

</div>
</div>
<a class="anchor" id="aa036644d4e71e779032f6cef6959f826"></a><!-- doxytag: member="NetModeUdpPerClient::Reset" ref="aa036644d4e71e779032f6cef6959f826" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetModeUdpPerClient::Reset </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets data of specified client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_mode_udp.html#af5895c1120cdc8d0d04bd3e1bb34bdd7">NetModeUdp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f4bc37fafcb1affa58c4b9820189d81"></a><!-- doxytag: member="NetModeUdpPerClient::SetRecvCounter" ref="a6f4bc37fafcb1affa58c4b9820189d81" args="(size_t clientID, size_t operationID, clock_t newCounter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetModeUdpPerClient::SetRecvCounter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_t&nbsp;</td>
          <td class="paramname"> <em>newCounter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manually changes the stored counter value for the specified client and operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>Operation ID of operation to use, ignored if <a class="el" href="class_net_mode_udp_per_client.html#a08a0bc34d06354add6d22f504ccfdaf7" title="True if object is used in NetMode::UDP_PER_CLIENT_PER_OPERATION UDP mode, false if object is used in ...">NetModeUdpPerClient::perOperation</a> is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newCounter</em>&nbsp;</td><td>New counter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a490edbb5bd9886e5a308e8d7333c7b54"></a><!-- doxytag: member="NetModeUdpPerClient::TestClass" ref="a490edbb5bd9886e5a308e8d7333c7b54" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetModeUdpPerClient::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

<p>Reimplemented from <a class="el" href="class_net_mode_udp.html#a2d4e3b8aede50899cb756392c48a8bcd">NetModeUdp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_mode_udp_per_client_8h_source.html">NetModeUdpPerClient.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetModeUdpPerClient.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:21 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
