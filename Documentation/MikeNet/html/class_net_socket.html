<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetSocket" --><!-- doxytag: inherits="NetSocketSimple" -->
<p>Socket class providing more advanced functionality than <a class="el" href="class_net_socket_simple.html" title="Simple socket with basic functionality.">NetSocketSimple</a> that is common to all protocols.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_socket_8h_source.html">NetSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_socket.png" usemap="#NetSocket_map" alt=""/>
  <map id="NetSocket_map" name="NetSocket_map">
<area href="class_net_socket_simple.html" alt="NetSocketSimple" shape="rect" coords="116,0,222,24"/>
<area href="class_net_socket_t_c_p.html" alt="NetSocketTCP" shape="rect" coords="0,112,106,136"/>
<area href="class_net_socket_u_d_p.html" alt="NetSocketUDP" shape="rect" coords="116,112,222,136"/>
<area href="class_test_net_socket.html" alt="TestNetSocket" shape="rect" coords="232,112,338,136"/>
</map>
</div>

<p><a href="class_net_socket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52b5f4de8d0a47fd8620f542b21c076c"></a><!-- doxytag: member="NetSocket::RecvFunc" ref="a52b5f4de8d0a47fd8620f542b21c076c" args=")(Packet &amp;packet)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">RecvFunc</a> )(<a class="el" href="class_packet.html">Packet</a> &amp;packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Placeholder method supplied by external source (e.g. Application) that can be called by API. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a0f3c63a94517b043d5c1b8c070852c60">NetSocket</a> (size_t bufferLength, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">RecvFunc</a> receiveFunction)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a0f3c63a94517b043d5c1b8c070852c60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ab916dbb4c1afa5078068eaef73274c92">NetSocket</a> (size_t bufferLength, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">RecvFunc</a> receiveFunction, <a class="el" href="class_net_instance.html">NetInstance</a> *instance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ab916dbb4c1afa5078068eaef73274c92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ebe4e1d8db6978255f48e1034d638a4"></a><!-- doxytag: member="NetSocket::~NetSocket" ref="a3ebe4e1d8db6978255f48e1034d638a4" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a3ebe4e1d8db6978255f48e1034d638a4">~NetSocket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a505f592181260a75c7c5060021ac4201">NetSocket</a> (const <a class="el" href="class_net_socket.html">NetSocket</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy constructor.  <a href="#a505f592181260a75c7c5060021ac4201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html">NetSocket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a703ac13a72d73c598c81372946097210">operator=</a> (const <a class="el" href="class_net_socket.html">NetSocket</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep assignment operator.  <a href="#a703ac13a72d73c598c81372946097210"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900eb09b76f4098e67af95daf9e0b3b2"></a><!-- doxytag: member="NetSocket::DefaultVariables" ref="a900eb09b76f4098e67af95daf9e0b3b2" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a900eb09b76f4098e67af95daf9e0b3b2">DefaultVariables</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets variables to default. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aa5e8328367081d19e64a37e6b15703cf">SetInstance</a> (<a class="el" href="class_net_instance.html">NetInstance</a> *instance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the completion key instance field.  <a href="#aa5e8328367081d19e64a37e6b15703cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aafadb66f83b867d49633a304d1083cad">SetClientID</a> (size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the completion key client ID field.  <a href="#aafadb66f83b867d49633a304d1083cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aedd848a5bbf20f92dcd2f2d68603a16a">RemoveSend</a> (const OVERLAPPED *operation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleans up the send operation that is using the specified overlapped object.  <a href="#aedd848a5bbf20f92dcd2f2d68603a16a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ae6829ea0830059f1c21154a9c1392ed2">RemoveSend</a> (size_t element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleans up the send operation at the specified element.  <a href="#ae6829ea0830059f1c21154a9c1392ed2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a84eea723ebe08ab09554c56a07d5411a">AddSend</a> (<a class="el" href="class_net_send.html">NetSend</a> *send)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a send operation to the cleanup vector.  <a href="#a84eea723ebe08ab09554c56a07d5411a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea9f9a2581f8f07a22a0d36d3bb23654"></a><!-- doxytag: member="NetSocket::ClearSend" ref="aea9f9a2581f8f07a22a0d36d3bb23654" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aea9f9a2581f8f07a22a0d36d3bb23654">ClearSend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the send cleanup vector, cleaning up all send operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a0f18c5b9a572438bb51cd166ae85e573">FindSend</a> (const OVERLAPPED *operation, size_t &amp;position) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the send operation that is using the specified overlapped object in the send cleanup list.  <a href="#a0f18c5b9a572438bb51cd166ae85e573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a9dad9c9499a245c125ba90fc753592f4">IsSendEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the send cleanup vector is empty.  <a href="#a9dad9c9499a245c125ba90fc753592f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a85c6cba30c3a8d780bb24d7af8d0a561">Close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes socket.  <a href="#a85c6cba30c3a8d780bb24d7af8d0a561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aaba0fd1ddc4b4f52751ccb15146aba9a">AssociateCompletionPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ad085ef45c567752aae4457f7945b46aa">ClearRecv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears <a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96" title="Winsock overlapped operation used to identify when a receive operation has completed.">NetSocket::recvOverlapped</a> object ready for next receive.  <a href="#ad085ef45c567752aae4457f7945b46aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6ef9866517f7aad01a69b70467375d5"></a><!-- doxytag: member="NetSocket::Recv" ref="ad6ef9866517f7aad01a69b70467375d5" args="()=0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ad6ef9866517f7aad01a69b70467375d5">Recv</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a receive operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a808894184a1eed1a647e1cdf3c015f3a">Send</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, const <a class="el" href="class_net_address.html">NetAddress</a> *sendToAddr, unsigned int timeout)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet using this socket.  <a href="#a808894184a1eed1a647e1cdf3c015f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ae2524e6cffa4e30726fde6b4e703ebc3">GetRecvBufferLength</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the size of the receive buffer.  <a href="#ae2524e6cffa4e30726fde6b4e703ebc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a8d65090c23a7624c34bdff512261e74f">IsOurOverlapped</a> (const WSAOVERLAPPED *overlapped) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the specified overlapped object is the overlapped object used by this object to monitor the status of pending receive operations.  <a href="#a8d65090c23a7624c34bdff512261e74f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_socket_simple.html#a31450636f6fb9ece239c50f616e0d7b0">Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a2c62a6815ffb8b17aabd4963f63c1afc">GetProtocol</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the protocol type that the socket represents as an enum.  <a href="#a2c62a6815ffb8b17aabd4963f63c1afc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#afbb34329c03836f0a6962d7396752979">GetRecvFunction</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the function that is executed when complete packets are received.  <a href="#afbb34329c03836f0a6962d7396752979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a8eca2a547a5e1e613f782edc3fe8b910">IsRecvFunctionLoaded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a receive function has been loaded.  <a href="#a8eca2a547a5e1e613f782edc3fe8b910"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#afb09f225fda4d4b8f1108cb6c1e6b3d9">RemoveRecvFunction</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporarily disables the receive function.  <a href="#afb09f225fda4d4b8f1108cb6c1e6b3d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0da1e270db405a2a49cb66670fbb2fbd"></a><!-- doxytag: member="NetSocket::UndoRemoveRecvFunction" ref="a0da1e270db405a2a49cb66670fbb2fbd" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a0da1e270db405a2a49cb66670fbb2fbd">UndoRemoveRecvFunction</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets receive function as if RemoveRecvFunction had never been used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a99a69ab706122acc2bbe63c64b279b8e">DealWithData</a> (const WSABUF &amp;buffer, size_t completionBytes, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc, size_t clientID, size_t instanceID)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with newly received data using the socket's protocol object.  <a href="#a99a69ab706122acc2bbe63c64b279b8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a4c8e1cac6b9bde0ef6ce3c137a8563ad">CompletedSendOperation</a> (const WSAOVERLAPPED *overlapped, bool success, bool shuttingDown)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with completed send operation.  <a href="#a4c8e1cac6b9bde0ef6ce3c137a8563ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a419d22dbf82c32e89b2664a18f7a05af">GetCompletionPortCloseRequest</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the completion port has signaled this socket for closure.  <a href="#a419d22dbf82c32e89b2664a18f7a05af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ad04c291a00cc8b97425a60f6f8a20d3a">CompletionPortRequestClose</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that the socket should be closed by the main process.  <a href="#ad04c291a00cc8b97425a60f6f8a20d3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a389b4eb60158c997a932798a2de02e68">SetCompletionPortFinishRecvNotification</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that the receive operation that was last initiated has completed.  <a href="#a389b4eb60158c997a932798a2de02e68"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ae2233dd5a751f07101b1347df5dfc308">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#ae2233dd5a751f07101b1347df5dfc308"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_completion_key.html">CompletionKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a26693d766fabf449245ef0a1e2a5ff49">completionKey</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unique completion key used by completion port to identify this object.  <a href="#a26693d766fabf449245ef0a1e2a5ff49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WSAOVERLAPPED&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96">recvOverlapped</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Winsock overlapped operation used to identify when a receive operation has completed.  <a href="#ac260f690a6f192c22463d1f5ea903d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WSABUF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a0565a5dafc4df4589c0013d0c2816f33">recvBuffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Winsock buffer that is filled with newly received data.  <a href="#a0565a5dafc4df4589c0013d0c2816f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DWORD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a794267d0dd5ed57e8d9bfdfea01d2995">flags</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filled when TCP receive operation completes, is ignored but required by winsock.  <a href="#a794267d0dd5ed57e8d9bfdfea01d2995"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a41017899d90bb50e70345c5fcfbce577">SetRecvOverlappedEvent</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manually sets the overlapped event.  <a href="#a41017899d90bb50e70345c5fcfbce577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a35080a7efc36c4a4444dcf8a35213ccd">Send</a> (<a class="el" href="class_net_send.html">NetSend</a> &amp;sendObject, const <a class="el" href="class_net_address.html">NetAddress</a> *sendToAddr, unsigned int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a send object to the specified address.  <a href="#a35080a7efc36c4a4444dcf8a35213ccd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a03f60f949b31ee3feae0d1d3daa3bf3c">notDealingWithData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">False after a receive operation has been initiated, only true when the operation has finished AND all data has been dealt with.  <a href="#a03f60f949b31ee3feae0d1d3daa3bf3c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a8eeea3a43d5eeeb3a7a12cdcc8a5fc64">AllocateBuffer</a> (size_t bufferLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up <a class="el" href="class_net_socket.html#a0565a5dafc4df4589c0013d0c2816f33" title="Winsock buffer that is filled with newly received data.">NetSocket::recvBuffer</a>, allocating memory to it.  <a href="#a8eeea3a43d5eeeb3a7a12cdcc8a5fc64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a9d149d9ffbfe8d2240f664fd1923eb74">Initialize</a> (size_t bufferLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes objects.  <a href="#a9d149d9ffbfe8d2240f664fd1923eb74"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92fcd22d674b159c192f356728d2a575"></a><!-- doxytag: member="NetSocket::recvFunction" ref="a92fcd22d674b159c192f356728d2a575" args="" -->
<a class="el" href="class_concurrent_object.html">ConcurrentObject</a><br class="typebreak"/>
&lt; <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a92fcd22d674b159c192f356728d2a575">recvFunction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to be called every time a complete packet is received. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_concurrent_object.html">ConcurrentObject</a><br class="typebreak"/>
&lt; <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a7d4dd5d72c86d0ee4f46a3ec9e03bdfc">recvFunctionAux</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary store of <a class="el" href="class_net_socket.html#a92fcd22d674b159c192f356728d2a575" title="Function to be called every time a complete packet is received.">NetSocket::recvFunction</a>.  <a href="#a7d4dd5d72c86d0ee4f46a3ec9e03bdfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aeeae305cd0382ee87cf9c35aec571719">recvOverlappedEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event object associated with <a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96" title="Winsock overlapped operation used to identify when a receive operation has completed.">NetSocket::recvOverlapped</a>.  <a href="#aeeae305cd0382ee87cf9c35aec571719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#aeff1c796b40fa0545b6b3f2bb7767f4d">completionPortCloseNotification</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if completion port wants this socket to be closed by the main process.  <a href="#aeff1c796b40fa0545b6b3f2bb7767f4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_store_vector.html">StoreVector</a>&lt; <a class="el" href="class_net_send.html">NetSend</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket.html#a84e789c6d2552eef894f1f751539233f">sendCleanup</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This vector is filled with send operations that are in progress.  <a href="#a84e789c6d2552eef894f1f751539233f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Socket class providing more advanced functionality than <a class="el" href="class_net_socket_simple.html" title="Simple socket with basic functionality.">NetSocketSimple</a> that is common to all protocols. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This class provides functionality for interacting with the completion port and for sending data.<br/>
<br/>
</p>
<p>This class is not completely thread safe. Send cleanup is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f3c63a94517b043d5c1b8c070852c60"></a><!-- doxytag: member="NetSocket::NetSocket" ref="a0f3c63a94517b043d5c1b8c070852c60" args="(size_t bufferLength, RecvFunc receiveFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocket::NetSocket </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>receiveFunction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>receiveFunction</em>&nbsp;</td><td>Function to be executed when packets are received. If NULL received packets are put into a queue and retrieved using GetPacketFromStore(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab916dbb4c1afa5078068eaef73274c92"></a><!-- doxytag: member="NetSocket::NetSocket" ref="ab916dbb4c1afa5078068eaef73274c92" args="(size_t bufferLength, RecvFunc receiveFunction, NetInstance *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocket::NetSocket </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>receiveFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_instance.html">NetInstance</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>receiveFunction</em>&nbsp;</td><td>Function to be executed when packets are received. If NULL received packets are put into a queue and retrieved using GetPacketFromStore(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>Pointer to instance that owns this object, use other constructor if no instance does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a505f592181260a75c7c5060021ac4201"></a><!-- doxytag: member="NetSocket::NetSocket" ref="a505f592181260a75c7c5060021ac4201" args="(const NetSocket &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocket::NetSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_socket.html">NetSocket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep copy constructor. </p>
<p>Socket does not directly copy contents of <em>copyMe</em>, but initializes its buffer to be the same size as <em>copyMe's</em>.<br/>
<br/>
</p>
<p><a class="el" href="class_net_socket_simple.html#ace6b7feadf536e09181b23d45c92cc5f" title="Winsock socket used to transfer data.">NetSocketSimple::winsockSocket</a> is not copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a84eea723ebe08ab09554c56a07d5411a"></a><!-- doxytag: member="NetSocket::AddSend" ref="a84eea723ebe08ab09554c56a07d5411a" args="(NetSend *send)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::AddSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_send.html">NetSend</a> *&nbsp;</td>
          <td class="paramname"> <em>send</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a send operation to the cleanup vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>send</em>&nbsp;</td><td>Send operation to add to cleanup vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eeea3a43d5eeeb3a7a12cdcc8a5fc64"></a><!-- doxytag: member="NetSocket::AllocateBuffer" ref="a8eeea3a43d5eeeb3a7a12cdcc8a5fc64" args="(size_t bufferLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::AllocateBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up <a class="el" href="class_net_socket.html#a0565a5dafc4df4589c0013d0c2816f33" title="Winsock buffer that is filled with newly received data.">NetSocket::recvBuffer</a>, allocating memory to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaba0fd1ddc4b4f52751ccb15146aba9a"></a><!-- doxytag: member="NetSocket::AssociateCompletionPort" ref="aaba0fd1ddc4b4f52751ccb15146aba9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::AssociateCompletionPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associates the socket with a completion port. The completion port takes over the following jobs:</p>
<ul>
<li>Cleaning up send operations.</li>
<li>Receiving data and dealing with it. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad085ef45c567752aae4457f7945b46aa"></a><!-- doxytag: member="NetSocket::ClearRecv" ref="ad085ef45c567752aae4457f7945b46aa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::ClearRecv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears <a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96" title="Winsock overlapped operation used to identify when a receive operation has completed.">NetSocket::recvOverlapped</a> object ready for next receive. </p>
<p>This must be done before every receive operation. </p>

<p>Reimplemented in <a class="el" href="class_net_socket_u_d_p.html#ad6c506ea179efce7d353b9f0735e2706">NetSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a85c6cba30c3a8d780bb24d7af8d0a561"></a><!-- doxytag: member="NetSocket::Close" ref="a85c6cba30c3a8d780bb24d7af8d0a561" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes socket. </p>
<p>To ensure that deallocation does not occur when the completion port is using the method:</p>
<ul>
<li>This method waits for all send operations to be cleaned up.</li>
<li>This method waits for all winsock receive operations to complete.</li>
<li>This method waits for finished receive operations to finish being dealt with.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method must not be used by the completion port, in case only one worker thread exists. In that case the completion port would be waiting for things that only it can do. </dd></dl>

<p>Reimplemented from <a class="el" href="class_net_socket_simple.html#a2ec9f15bf28b6ae73783d03c6aedffec">NetSocketSimple</a>.</p>

<p>Reimplemented in <a class="el" href="class_net_socket_t_c_p.html#a407a844020c03e9dd24048f38a4d2c1f">NetSocketTCP</a>, and <a class="el" href="class_net_socket_u_d_p.html#a2363fe21c1fa15e7781766c952c72e95">NetSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a4c8e1cac6b9bde0ef6ce3c137a8563ad"></a><!-- doxytag: member="NetSocket::CompletedSendOperation" ref="a4c8e1cac6b9bde0ef6ce3c137a8563ad" args="(const WSAOVERLAPPED *overlapped, bool success, bool shuttingDown)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::CompletedSendOperation </td>
          <td>(</td>
          <td class="paramtype">const WSAOVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>overlapped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>shuttingDown</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with completed send operation. </p>
<p>In the event of an error that needs further action <a class="el" href="class_net_socket.html#aeff1c796b40fa0545b6b3f2bb7767f4d" title="True if completion port wants this socket to be closed by the main process.">NetSocket::completionPortCloseNotification</a> is signaled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlapped</em>&nbsp;</td><td>Pointer to WSAOVERLAPPED object associated with send operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>success</em>&nbsp;</td><td>True if the operation completed successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shuttingDown</em>&nbsp;</td><td>True if the operation failed but this was because the socket is shutting down. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad04c291a00cc8b97425a60f6f8a20d3a"></a><!-- doxytag: member="NetSocket::CompletionPortRequestClose" ref="ad04c291a00cc8b97425a60f6f8a20d3a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::CompletionPortRequestClose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that the socket should be closed by the main process. </p>
<p>The completion port will only signal a socket for closure if it is stand alone i.e. Not part of an instance.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Should only be used by completion port. </dd></dl>

</div>
</div>
<a class="anchor" id="a99a69ab706122acc2bbe63c64b279b8e"></a><!-- doxytag: member="NetSocket::DealWithData" ref="a99a69ab706122acc2bbe63c64b279b8e" args="(const WSABUF &amp;buffer, size_t completionBytes, NetSocket::RecvFunc recvFunc, size_t clientID, size_t instanceID)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void NetSocket::DealWithData </td>
          <td>(</td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with newly received data using the socket's protocol object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Newly received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>Number of bytes of new data stored in <em>buffer</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance that data was received on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that data was received from, set to 0 if not applicable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_test_net_socket.html#a048a7cff25a17d0e163c3d182211156c">TestNetSocket</a>, <a class="el" href="class_net_socket_t_c_p.html#a33a379bcc79c7c2631be6bea0ac13ce3">NetSocketTCP</a>, and <a class="el" href="class_net_socket_u_d_p.html#a433c0374fee477952c0b89b128cd2df6">NetSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a0f18c5b9a572438bb51cd166ae85e573"></a><!-- doxytag: member="NetSocket::FindSend" ref="a0f18c5b9a572438bb51cd166ae85e573" args="(const OVERLAPPED *operation, size_t &amp;position) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::FindSend </td>
          <td>(</td>
          <td class="paramtype">const OVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for the send operation that is using the specified overlapped object in the send cleanup list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>Pointer to overlapped object. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>position</em>&nbsp;</td><td>The location of the found send operation will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the send operation that is using the specified overlapped object was found in the send cleanup list. </dd></dl>

</div>
</div>
<a class="anchor" id="a419d22dbf82c32e89b2664a18f7a05af"></a><!-- doxytag: member="NetSocket::GetCompletionPortCloseRequest" ref="a419d22dbf82c32e89b2664a18f7a05af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::GetCompletionPortCloseRequest </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the completion port has signaled this socket for closure. </p>
<p>The completion port will only signal a socket for closure if it is stand alone i.e. Not part of an instance.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the completion port wants this socket to be closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c62a6815ffb8b17aabd4963f63c1afc"></a><!-- doxytag: member="NetSocket::GetProtocol" ref="a2c62a6815ffb8b17aabd4963f63c1afc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_socket_simple.html#a31450636f6fb9ece239c50f616e0d7b0">Protocol</a> NetSocket::GetProtocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the protocol type that the socket represents as an enum. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>protocol type that socket represents. </dd></dl>

<p>Implemented in <a class="el" href="class_test_net_socket.html#a66959377686b85046b06a71cd88e285e">TestNetSocket</a>, <a class="el" href="class_net_socket_t_c_p.html#ac599af5903f2a92f481f41ad1466390d">NetSocketTCP</a>, and <a class="el" href="class_net_socket_u_d_p.html#a38f2d51c45a6205aa8209edf8d954dbf">NetSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ae2524e6cffa4e30726fde6b4e703ebc3"></a><!-- doxytag: member="NetSocket::GetRecvBufferLength" ref="ae2524e6cffa4e30726fde6b4e703ebc3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NetSocket::GetRecvBufferLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the size of the receive buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF. This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb34329c03836f0a6962d7396752979"></a><!-- doxytag: member="NetSocket::GetRecvFunction" ref="afbb34329c03836f0a6962d7396752979" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> NetSocket::GetRecvFunction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the function that is executed when complete packets are received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the function that will be executed when data is received. </dd>
<dd>
NULL if there is no method loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d149d9ffbfe8d2240f664fd1923eb74"></a><!-- doxytag: member="NetSocket::Initialize" ref="a9d149d9ffbfe8d2240f664fd1923eb74" args="(size_t bufferLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::Initialize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d65090c23a7624c34bdff512261e74f"></a><!-- doxytag: member="NetSocket::IsOurOverlapped" ref="a8d65090c23a7624c34bdff512261e74f" args="(const WSAOVERLAPPED *overlapped) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::IsOurOverlapped </td>
          <td>(</td>
          <td class="paramtype">const WSAOVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>overlapped</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the specified overlapped object is the overlapped object used by this object to monitor the status of pending receive operations. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>overlapped</em> points to the overlapped object used by this object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlapped</em>&nbsp;</td><td>Overlapped pointer to compare. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eca2a547a5e1e613f782edc3fe8b910"></a><!-- doxytag: member="NetSocket::IsRecvFunctionLoaded" ref="a8eca2a547a5e1e613f782edc3fe8b910" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::IsRecvFunctionLoaded </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether a receive function has been loaded. </p>
<p>If no function has been loaded received packets are put into a queue and retrieved using GetPacketFromStore().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a method to be executed when packets are received has been set. </dd>
<dd>
false if no method has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dad9c9499a245c125ba90fc753592f4"></a><!-- doxytag: member="NetSocket::IsSendEmpty" ref="a9dad9c9499a245c125ba90fc753592f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::IsSendEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the send cleanup vector is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the send cleanup vector is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a703ac13a72d73c598c81372946097210"></a><!-- doxytag: member="NetSocket::operator=" ref="a703ac13a72d73c598c81372946097210" args="(const NetSocket &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html">NetSocket</a> &amp; NetSocket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_socket.html">NetSocket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep assignment operator. </p>
<p>Socket does not directly copy contents of <em>copyMe</em>, but initializes its buffer to be the same size as <em>copyMe's</em>.<br/>
<br/>
</p>
<p><a class="el" href="class_net_socket_simple.html#ace6b7feadf536e09181b23d45c92cc5f" title="Winsock socket used to transfer data.">NetSocketSimple::winsockSocket</a> is not copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="afb09f225fda4d4b8f1108cb6c1e6b3d9"></a><!-- doxytag: member="NetSocket::RemoveRecvFunction" ref="afb09f225fda4d4b8f1108cb6c1e6b3d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::RemoveRecvFunction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporarily disables the receive function. </p>
<p>Use <a class="el" href="class_net_socket.html#a0da1e270db405a2a49cb66670fbb2fbd" title="Resets receive function as if RemoveRecvFunction had never been used.">UndoRemoveRecvFunction()</a> to undo this action. </p>

</div>
</div>
<a class="anchor" id="ae6829ea0830059f1c21154a9c1392ed2"></a><!-- doxytag: member="NetSocket::RemoveSend" ref="ae6829ea0830059f1c21154a9c1392ed2" args="(size_t element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::RemoveSend </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up the send operation at the specified element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to cleanup. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Check that object is not in use. The object will only be in use at this point if it is still executing the internal function it was doing when it added itself to the cleanup queue. It may still need to use some internal variables e.g. If it is blocking for completion and so we must wait before we clean it up. We must release the critical section BEFORE cleaning it up.</p>
</p>

</div>
</div>
<a class="anchor" id="aedd848a5bbf20f92dcd2f2d68603a16a"></a><!-- doxytag: member="NetSocket::RemoveSend" ref="aedd848a5bbf20f92dcd2f2d68603a16a" args="(const OVERLAPPED *operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::RemoveSend </td>
          <td>(</td>
          <td class="paramtype">const OVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>operation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up the send operation that is using the specified overlapped object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>Pointer to overlapped operation of send operation to cleanup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an operation was cleaned up, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a808894184a1eed1a647e1cdf3c015f3a"></a><!-- doxytag: member="NetSocket::Send" ref="a808894184a1eed1a647e1cdf3c015f3a" args="(const Packet &amp;packet, bool block, const NetAddress *sendToAddr, unsigned int timeout)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>sendToAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet using this socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendToAddr</em>&nbsp;</td><td>Address to send to, if NULL then object is sent to address that socket is connected to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Length of time in milliseconds to wait before canceling send operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implemented in <a class="el" href="class_test_net_socket.html#a8532d19ebb469fa60ed3c66ca62ad0b7">TestNetSocket</a>, <a class="el" href="class_net_socket_t_c_p.html#a0c81335a45d43fc31073596bee96f7c0">NetSocketTCP</a>, and <a class="el" href="class_net_socket_u_d_p.html#ab9f7c46f5aab7fb043a40f831132f213">NetSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a35080a7efc36c4a4444dcf8a35213ccd"></a><!-- doxytag: member="NetSocket::Send" ref="a35080a7efc36c4a4444dcf8a35213ccd" args="(NetSend &amp;sendObject, const NetAddress *sendToAddr, unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetSocket::Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_send.html">NetSend</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sendObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>sendToAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a send object to the specified address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendObject</em>&nbsp;</td><td>Object to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendToAddr</em>&nbsp;</td><td>Address to send to, if NULL then object is sent to address that socket is connected to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Length of time in milliseconds to wait before canceling send operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="aafadb66f83b867d49633a304d1083cad"></a><!-- doxytag: member="NetSocket::SetClientID" ref="aafadb66f83b867d49633a304d1083cad" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::SetClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the completion key client ID field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>Client ID to be loaded into completion key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a389b4eb60158c997a932798a2de02e68"></a><!-- doxytag: member="NetSocket::SetCompletionPortFinishRecvNotification" ref="a389b4eb60158c997a932798a2de02e68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::SetCompletionPortFinishRecvNotification </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that the receive operation that was last initiated has completed. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Should only be used by completion port. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5e8328367081d19e64a37e6b15703cf"></a><!-- doxytag: member="NetSocket::SetInstance" ref="aa5e8328367081d19e64a37e6b15703cf" args="(NetInstance *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::SetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance.html">NetInstance</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the completion key instance field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>Pointer to instance to be loaded into completion key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41017899d90bb50e70345c5fcfbce577"></a><!-- doxytag: member="NetSocket::SetRecvOverlappedEvent" ref="a41017899d90bb50e70345c5fcfbce577" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocket::SetRecvOverlappedEvent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manually sets the overlapped event. </p>
<p>This is necessary when an overlapped recv operation fails before pending as in this case the overlapped event object is not automatically signaled. </p>

</div>
</div>
<a class="anchor" id="ae2233dd5a751f07101b1347df5dfc308"></a><!-- doxytag: member="NetSocket::TestClass" ref="ae2233dd5a751f07101b1347df5dfc308" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocket::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

<p>Reimplemented from <a class="el" href="class_net_socket_simple.html#a69c2149f61ab6af018faf89e61ec6592">NetSocketSimple</a>.</p>

<p>Reimplemented in <a class="el" href="class_net_socket_t_c_p.html#a844311ce7f1248d66b4e15d9e042e89a">NetSocketTCP</a>, and <a class="el" href="class_net_socket_u_d_p.html#a68728f4e9718f3f730a8f28c94a91968">NetSocketUDP</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a26693d766fabf449245ef0a1e2a5ff49"></a><!-- doxytag: member="NetSocket::completionKey" ref="a26693d766fabf449245ef0a1e2a5ff49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_completion_key.html">CompletionKey</a> <a class="el" href="class_net_socket.html#a26693d766fabf449245ef0a1e2a5ff49">NetSocket::completionKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unique completion key used by completion port to identify this object. </p>
<p>Public access rights so that winsock has access to it. </p>

</div>
</div>
<a class="anchor" id="aeff1c796b40fa0545b6b3f2bb7767f4d"></a><!-- doxytag: member="NetSocket::completionPortCloseNotification" ref="aeff1c796b40fa0545b6b3f2bb7767f4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a> <a class="el" href="class_net_socket.html#aeff1c796b40fa0545b6b3f2bb7767f4d">NetSocket::completionPortCloseNotification</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>True if completion port wants this socket to be closed by the main process. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Completion port does not close socket directly in order to simplify multithreaded architecture. </dd></dl>

</div>
</div>
<a class="anchor" id="a794267d0dd5ed57e8d9bfdfea01d2995"></a><!-- doxytag: member="NetSocket::flags" ref="a794267d0dd5ed57e8d9bfdfea01d2995" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD <a class="el" href="class_net_socket.html#a794267d0dd5ed57e8d9bfdfea01d2995">NetSocket::flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filled when TCP receive operation completes, is ignored but required by winsock. </p>
<p>Public access rights so that winsock has access to it. </p>

</div>
</div>
<a class="anchor" id="a03f60f949b31ee3feae0d1d3daa3bf3c"></a><!-- doxytag: member="NetSocket::notDealingWithData" ref="a03f60f949b31ee3feae0d1d3daa3bf3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a> <a class="el" href="class_net_socket.html#a03f60f949b31ee3feae0d1d3daa3bf3c">NetSocket::notDealingWithData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>False after a receive operation has been initiated, only true when the operation has finished AND all data has been dealt with. </p>
<p>This is important during the socket closure process so that resources being used are not cleaned up. </p>

</div>
</div>
<a class="anchor" id="a0565a5dafc4df4589c0013d0c2816f33"></a><!-- doxytag: member="NetSocket::recvBuffer" ref="a0565a5dafc4df4589c0013d0c2816f33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSABUF <a class="el" href="class_net_socket.html#a0565a5dafc4df4589c0013d0c2816f33">NetSocket::recvBuffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Winsock buffer that is filled with newly received data. </p>
<p>Public access rights so that winsock has access to it. </p>

</div>
</div>
<a class="anchor" id="a7d4dd5d72c86d0ee4f46a3ec9e03bdfc"></a><!-- doxytag: member="NetSocket::recvFunctionAux" ref="a7d4dd5d72c86d0ee4f46a3ec9e03bdfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_concurrent_object.html">ConcurrentObject</a>&lt;<a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&gt; <a class="el" href="class_net_socket.html#a7d4dd5d72c86d0ee4f46a3ec9e03bdfc">NetSocket::recvFunctionAux</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporary store of <a class="el" href="class_net_socket.html#a92fcd22d674b159c192f356728d2a575" title="Function to be called every time a complete packet is received.">NetSocket::recvFunction</a>. </p>
<p>This is used in rare cases where the receive function needs to be temporarily disabled during an initial connection process, usually at the instance level. </p>

</div>
</div>
<a class="anchor" id="ac260f690a6f192c22463d1f5ea903d96"></a><!-- doxytag: member="NetSocket::recvOverlapped" ref="ac260f690a6f192c22463d1f5ea903d96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSAOVERLAPPED <a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96">NetSocket::recvOverlapped</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Winsock overlapped operation used to identify when a receive operation has completed. </p>
<p>See <a class="el" href="class_net_socket.html#aeeae305cd0382ee87cf9c35aec571719" title="Event object associated with NetSocket::recvOverlapped.">NetSocket::recvOverlappedEvent</a> for details on the status of the associated event object.<br/>
<br/>
</p>
<p>Public access rights so that winsock has access to it. </p>

</div>
</div>
<a class="anchor" id="aeeae305cd0382ee87cf9c35aec571719"></a><!-- doxytag: member="NetSocket::recvOverlappedEvent" ref="aeeae305cd0382ee87cf9c35aec571719" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a> <a class="el" href="class_net_socket.html#aeeae305cd0382ee87cf9c35aec571719">NetSocket::recvOverlappedEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event object associated with <a class="el" href="class_net_socket.html#ac260f690a6f192c22463d1f5ea903d96" title="Winsock overlapped operation used to identify when a receive operation has completed.">NetSocket::recvOverlapped</a>. </p>
<p>The overlapped event object goes through the following stages: <br/>
 1. Starts signaled. <br/>
 2. Begins operation, becomes unsignaled. <br/>
 3. Finishes operation successfully and becomes signaled. <br/>
 4. OR fails to complete operation and is manually signaled (to prevent deadlock). <br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a84e789c6d2552eef894f1f751539233f"></a><!-- doxytag: member="NetSocket::sendCleanup" ref="a84e789c6d2552eef894f1f751539233f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_store_vector.html">StoreVector</a>&lt;<a class="el" href="class_net_send.html">NetSend</a>&gt; <a class="el" href="class_net_socket.html#a84e789c6d2552eef894f1f751539233f">NetSocket::sendCleanup</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This vector is filled with send operations that are in progress. </p>
<p>Upon completion, a completion thread compares the overlapped pointer using. <a class="el" href="class_net_socket.html#aedd848a5bbf20f92dcd2f2d68603a16a" title="Cleans up the send operation that is using the specified overlapped object.">RemoveSend()</a> to determine which send operation should be cleaned up. When cleaned up the send operation is removed from this vector.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Vector should not be used if socket is not associated with completion port. </dd>
<dd>
Made mutable because vector CPP class is not const correct. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_socket_8h_source.html">NetSocket.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetSocket.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:22 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
