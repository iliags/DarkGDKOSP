<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: NetSocketTCP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>NetSocketTCP Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetSocketTCP" --><!-- doxytag: inherits="NetSocket" -->
<p>Socket used for TCP data transfer.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_socket_t_c_p_8h_source.html">NetSocketTCP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetSocketTCP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_socket_t_c_p.png" usemap="#NetSocketTCP_map" alt=""/>
  <map id="NetSocketTCP_map" name="NetSocketTCP_map">
<area href="class_net_socket.html" alt="NetSocket" shape="rect" coords="0,56,106,80"/>
<area href="class_net_socket_simple.html" alt="NetSocketSimple" shape="rect" coords="0,0,106,24"/>
</map>
</div>

<p><a href="class_net_socket_t_c_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a95b4b79524f18cf19c2bf067ab94799e">NetSocketTCP</a> (size_t wsaBufferLength, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;localAddr, bool <a class="el" href="class_net_socket_simple.html#a7edf43d1de9a08cd1919ba386955951a">nagleEnabled</a>, bool gracefulDisconnectEnabled, <a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *<a class="el" href="class_net_socket_t_c_p.html#aafcdf2d4234f269eab1c9d43955e99bc">modeTCP</a>, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, sets up socket ready to be connected and transfer data.  <a href="#a95b4b79524f18cf19c2bf067ab94799e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#afd3973e920c0c5eb352d1cced26d8c30">NetSocketTCP</a> (size_t wsaBufferLength, bool <a class="el" href="class_net_socket_simple.html#a7edf43d1de9a08cd1919ba386955951a">nagleEnabled</a>, bool gracefulDisconnectEnabled, <a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *<a class="el" href="class_net_socket_t_c_p.html#aafcdf2d4234f269eab1c9d43955e99bc">modeTCP</a>, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, sets up socket ready to be loaded (via <a class="el" href="class_net_socket_t_c_p.html#a2c2fc5b7ff9f35930f566b6913b67aef" title="Loads a TCP winsock socket that is already fully setup and connected.">LoadSOCKET()</a>) with a fully operational socket.  <a href="#afd3973e920c0c5eb352d1cced26d8c30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae689f3d8989ce0b5bc4e78c61e7236b1"></a><!-- doxytag: member="NetSocketTCP::~NetSocketTCP" ref="ae689f3d8989ce0b5bc4e78c61e7236b1" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#ae689f3d8989ce0b5bc4e78c61e7236b1">~NetSocketTCP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#ab8958e92980c0f82dc75c2dc59e05577">NetSocketTCP</a> (const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy constructor.  <a href="#ab8958e92980c0f82dc75c2dc59e05577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a5307a3b22575686da141a3929e5eb3be">operator=</a> (const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep assignment operator.  <a href="#a5307a3b22575686da141a3929e5eb3be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a2c2fc5b7ff9f35930f566b6913b67aef">LoadSOCKET</a> (SOCKET paraSocket, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a TCP winsock socket that is already fully setup and connected.  <a href="#a2c2fc5b7ff9f35930f566b6913b67aef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a211e98d94191998d689e4ddc0714f18d">PollConnect</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the status of the TCP handshake routine started by <a class="el" href="class_net_socket_simple.html#a8b3d61a80b904f12791144ba336cf37b" title="Connects the socket to a remote address.">NetSocketSimple::Connect()</a>.  <a href="#a211e98d94191998d689e4ddc0714f18d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a0c81335a45d43fc31073596bee96f7c0">Send</a> (const <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool block, const <a class="el" href="class_net_address.html">NetAddress</a> *sendToAddr, unsigned int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet using this socket.  <a href="#a0c81335a45d43fc31073596bee96f7c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31775717fef7b062f9af098ca5e6b7c9"></a><!-- doxytag: member="NetSocketTCP::Shutdown" ref="a31775717fef7b062f9af098ca5e6b7c9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9">Shutdown</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="class_net_socket_t_c_p.html#a71e478845fc449fc9fccaa098db37c50" title="Halts sending on socket so that all further send operations will fail.">StopSend()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a71e478845fc449fc9fccaa098db37c50">StopSend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Halts sending on socket so that all further send operations will fail.  <a href="#a71e478845fc449fc9fccaa098db37c50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a3bfb846d84dd1f29ece510f025adba3d">IsSendPossible</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether further send operations can be initiated.  <a href="#a3bfb846d84dd1f29ece510f025adba3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a1e1063d77e9ae490c4c5146136141199">IsRecvPossible</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether further receive operations can be initiated.  <a href="#a1e1063d77e9ae490c4c5146136141199"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a11891910910477cf1eba5fffef8bda52">Recv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a receive operation via TCP.  <a href="#a11891910910477cf1eba5fffef8bda52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a407a844020c03e9dd24048f38a4d2c1f"></a><!-- doxytag: member="NetSocketTCP::Close" ref="a407a844020c03e9dd24048f38a4d2c1f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a407a844020c03e9dd24048f38a4d2c1f">Close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes socket and resets <a class="el" href="class_net_socket_t_c_p.html#aafcdf2d4234f269eab1c9d43955e99bc" title="Describes how received data should be dealt with and how sent data should be modified.">NetSocketTCP::modeTCP</a> to unused state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a68dc0183e216cdd1796466d411f0b681">GetConnectionStatus</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the status of the connection.  <a href="#a68dc0183e216cdd1796466d411f0b681"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#ad528efe4a16f0a110f488820d7abbc89">GetMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves constant pointer to TCP mode object.  <a href="#ad528efe4a16f0a110f488820d7abbc89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a75ede4ec55e9e9ec49a0f31da51e2dd3">GetMode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves mutable pointer to TCP mode object.  <a href="#a75ede4ec55e9e9ec49a0f31da51e2dd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a00ea1a6922eb6cf69e23a1992752685c">IsGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled.  <a href="#a00ea1a6922eb6cf69e23a1992752685c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket_simple.html#a31450636f6fb9ece239c50f616e0d7b0">NetSocket::Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#ac599af5903f2a92f481f41ad1466390d">GetProtocol</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the protocol type that the socket represents as an enum.  <a href="#ac599af5903f2a92f481f41ad1466390d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a33a379bcc79c7c2631be6bea0ac13ce3">DealWithData</a> (const WSABUF &amp;buffer, size_t completionBytes, <a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> recvFunc, size_t clientID, size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deals with newly received data using the stored <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a> object.  <a href="#a33a379bcc79c7c2631be6bea0ac13ce3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a844311ce7f1248d66b4e15d9e042e89a">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#a844311ce7f1248d66b4e15d9e042e89a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39f8b4993f0995b1ee3c3f037870184d"></a><!-- doxytag: member="NetSocketTCP::AssociateGracefulDisconnect" ref="a39f8b4993f0995b1ee3c3f037870184d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a39f8b4993f0995b1ee3c3f037870184d">AssociateGracefulDisconnect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates event object with FD_CLOSE notification if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#aa53e2b58c3330e5d8ea6a61942a3daf7">Initialize</a> (bool gracefulDisconnectEnabled, <a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *<a class="el" href="class_net_socket_t_c_p.html#aafcdf2d4234f269eab1c9d43955e99bc">modeTCP</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes object, contains code that is shared between constructors.  <a href="#aa53e2b58c3330e5d8ea6a61942a3daf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a70bc18da8a63c5209f10e818cda8675b">Copy</a> (const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;copyMe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor / assignment operator helper method.  <a href="#a70bc18da8a63c5209f10e818cda8675b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a59ecfff878b08596b570c17ae57b93b9">gracefulShutdown</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non NULL if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. Signaled when an <code>FD_CLOSE</code> notification has been received.  <a href="#a59ecfff878b08596b570c17ae57b93b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#a405f72b045af06f88730b1b239dfe61d">sendPossible</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">False when <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> or <a class="el" href="class_net_socket_t_c_p.html#a71e478845fc449fc9fccaa098db37c50" title="Halts sending on socket so that all further send operations will fail.">StopSend()</a> have been used.  <a href="#a405f72b045af06f88730b1b239dfe61d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafcdf2d4234f269eab1c9d43955e99bc"></a><!-- doxytag: member="NetSocketTCP::modeTCP" ref="aafcdf2d4234f269eab1c9d43955e99bc" args="" -->
<a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_socket_t_c_p.html#aafcdf2d4234f269eab1c9d43955e99bc">modeTCP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes how received data should be dealt with and how sent data should be modified. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Socket used for TCP data transfer. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 3/28/2010.</dd></dl>
<p>This class provides functionality specific to the TCP protocol.<br/>
<br/>
</p>
<p>This class is not thread safe: </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a95b4b79524f18cf19c2bf067ab94799e"></a><!-- doxytag: member="NetSocketTCP::NetSocketTCP" ref="a95b4b79524f18cf19c2bf067ab94799e" args="(size_t wsaBufferLength, const NetAddress &amp;localAddr, bool nagleEnabled, bool gracefulDisconnectEnabled, NetModeTcp *modeTCP, NetSocket::RecvFunc recvFunc=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocketTCP::NetSocketTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>wsaBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>nagleEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>gracefulDisconnectEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td>
          <td class="paramname"> <em>modeTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, sets up socket ready to be connected and transfer data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wsaBufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localAddr</em>&nbsp;</td><td>Local address to bind to, if IP or port is set to 0 then winsock will automatically find one. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nagleEnabled</em>&nbsp;</td><td>If true then the nagle algorithm will be enabled. See. <a class="el" href="class_net_socket_simple.html#a7edf43d1de9a08cd1919ba386955951a" title="True if the Nagle algorithm is enabled.">NetSocketSimple::nagleEnabled</a> for more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gracefulDisconnectEnabled</em>&nbsp;</td><td>If true <a class="el" href="graceful_disconnect_page.html">graceful</a> disconnection" is possible. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modeTCP</em>&nbsp;</td><td>Describes how received data should be dealt with and how sent data should be modified. Must not be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Function that any received packets will be passed to. (optional, default NULL). Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>. If NULL then packets will not be passed to a function, and instead will be put into a queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd3973e920c0c5eb352d1cced26d8c30"></a><!-- doxytag: member="NetSocketTCP::NetSocketTCP" ref="afd3973e920c0c5eb352d1cced26d8c30" args="(size_t wsaBufferLength, bool nagleEnabled, bool gracefulDisconnectEnabled, NetModeTcp *modeTCP, NetSocket::RecvFunc recvFunc=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocketTCP::NetSocketTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>wsaBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>nagleEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>gracefulDisconnectEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td>
          <td class="paramname"> <em>modeTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, sets up socket ready to be loaded (via <a class="el" href="class_net_socket_t_c_p.html#a2c2fc5b7ff9f35930f566b6913b67aef" title="Loads a TCP winsock socket that is already fully setup and connected.">LoadSOCKET()</a>) with a fully operational socket. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This socket is not ready to be used yet, LoadSOCKET MUST be used before attempting to transfer data.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_net_server_client.html" title="Object stores and manages individual clients.">NetServerClient</a> has an object constructed in this way as it is more efficient to allocate memory to the WSABUF during initial instance setup, since typically this buffer will not be reallocated during the lifetime of the instance. An alternative method (which is not implemented in MikeNet) would be to pass a new <a class="el" href="class_net_socket_t_c_p.html" title="Socket used for TCP data transfer.">NetSocketTCP</a> object after WSAAccept accepts a connection but this has the overhead of WSABUF allocation during connection and equally. WSABUF deallocation during disconnection of a client.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wsaBufferLength</em>&nbsp;</td><td>Length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nagleEnabled</em>&nbsp;</td><td>True if the nagle algorithm should be enabled, false if not. See <a class="el" href="class_net_socket_simple.html#a7edf43d1de9a08cd1919ba386955951a" title="True if the Nagle algorithm is enabled.">NetSocketSimple::nagleEnabled</a> for more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gracefulDisconnectEnabled</em>&nbsp;</td><td>If true <a class="el" href="graceful_disconnect_page.html">graceful</a> disconnection" is possible. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modeTCP</em>&nbsp;</td><td>Describes how received data should be dealt with and how sent data should be modified. Must not be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Function that any received packets will be passed to. (optional, default NULL). Care must be taken to ensure that this function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a>. If NULL then packets will not be passed to a function, and instead will be put into a queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8958e92980c0f82dc75c2dc59e05577"></a><!-- doxytag: member="NetSocketTCP::NetSocketTCP" ref="ab8958e92980c0f82dc75c2dc59e05577" args="(const NetSocketTCP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetSocketTCP::NetSocketTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep copy constructor. </p>
<p>Socket will not be ready to send or receive data, even if <em>copyMe</em> is. First LoadSOCKET must be used to load a fully setup winsock socket object.<br/>
<br/>
</p>
<p><a class="el" href="class_net_socket_simple.html#ace6b7feadf536e09181b23d45c92cc5f" title="Winsock socket used to transfer data.">NetSocketSimple::winsockSocket</a> is not copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a70bc18da8a63c5209f10e818cda8675b"></a><!-- doxytag: member="NetSocketTCP::Copy" ref="a70bc18da8a63c5209f10e818cda8675b" args="(const NetSocketTCP &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocketTCP::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor / assignment operator helper method. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Does not copy modeTCP, do this elsewhere.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33a379bcc79c7c2631be6bea0ac13ce3"></a><!-- doxytag: member="NetSocketTCP::DealWithData" ref="a33a379bcc79c7c2631be6bea0ac13ce3" args="(const WSABUF &amp;buffer, size_t completionBytes, NetSocket::RecvFunc recvFunc, size_t clientID, size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocketTCP::DealWithData </td>
          <td>(</td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deals with newly received data using the stored <a class="el" href="class_net_mode_tcp.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">NetModeTcp</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Newly received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>Number of bytes of new data stored in NetSocket::buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>Method will be executed and data not added to the queue if this is non NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance that data was received on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that data was received from, set to 0 if not applicable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_net_socket.html#a99a69ab706122acc2bbe63c64b279b8e">NetSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a68dc0183e216cdd1796466d411f0b681"></a><!-- doxytag: member="NetSocketTCP::GetConnectionStatus" ref="a68dc0183e216cdd1796466d411f0b681" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> NetSocketTCP::GetConnectionStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the status of the connection. </p>
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a>: Fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6daef8b7210b8ae3961e19fcde743ee08af">NetUtility::NOT_CONNECTED</a>: Not connected at all. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dad749d5c33d1f4fda670efe634f651885">NetUtility::NO_RECV</a>: Connected but new data cannot be received because <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> has been used by the end point that we are connected to (only possible if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da1bcc92a56bd754f0e02e33787f7f9e38">NetUtility::NO_SEND</a>: Connected but data cannot be sent because <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> has been used by the end point that we are connected to (only possible if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabfdb16770f1140f86d621739ffe89560">NetUtility::NO_SEND_RECV</a>: Connected but data cannot be sent or received because <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled). </dd></dl>

</div>
</div>
<a class="anchor" id="a75ede4ec55e9e9ec49a0f31da51e2dd3"></a><!-- doxytag: member="NetSocketTCP::GetMode" ref="a75ede4ec55e9e9ec49a0f31da51e2dd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> * NetSocketTCP::GetMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves mutable pointer to TCP mode object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns pointer to object representing TCP mode specific options. </dd></dl>

</div>
</div>
<a class="anchor" id="ad528efe4a16f0a110f488820d7abbc89"></a><!-- doxytag: member="NetSocketTCP::GetMode" ref="ad528efe4a16f0a110f488820d7abbc89" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> * NetSocketTCP::GetMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves constant pointer to TCP mode object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns pointer to object (which cannot be modified) representing TCP mode specific options. </dd></dl>

</div>
</div>
<a class="anchor" id="ac599af5903f2a92f481f41ad1466390d"></a><!-- doxytag: member="NetSocketTCP::GetProtocol" ref="ac599af5903f2a92f481f41ad1466390d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket_simple.html#a31450636f6fb9ece239c50f616e0d7b0">NetSocket::Protocol</a> NetSocketTCP::GetProtocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the protocol type that the socket represents as an enum. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_socket_simple.html#a31450636f6fb9ece239c50f616e0d7b0ad093d601c519b54e673755f915cd6467">NetSocketSimple::TCP</a>. </dd></dl>

<p>Implements <a class="el" href="class_net_socket.html#a2c62a6815ffb8b17aabd4963f63c1afc">NetSocket</a>.</p>

</div>
</div>
<a class="anchor" id="aa53e2b58c3330e5d8ea6a61942a3daf7"></a><!-- doxytag: member="NetSocketTCP::Initialize" ref="aa53e2b58c3330e5d8ea6a61942a3daf7" args="(bool gracefulDisconnectEnabled, NetModeTcp *modeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocketTCP::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>gracefulDisconnectEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode_tcp.html">NetModeTcp</a> *&nbsp;</td>
          <td class="paramname"> <em>modeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes object, contains code that is shared between constructors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modeTCP</em>&nbsp;</td><td>Describes how received data should be dealt with and how sent data should be modified. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gracefulDisconnectEnabled</em>&nbsp;</td><td>If true <a class="el" href="graceful_disconnect_page.html">graceful</a> disconnection" is possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00ea1a6922eb6cf69e23a1992752685c"></a><!-- doxytag: member="NetSocketTCP::IsGracefulDisconnectEnabled" ref="a00ea1a6922eb6cf69e23a1992752685c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::IsGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. </p>
<p>See NetSocketTCP::gracefulDisconnectEnabled for more information.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>gracefulDisconnectEnabled true if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is possible. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e1063d77e9ae490c4c5146136141199"></a><!-- doxytag: member="NetSocketTCP::IsRecvPossible" ref="a1e1063d77e9ae490c4c5146136141199" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::IsRecvPossible </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether further receive operations can be initiated. </p>
<p>See <a class="el" href="class_net_socket_t_c_p.html#a59ecfff878b08596b570c17ae57b93b9" title="Non NULL if graceful disconnection is enabled. Signaled when an FD_CLOSE notification has been receiv...">NetSocketTCP::gracefulShutdown</a> for more information.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if further receive operations can be initiated. </dd>
<dd>
false if further receive operations will fail. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bfb846d84dd1f29ece510f025adba3d"></a><!-- doxytag: member="NetSocketTCP::IsSendPossible" ref="a3bfb846d84dd1f29ece510f025adba3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::IsSendPossible </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether further send operations can be initiated. </p>
<p>See <a class="el" href="class_net_socket_t_c_p.html#a405f72b045af06f88730b1b239dfe61d" title="False when Shutdown() or StopSend() have been used.">NetSocketTCP::sendPossible</a> for more information.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if further send operations can be initiated. </dd>
<dd>
false if further send operations will fail. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2fc5b7ff9f35930f566b6913b67aef"></a><!-- doxytag: member="NetSocketTCP::LoadSOCKET" ref="a2c2fc5b7ff9f35930f566b6913b67aef" args="(SOCKET paraSocket, const NetAddress &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocketTCP::LoadSOCKET </td>
          <td>(</td>
          <td class="paramtype">SOCKET&nbsp;</td>
          <td class="paramname"> <em>paraSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a TCP winsock socket that is already fully setup and connected. </p>
<p>This is used when <code>WSAAccept</code> accepts a connection. WSAAccept does not associate the socket with the completion port, so this is done by this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paraSocket</em>&nbsp;</td><td>TCP winsock socket that is fully setup. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address that socket is connected to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_net_socket_simple.html#a891ba8e42ebdea12ee56888e5adf942d">NetSocketSimple</a>.</p>

</div>
</div>
<a class="anchor" id="a5307a3b22575686da141a3929e5eb3be"></a><!-- doxytag: member="NetSocketTCP::operator=" ref="a5307a3b22575686da141a3929e5eb3be" args="(const NetSocketTCP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp; NetSocketTCP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_socket_t_c_p.html">NetSocketTCP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep assignment operator. </p>
<p><a class="el" href="class_net_socket_simple.html#ace6b7feadf536e09181b23d45c92cc5f" title="Winsock socket used to transfer data.">NetSocketSimple::winsockSocket</a> is not copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a211e98d94191998d689e4ddc0714f18d"></a><!-- doxytag: member="NetSocketTCP::PollConnect" ref="a211e98d94191998d689e4ddc0714f18d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::PollConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the status of the TCP handshake routine started by <a class="el" href="class_net_socket_simple.html#a8b3d61a80b904f12791144ba336cf37b" title="Connects the socket to a remote address.">NetSocketSimple::Connect()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the connection is in progress. </dd>
<dd>
false if the connection has completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a11891910910477cf1eba5fffef8bda52"></a><!-- doxytag: member="NetSocketTCP::Recv" ref="a11891910910477cf1eba5fffef8bda52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::Recv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a receive operation via TCP. </p>
<p>This method calls the winsock method <code>WSARecv</code>.<br/>
<br/>
</p>
<p>If <code>WSARecv</code> is successful the result of the operation (which will probably not complete instantly) will be passed to the completion port. Upon completion <a class="el" href="class_net_socket.html#a0565a5dafc4df4589c0013d0c2816f33" title="Winsock buffer that is filled with newly received data.">NetSocket::recvBuffer</a> will be filled with received data.<br/>
<br/>
</p>
<p>If <code>WSARecv</code> is unsuccessful the operation will not complete so the completion port will receive no notification. This means that we must manually set the overlapped event in the case of initial failure.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Receive operations will fail when the thread exits, so if you start a receive operation and the thread that started it completes then the operation will fail and no data will be received.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an error occurred and data was not properly received, false if no error occurred. </dd></dl>

<p>Implements <a class="el" href="class_net_socket.html#ad6ef9866517f7aad01a69b70467375d5">NetSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a0c81335a45d43fc31073596bee96f7c0"></a><!-- doxytag: member="NetSocketTCP::Send" ref="a0c81335a45d43fc31073596bee96f7c0" args="(const Packet &amp;packet, bool block, const NetAddress *sendToAddr, unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> NetSocketTCP::Send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>sendToAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a packet using this socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendToAddr</em>&nbsp;</td><td>Ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Length of time in milliseconds to wait before canceling send operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

<p>Implements <a class="el" href="class_net_socket.html#a808894184a1eed1a647e1cdf3c015f3a">NetSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a71e478845fc449fc9fccaa098db37c50"></a><!-- doxytag: member="NetSocketTCP::StopSend" ref="a71e478845fc449fc9fccaa098db37c50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetSocketTCP::StopSend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Halts sending on socket so that all further send operations will fail. </p>
<p>See <a class="el" href="class_net_socket_t_c_p.html#a405f72b045af06f88730b1b239dfe61d" title="False when Shutdown() or StopSend() have been used.">NetSocketTCP::sendPossible</a> for more information.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If graceful disconnect is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a844311ce7f1248d66b4e15d9e042e89a"></a><!-- doxytag: member="NetSocketTCP::TestClass" ref="a844311ce7f1248d66b4e15d9e042e89a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetSocketTCP::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

<p>Reimplemented from <a class="el" href="class_net_socket.html#ae2233dd5a751f07101b1347df5dfc308">NetSocket</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a59ecfff878b08596b570c17ae57b93b9"></a><!-- doxytag: member="NetSocketTCP::gracefulShutdown" ref="a59ecfff878b08596b570c17ae57b93b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_concurrency_event.html">ConcurrencyEvent</a>* <a class="el" href="class_net_socket_t_c_p.html#a59ecfff878b08596b570c17ae57b93b9">NetSocketTCP::gracefulShutdown</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non NULL if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. Signaled when an <code>FD_CLOSE</code> notification has been received. </p>
<p>If non NULL <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> / <a class="el" href="class_net_socket_t_c_p.html#a71e478845fc449fc9fccaa098db37c50" title="Halts sending on socket so that all further send operations will fail.">StopSend()</a>, <a class="el" href="class_net_socket_t_c_p.html#a1e1063d77e9ae490c4c5146136141199" title="Determines whether further receive operations can be initiated.">IsRecvPossible()</a> and <a class="el" href="class_net_socket_t_c_p.html#a3bfb846d84dd1f29ece510f025adba3d" title="Determines whether further send operations can be initiated.">IsSendPossible()</a> can now be used (with purpose). When this variable is false these methods should not be used.<br/>
<br/>
</p>
<p><code>FD_CLOSE</code> is a signal that indicates that the end point that the socket is connected to has used <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a>. All further attempts to start a receive operation will fail and. <a class="el" href="class_net_socket_t_c_p.html#a1e1063d77e9ae490c4c5146136141199" title="Determines whether further receive operations can be initiated.">IsRecvPossible()</a> will return false. This is only possible when <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. </p>

</div>
</div>
<a class="anchor" id="a405f72b045af06f88730b1b239dfe61d"></a><!-- doxytag: member="NetSocketTCP::sendPossible" ref="a405f72b045af06f88730b1b239dfe61d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_socket_t_c_p.html#a405f72b045af06f88730b1b239dfe61d">NetSocketTCP::sendPossible</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>False when <a class="el" href="class_net_socket_t_c_p.html#a31775717fef7b062f9af098ca5e6b7c9" title="Calls StopSend().">Shutdown()</a> or <a class="el" href="class_net_socket_t_c_p.html#a71e478845fc449fc9fccaa098db37c50" title="Halts sending on socket so that all further send operations will fail.">StopSend()</a> have been used. </p>
<p>All further send operations will fail and <a class="el" href="class_net_socket_t_c_p.html#a3bfb846d84dd1f29ece510f025adba3d" title="Determines whether further send operations can be initiated.">IsSendPossible()</a> will return false. Further receive operations may succeed if <a class="el" href="class_net_socket_t_c_p.html#a1e1063d77e9ae490c4c5146136141199" title="Determines whether further receive operations can be initiated.">IsRecvPossible()</a> returns true.<br/>
<br/>
</p>
<p>An <code>FD_CLOSE</code> notification is sent to the end point that the socket is connected to when this is first changed to false, see <a class="el" href="class_net_socket_t_c_p.html#a59ecfff878b08596b570c17ae57b93b9" title="Non NULL if graceful disconnection is enabled. Signaled when an FD_CLOSE notification has been receiv...">NetSocketTCP::gracefulShutdown</a> for more information. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/<a class="el" href="_net_socket_t_c_p_8h_source.html">NetSocketTCP.h</a></li>
<li>C:/Users/Michael Pryor/Documents/Programming 09/MikeNet/Project/MikeNet/NetSocketTCP.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:22 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
