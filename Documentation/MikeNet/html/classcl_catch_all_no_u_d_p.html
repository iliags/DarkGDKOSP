<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clCatchAllNoUDP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clCatchAllNoUDP Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clCatchAllNoUDP" --><!-- doxytag: inherits="clCatchAllUDP" -->
<p>UDP mode where all ordered packets are received, out of order packets are discarded.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_catch_all_no_u_d_p_8h_source.html">clCatchAllNoUDP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clCatchAllNoUDP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_catch_all_no_u_d_p.png" usemap="#clCatchAllNoUDP_map" alt=""/>
  <map id="clCatchAllNoUDP_map" name="clCatchAllNoUDP_map">
<area href="classcl_catch_all_u_d_p.html" alt="clCatchAllUDP" shape="rect" coords="0,112,111,136"/>
<area href="classcl_shared_u_d_p.html" alt="clSharedUDP" shape="rect" coords="0,56,111,80"/>
<area href="classcl_shared_protocol.html" alt="clSharedProtocol" shape="rect" coords="0,0,111,24"/>
</map>
</div>

<p><a href="classcl_catch_all_no_u_d_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a0f0afccf0237b04676b9cb1cc460b7b8">clCatchAllNoUDP</a> (size_t numClients)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a8fec259a6e1598bb600672f9c59211f3">clCatchAllNoUDP</a> (const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#ad6eb8cb12e29758e295b69fe9c73a012">operator=</a> (const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a64c2a0db2dffeb144559bb2c134c4aa0">Clone</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#af80b84880abeb4cc701c4facd4391156">Reset</a> (size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a5b4b52daa2fe9319eb25481951a70818">Reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a85b8bad42a00da200b572fb8f8f142c5">DealWithData</a> (size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t operationID, size_t instanceID, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> recvFuncUDP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_send.html">clSharedSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#ab617cfaf8427e415c591518fe36b95af">GetSendObject</a> (const <a class="el" href="classcl_packet.html">clPacket</a> *packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a93dceb605e7c892975772958e91f44b4">GetProtocolMode</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a42c6c3dca9de2a8374acd134ad0aca3b">_Copy</a> (const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;copyMe)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classcl_status.html">clStatus</a>&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a50669cdeff504e9029f11480453748ab">sendCounter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classcl_status.html">clStatus</a>&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_catch_all_no_u_d_p.html#a05914d96351f77d9c2b94101f118398c">recvCounter</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>UDP mode where all ordered packets are received, out of order packets are discarded. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This UDP mode is known as 'catch all, no out of order'. <br/>
<br/>
</p>
<p>Packets sent have a prefix added which is a counter, which increases by one with every send operation <br/>
 On the receiving end the highest counter prefix received is recorded and if a packet is received with an older counter prefix, it is assumed to be out of order and thus is discarded.<br/>
<br/>
</p>
<p>This UDP mode is the most flexible and useful and is recommended for most purposes. <br/>
<br/>
</p>
<p>The prefix is 32 bits for the 32 bit version of this plugin and 64 bits for the 64 bit version. <br/>
<br/>
</p>
<p>This class is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f0afccf0237b04676b9cb1cc460b7b8"></a><!-- doxytag: member="clCatchAllNoUDP::clCatchAllNoUDP" ref="a0f0afccf0237b04676b9cb1cc460b7b8" args="(size_t numClients)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clCatchAllNoUDP::clCatchAllNoUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numClients</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a class="anchor" id="a8fec259a6e1598bb600672f9c59211f3"></a><!-- doxytag: member="clCatchAllNoUDP::clCatchAllNoUDP" ref="a8fec259a6e1598bb600672f9c59211f3" args="(const clCatchAllNoUDP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clCatchAllNoUDP::clCatchAllNoUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a42c6c3dca9de2a8374acd134ad0aca3b"></a><!-- doxytag: member="clCatchAllNoUDP::_Copy" ref="a42c6c3dca9de2a8374acd134ad0aca3b" args="(const clCatchAllNoUDP &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clCatchAllNoUDP::_Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies <em>copyMe</em> into this object (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64c2a0db2dffeb144559bb2c134c4aa0"></a><!-- doxytag: member="clCatchAllNoUDP::Clone" ref="a64c2a0db2dffeb144559bb2c134c4aa0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> * clCatchAllNoUDP::Clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a deep copy of this object </dd></dl>

<p>Reimplemented from <a class="el" href="classcl_catch_all_u_d_p.html#a0e329ffd49f681f9e81938d20ac1ab06">clCatchAllUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a85b8bad42a00da200b572fb8f8f142c5"></a><!-- doxytag: member="clCatchAllNoUDP::DealWithData" ref="a85b8bad42a00da200b572fb8f8f142c5" args="(size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t operationID, size_t instanceID, clInstanceCore::RecvFunc recvFuncUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clCatchAllNoUDP::DealWithData </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>udpRecvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deals with a recently received UDP packet <br/>
 Packet must be deemed new (based on its clock value) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread that packet was received on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>size of packet stored in <em>buffer</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>where newly received packet is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that packet was received from, must be 0 in client state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>instance that packet was received on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpRecvFunc</em>&nbsp;</td><td>method will be executed and data not added to the queue if this is non NULL </td></tr>
  </table>
  </dd>
</dl>

<p><p>If the current counter value is vastly different to the last counter value, then it is likely that the maximum for the counter value was reached, and so it looped back round to 0 </p>
</p>

</div>
</div>
<a class="anchor" id="a93dceb605e7c892975772958e91f44b4"></a><!-- doxytag: member="clCatchAllNoUDP::GetProtocolMode" ref="a93dceb605e7c892975772958e91f44b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clCatchAllNoUDP::GetProtocolMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP mode that this class represents </dd></dl>

<p>Reimplemented from <a class="el" href="classcl_catch_all_u_d_p.html#adacc5977909396017910dcb3ab44c395">clCatchAllUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ab617cfaf8427e415c591518fe36b95af"></a><!-- doxytag: member="clCatchAllNoUDP::GetSendObject" ref="ab617cfaf8427e415c591518fe36b95af" args="(const clPacket *packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_send.html">clSharedSend</a> * clCatchAllNoUDP::GetSendObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a send object with a prefix which is a counter that increments with every send operation (by 1) </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send. The return value of GetClientFrom on this object MUST BE the client that this object is being sent to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>true if sending should be synchronous, false if sending should be asynchronous </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcl_catch_all_u_d_p.html#a6651f3534e139451f9bbabe16e00671c">clCatchAllUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ad6eb8cb12e29758e295b69fe9c73a012"></a><!-- doxytag: member="clCatchAllNoUDP::operator=" ref="ad6eb8cb12e29758e295b69fe9c73a012" args="(const clCatchAllNoUDP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp; clCatchAllNoUDP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_catch_all_no_u_d_p.html">clCatchAllNoUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment operator (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5b4b52daa2fe9319eb25481951a70818"></a><!-- doxytag: member="clCatchAllNoUDP::Reset" ref="a5b4b52daa2fe9319eb25481951a70818" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clCatchAllNoUDP::Reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset all client's packet store </p>

<p>Reimplemented from <a class="el" href="classcl_catch_all_u_d_p.html#ab73dbee966b725003aa44dcf88eb89d5">clCatchAllUDP</a>.</p>

</div>
</div>
<a class="anchor" id="af80b84880abeb4cc701c4facd4391156"></a><!-- doxytag: member="clCatchAllNoUDP::Reset" ref="af80b84880abeb4cc701c4facd4391156" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clCatchAllNoUDP::Reset </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset to as if object had just been constructed </p>

<p>Reimplemented from <a class="el" href="classcl_catch_all_u_d_p.html#ad4530482136db2ffffff7fdac7f2e00f">clCatchAllUDP</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a05914d96351f77d9c2b94101f118398c"></a><!-- doxytag: member="clCatchAllNoUDP::recvCounter" ref="a05914d96351f77d9c2b94101f118398c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classcl_status.html">clStatus</a>&lt;size_t&gt; &gt; <a class="el" href="classcl_catch_all_no_u_d_p.html#a05914d96351f77d9c2b94101f118398c">clCatchAllNoUDP::recvCounter</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores the largest counter received for each client. Packets received with lower counters are discarded as they are deemed old </p>

</div>
</div>
<a class="anchor" id="a50669cdeff504e9029f11480453748ab"></a><!-- doxytag: member="clCatchAllNoUDP::sendCounter" ref="a50669cdeff504e9029f11480453748ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classcl_status.html">clStatus</a>&lt;size_t&gt; &gt; <a class="el" href="classcl_catch_all_no_u_d_p.html#a50669cdeff504e9029f11480453748ab">clCatchAllNoUDP::sendCounter</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores counters for each client which are incremented by 1 with every send operation <br/>
 These counters are inserted at the start of each packet and are used to determine the age of the packet, where newer the youngest packet has the highest prefix </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_catch_all_no_u_d_p_8h_source.html">clCatchAllNoUDP.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clCatchAllNoUDP.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:06 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
