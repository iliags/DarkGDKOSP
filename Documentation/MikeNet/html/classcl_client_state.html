<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clClientState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clClientState Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clClientState" --><!-- doxytag: inherits="clInstanceTCP,clInstanceUDP" -->
<p>Client instance, designed to communicate with servers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_client_state_8h_source.html">clClientState.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clClientState:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_client_state.png" usemap="#clClientState_map" alt=""/>
  <map id="clClientState_map" name="clClientState_map">
<area href="classcl_instance_t_c_p.html" alt="clInstanceTCP" shape="rect" coords="0,56,97,80"/>
<area href="classcl_instance_u_d_p.html" alt="clInstanceUDP" shape="rect" coords="107,56,204,80"/>
<area href="classcl_instance_core.html" alt="clInstanceCore" shape="rect" coords="0,0,97,24"/>
</map>
</div>

<p><a href="classcl_client_state-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a114e8dfb1061a13b207b8e54e4ee4830">GetRecvSizeMinTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ae68242becb3d84695b2f7112633a1ecc">GetRecvSizeMinUDP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#af5273cc686055cb060b4ff2c2e3cc237">GetConnectTimeout</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a080073cb5cd9bc23f9ba54f1ed757e41">Connect</a> (const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;addressTCP, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;addressUDP, size_t connectionTimeout, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a492c1690020513b638c0237ef493d5b3">_Handshake</a> (size_t paraTimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a82686bcb0526d9499a12346a1c58d73f">PollConnect</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#abf445888bd4e92122504654e7c74b5fb">StopConnect</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#aa77a903cb79356329a96d3b3cd5e5f79">ClientConnected</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#af30b846a7bed7581322a639758f386f6">ErrorOccurred</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a0896fc48ea83b9d2c9db5c4fbb520cd0">DoRecvUDP</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a00fdb8cf2f551822cff470830e29fcdd">DoRecvTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#abfab264fa6f8a55abf4b4c5d645deba2">DoRawSendUDP</a> (const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a063ef9858fccf0f90d50a387e91c3bec">clClientState</a> (size_t connectTimeout, <a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *<a class="el" href="classcl_client_state.html#ac58716d4f5c67f88577540d0272f0804">socketTCP</a>, <a class="el" href="classcl_socket_u_d_p.html">clSocketUDP</a> *<a class="el" href="classcl_instance_u_d_p.html#adabf31cb357eb5dada6ad5c8e57c611e">socketUDP</a>, bool <a class="el" href="classcl_instance_t_c_p.html#a4a35647e926d2c2c5abec877242f69fa">handshakeEnabled</a>, unsigned int <a class="el" href="classcl_instance_core.html#a05be31d3ac12930f23fb1a06c25b225c">sendTimeout</a>=INFINITE, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> <a class="el" href="classcl_instance_t_c_p.html#aae4ec2a4dd6ac904c67e53c0620e2843">recvFuncTCP</a>=NULL, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> <a class="el" href="classcl_instance_u_d_p.html#a71fd288aaec92fa83f45060bc15d1f1e">recvFuncUDP</a>=NULL, INT_PTR <a class="el" href="classcl_client_state.html#ab8feb66a89295b2ee744245aad8e86ba">decryptKey</a>=NULL, size_t <a class="el" href="classcl_instance_core.html#ad3de74dbad74098dc2f010806186bf7f">instanceID</a>=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a008f55bf780aca9e02eecea61b83c19c">clClientState</a> (size_t connectTimeout, const <a class="el" href="classcl_instance_profile.html">clInstanceProfile</a> &amp;profile, size_t <a class="el" href="classcl_instance_core.html#ad3de74dbad74098dc2f010806186bf7f">instanceID</a>=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#add703eb88e78da6ed99323dc9607aa8c">~clClientState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a7f4bf7e8f386b15f7665929212f56a4b">GetGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#acbd393fc852bbdcde7dc119342ce3edc">GetMaxPacketSizeTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a71c061f87888b1c8f45e1edec5564f4f">GetRecvBufferLengthTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a25553b01d03b04f99f08edcddb5fe767">GetPartialPacketCurrentSizeTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a20219c44a86cfaf56479a9ab2fc673ad">SetMaxPacketSizeTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, size_t newMaxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ab209ee2149fe08f9c8c9ff559ce230e3">GetAutoResizeTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a33cd6903e101dfd02128a8a98bcbcb76">SetAutoResizeTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, bool newAutoResizeTCP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a886d8ef782d724132a514ba9d48ba03d">GetProtocolModeTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a906abc63036242a2b59bf4566fbb7663">GetLocalAddressTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#aa7660aef340c674ef324e54f8f032968">GetConnectAddressTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a37f4fc080494f38943b43c5713846ff3">FlushRecvTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a1694f4da0940ca63a28deb5a5bb6fa1e">GetPacketAmountTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ab267f5f6408b8bd333557c262135210c">ShutdownTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a0da4458de7279931aa41c9b1850c70b3">GetPacketFromStoreTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, <a class="el" href="classcl_packet.html">clPacket</a> *destination)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a4aeba181b4a720a0d545c0e25caa205d">SendTCP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ab05b47be38699babada23180023604f9">SendUDP</a> (size_t threadID, size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#aff27b2186960a4b8279e77ba8df634d0">SendToUDP</a> (size_t threadID, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;address, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#aa6eebf5f365dc2afe8617973a9f40049">DealCompletion</a> (size_t threadID, <a class="el" href="classcl_completion_key.html">clCompletionKey</a> &amp;completionKey, DWORD bytes, const WSAOVERLAPPED *overlapped, BOOL success)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#afd1442e1b167bb89c198582804bdb7c9">SetContainer</a> (<a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *container)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a0941e83ecbd7a734a83e9759e622c7a3">recvSizeMinUDP</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ac4ab48651bcfd9249d396771f9bb7f58">recvSizeMinTCP</a> = 33</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ae6a4b95bd73627ae1f3c7a512eb13112">_CheckClientID</a> (size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a>, size_t line, const char *file) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a913aba070282c4e7c3de92d8e3de3d9a">init</a> (size_t connectTimeout, INT_PTR <a class="el" href="classcl_client_state.html#ab8feb66a89295b2ee744245aad8e86ba">decryptKey</a>)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INT_PTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ab8feb66a89295b2ee744245aad8e86ba">decryptKey</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a3aaf9947d4f362c07cacc6f5ea89ba82">recvSizeUDP</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#aad6e8fb3e4c918cdd7596a1e5b7e8e5b">timeoutMilliseconds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_status.html">clStatus</a><br class="typebreak"/>
&lt; <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a97b10049b464fb11544d22bdb03ada4f">connectionStatus</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ac58716d4f5c67f88577540d0272f0804">socketTCP</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clientID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a8a137584141df71f35ef6af70d1ec365">handshake</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcl_error.html">clError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#ad6d910b86977c982fe7d60689289fada">handshakeError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_client_state.html#a5d655bd30abb4dc85baf932cafec8d41">handshakeErrorOccurred</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Client instance, designed to communicate with servers. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This instance uses TCP and UDP to communicate with servers. Most commonly it will be used to communicate with another entity running a <a class="el" href="classcl_server_state.html" title="Server instance, designed to communicate with clients.">clServerState</a> instance. However, this instance can also communicate with non DarkNet entities such as web servers. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a063ef9858fccf0f90d50a387e91c3bec"></a><!-- doxytag: member="clClientState::clClientState" ref="a063ef9858fccf0f90d50a387e91c3bec" args="(size_t connectTimeout, clSocketTCP *socketTCP, clSocketUDP *socketUDP, bool handshakeEnabled, unsigned int sendTimeout=INFINITE, clInstanceCore::RecvFunc recvFuncTCP=NULL, clInstanceCore::RecvFunc recvFuncUDP=NULL, INT_PTR decryptKey=NULL, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clClientState::clClientState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_u_d_p.html">clSocketUDP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>p_sendTimeout</em> = <code>INFINITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>p_recvFuncTCP</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>p_recvFuncUDP</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT_PTR&nbsp;</td>
          <td class="paramname"> <em>p_decryptKey</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_connectTimeout</em>&nbsp;</td><td>length of time in milliseconds that handshaking process should be allowed before aborting the process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_socketTCP</em>&nbsp;</td><td>socket to use to send and receive TCP data. This pointer and its data is now owned by this object and should not be used elsewhere. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_socketUDP</em>&nbsp;</td><td>socket to use to send and receive UDP data, NULL if UDP is disabled. This pointer and its data is now owned by this object and should not be used elsewhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>true if the TCP handshaking process is enabled, false if not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_sendTimeout</em>&nbsp;</td><td>length of time in milliseconds to wait for a send operation to complete before disconnecting client (optional, default INFINITE) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_recvFuncTCP</em>&nbsp;</td><td>method to be executed when new TCP packets are received (optional, default NULL) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p_recvFuncUDP</em>&nbsp;</td><td>method to be executed when new UDP packets are received (optional, default NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_decryptKey</em>&nbsp;</td><td>pointer (casted to long long int) to a <a class="el" href="classcl_encrypt_key.html">clEncryptKey</a> object to be used to decrypt UDP data (optional, default NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>unique identifier for instance (optional, default 0) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if p_socketTCP-&gt;GetRecvBufferLength() &lt; <a class="el" href="classcl_client_state.html#a114e8dfb1061a13b207b8e54e4ee4830">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a008f55bf780aca9e02eecea61b83c19c"></a><!-- doxytag: member="clClientState::clClientState" ref="a008f55bf780aca9e02eecea61b83c19c" args="(size_t connectTimeout, const clInstanceProfile &amp;profile, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clClientState::clClientState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_instance_profile.html">clInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor, using profile instead of individual parameters </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_connectTimeout</em>&nbsp;</td><td>length of time in milliseconds that handshaking process should be allowed before aborting the process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_profile</em>&nbsp;</td><td>instance profile containing parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>unique identifier for instance (optional, default 0) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if p_profile.GetRecvSizeTCP() &lt; <a class="el" href="classcl_client_state.html#a114e8dfb1061a13b207b8e54e4ee4830">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add703eb88e78da6ed99323dc9607aa8c"></a><!-- doxytag: member="clClientState::~clClientState" ref="add703eb88e78da6ed99323dc9607aa8c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clClientState::~clClientState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae6a4b95bd73627ae1f3c7a512eb13112"></a><!-- doxytag: member="clClientState::_CheckClientID" ref="ae6a4b95bd73627ae1f3c7a512eb13112" args="(size_t clientID, size_t line, const char *file) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::_CheckClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks that client ID is within range </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>client ID to check, can be 0 because this is for packets received from server in UDP mode per client or per client, per operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>line number of method call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file</em>&nbsp;</td><td>file name of method call</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID &gt; maxClients </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a492c1690020513b638c0237ef493d5b3"></a><!-- doxytag: member="clClientState::_Handshake" ref="a492c1690020513b638c0237ef493d5b3" args="(size_t paraTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clClientState::_Handshake </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>paraTimeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread that negotiates a connection with the server. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paraTimeout</em>&nbsp;</td><td>length of time in milliseconds that handshaking process should be allowed before aborting the process</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Receive operations are canceled when the thread who initiated them exits this means that initiating a receive operation that is not guaranteed to have completed before this thread exits is wrong. Note that if the operation completes the completion port will then initiate a new one which is not bound to this thread.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da91a3fd8751354e5c4f32181268627d9f">clNetworkingUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da4ab4eb1108087cf8c17bff8585cf8270">clNetworkingUtility::TIMED_OUT</a> if the handshaking process timed out </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dafafd46790b41dc51910c2cc598024480">clNetworkingUtility::CONNECTION_ERROR</a> if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="aa77a903cb79356329a96d3b3cd5e5f79"></a><!-- doxytag: member="clClientState::ClientConnected" ref="aa77a903cb79356329a96d3b3cd5e5f79" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clClientState::ClientConnected </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to query the status of a clients connection. <br/>
 This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da91a3fd8751354e5c4f32181268627d9f">clNetworkingUtility::CONNECTED</a>: fully connected </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da7ea7f5aa34e94ec65b905c2a37610583">clNetworkingUtility::NOT_CONNECTED</a>: not connected at all </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6daf36e05d04ad267b00184a32d654c3989">clNetworkingUtility::NO_RECV</a>: connected but new data cannot be received because <code>Shutdown</code> has been used by recipient (only possible if graceful disconnect is enabled) </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dab8241425bb2dc77be7422346559bbb30">clNetworkingUtility::NO_SEND</a>: connected but data cannot be sent because <code>Shutdown</code> has been used (only possible if graceful disconnect is enabled) </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da049f6833fe3ed9d08cfe5047078b73e3">clNetworkingUtility::NO_SEND_RECV</a>: connected but data cannot be sent or received because <code>Shutdown</code> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if graceful disconnect is enabled) </dd></dl>

</div>
</div>
<a class="anchor" id="a080073cb5cd9bc23f9ba54f1ed757e41"></a><!-- doxytag: member="clClientState::Connect" ref="a080073cb5cd9bc23f9ba54f1ed757e41" args="(const clSingleAddr &amp;addressTCP, const clSingleAddr &amp;addressUDP, size_t connectionTimeout, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clClientState::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>connectionTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to server. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addressTCP</em>&nbsp;</td><td>TCP IP and port of server that we should attempt to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressUDP</em>&nbsp;</td><td>UDP IP and port of server that we should attempt to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectionTimeout</em>&nbsp;</td><td>length in milliseconds that connection attempt should last before it should abort (applies to non blocking too) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the connection attempt is done synchronously and the method will not return until the connection attempt completes or fails. If false the connection attempt is done asynchronously and the method will return straight away, PollConnect and StopConnect should then be used to manage the connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da91a3fd8751354e5c4f32181268627d9f">clNetworkingUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da4ab4eb1108087cf8c17bff8585cf8270">clNetworkingUtility::TIMED_OUT</a> if the handshaking process timed out </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dafafd46790b41dc51910c2cc598024480">clNetworkingUtility::CONNECTION_ERROR</a> if an error occurred </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da1a0333d6bbf1103cfcdfa4621133e3a4">clNetworkingUtility::REFUSED</a> if the server is full and so the connection attempt failed </dd></dl>

</div>
</div>
<a class="anchor" id="aa6eebf5f365dc2afe8617973a9f40049"></a><!-- doxytag: member="clClientState::DealCompletion" ref="aa6eebf5f365dc2afe8617973a9f40049" args="(size_t threadID, clCompletionKey &amp;completionKey, DWORD bytes, const WSAOVERLAPPED *overlapped, BOOL success)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::DealCompletion </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_completion_key.html">clCompletionKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>completionKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSAOVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>overlapped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>success</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When send and receive operations are completed on this instance, this method is called</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionKey</em>&nbsp;</td><td>reference to completion key which provides information about the completed operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>number of bytes of data transferred in operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlapped</em>&nbsp;</td><td>pointer to overlapped operation associated with event </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>success</em>&nbsp;</td><td>TRUE if no error occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_core.html#afb72728b46b08c2928845cd67acc238d">clInstanceCore</a>.</p>

</div>
</div>
<a class="anchor" id="abfab264fa6f8a55abf4b4c5d645deba2"></a><!-- doxytag: member="clClientState::DoRawSendUDP" ref="abfab264fa6f8a55abf4b4c5d645deba2" args="(const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int clClientState::DoRawSendUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls socketTCP-&gt;RawSend and deals with errors in a client specific way <br/>
 Use this INSTEAD OF socketTCP-&gt;RawSend, never use socketTCP-&gt;RawSend directly</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if any send operation completed successfully instantly </dd>
<dd>
1 if any send operation was started, but has not yet completed </dd>
<dd>
-1 if any send operation failed </dd>
<dd>
-2 if any send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="a00fdb8cf2f551822cff470830e29fcdd"></a><!-- doxytag: member="clClientState::DoRecvTCP" ref="a00fdb8cf2f551822cff470830e29fcdd" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::DoRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls socketTCP-&gt;Recv and deals with errors in a client specific way <br/>
 Use this INSTEAD OF socketTCP-&gt;Recv, never use socketTCP-&gt;Recv directly</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0896fc48ea83b9d2c9db5c4fbb520cd0"></a><!-- doxytag: member="clClientState::DoRecvUDP" ref="a0896fc48ea83b9d2c9db5c4fbb520cd0" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::DoRecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls socketUDP-&gt;Recv and deals with errors in a client specific way <br/>
 Use this INSTEAD OF socketUDP-&gt;Recv, never use socketUDP-&gt;Recv directly</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this method </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_u_d_p.html#ac481cdb9cb825fd303acf8a16da332a2">clInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="af30b846a7bed7581322a639758f386f6"></a><!-- doxytag: member="clClientState::ErrorOccurred" ref="af30b846a7bed7581322a639758f386f6" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::ErrorOccurred </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deals with error <br/>
 Signals instance to be shutdown, ClientConnected will do this when it is next called <br/>
 The instance is not shutdown directly because it is important that instance shutdown is done by the main process and not by a worker thread (a worker thread may call this method) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using method </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_core.html#ad5359146ac131598d7f6b86e10577738">clInstanceCore</a>.</p>

</div>
</div>
<a class="anchor" id="a37f4fc080494f38943b43c5713846ff3"></a><!-- doxytag: member="clClientState::FlushRecvTCP" ref="a37f4fc080494f38943b43c5713846ff3" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all fully received TCP packets from the packet queue <br/>
 Has no impact on the partial packet store </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab209ee2149fe08f9c8c9ff559ce230e3"></a><!-- doxytag: member="clClientState::GetAutoResizeTCP" ref="ab209ee2149fe08f9c8c9ff559ce230e3" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clClientState::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7660aef340c674ef324e54f8f032968"></a><!-- doxytag: member="clClientState::GetConnectAddressTCP" ref="aa7660aef340c674ef324e54f8f032968" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clClientState::GetConnectAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="af5273cc686055cb060b4ff2c2e3cc237"></a><!-- doxytag: member="clClientState::GetConnectTimeout" ref="af5273cc686055cb060b4ff2c2e3cc237" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetConnectTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>length of time in milliseconds that handshaking process should be allowed before aborting the process </dd></dl>

</div>
</div>
<a class="anchor" id="a7f4bf7e8f386b15f7665929212f56a4b"></a><!-- doxytag: member="clClientState::GetGracefulDisconnectEnabled" ref="a7f4bf7e8f386b15f7665929212f56a4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clClientState::GetGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if true graceful disconnection is possible, where data is allowed to finish sending and receiving before the connection is closed </dd></dl>

</div>
</div>
<a class="anchor" id="a906abc63036242a2b59bf4566fbb7663"></a><!-- doxytag: member="clClientState::GetLocalAddressTCP" ref="a906abc63036242a2b59bf4566fbb7663" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clClientState::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information. This reference should remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="acbd393fc852bbdcde7dc119342ce3edc"></a><!-- doxytag: member="clClientState::GetMaxPacketSizeTCP" ref="acbd393fc852bbdcde7dc119342ce3edc" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </dd></dl>

</div>
</div>
<a class="anchor" id="a1694f4da0940ca63a28deb5a5bb6fa1e"></a><!-- doxytag: member="clClientState::GetPacketAmountTCP" ref="a1694f4da0940ca63a28deb5a5bb6fa1e" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetPacketAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of fully received UDP packets in the packet store </dd></dl>

</div>
</div>
<a class="anchor" id="a0da4458de7279931aa41c9b1850c70b3"></a><!-- doxytag: member="clClientState::GetPacketFromStoreTCP" ref="a0da4458de7279931aa41c9b1850c70b3" args="(size_t threadID, size_t clientID, clPacket *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetPacketFromStoreTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a complete packet from the TCP packet store and copies it into <em>destination</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>destination to copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call </dd></dl>

</div>
</div>
<a class="anchor" id="a25553b01d03b04f99f08edcddb5fe767"></a><!-- doxytag: member="clClientState::GetPartialPacketCurrentSizeTCP" ref="a25553b01d03b04f99f08edcddb5fe767" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetPartialPacketCurrentSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current size of the TCP partial packet being received <br/>
 i.e. the number of bytes of the packet that have been received </dd></dl>

</div>
</div>
<a class="anchor" id="a886d8ef782d724132a514ba9d48ba03d"></a><!-- doxytag: member="clClientState::GetProtocolModeTCP" ref="a886d8ef782d724132a514ba9d48ba03d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clClientState::GetProtocolModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>protocol mode in use by instance </dd></dl>

</div>
</div>
<a class="anchor" id="a71c061f87888b1c8f45e1edec5564f4f"></a><!-- doxytag: member="clClientState::GetRecvBufferLengthTCP" ref="a71c061f87888b1c8f45e1edec5564f4f" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetRecvBufferLengthTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF used by the TCP socket. <br/>
 This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a114e8dfb1061a13b207b8e54e4ee4830"></a><!-- doxytag: member="clClientState::GetRecvSizeMinTCP" ref="a114e8dfb1061a13b207b8e54e4ee4830" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetRecvSizeMinTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The smallest acceptable TCP packet size that can be received </p>

</div>
</div>
<a class="anchor" id="ae68242becb3d84695b2f7112633a1ecc"></a><!-- doxytag: member="clClientState::GetRecvSizeMinUDP" ref="ae68242becb3d84695b2f7112633a1ecc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clClientState::GetRecvSizeMinUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The smallest acceptable UDP packet size that can be received </p>

<p>Implements <a class="el" href="classcl_instance_u_d_p.html#a180b09957ac5b22a7a298f2615f1d656">clInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a913aba070282c4e7c3de92d8e3de3d9a"></a><!-- doxytag: member="clClientState::init" ref="a913aba070282c4e7c3de92d8e3de3d9a" args="(size_t connectTimeout, INT_PTR decryptKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::init </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT_PTR&nbsp;</td>
          <td class="paramname"> <em>p_decryptKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes object, used by constructors </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_connectTimeout</em>&nbsp;</td><td>length of time in milliseconds that handshaking process should be allowed before aborting the process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_decryptKey</em>&nbsp;</td><td>pointer (casted to long long int) to a <a class="el" href="classcl_encrypt_key.html">clEncryptKey</a> object to be used to decrypt UDP data </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>socketUDP must be initialized before using this method </dd></dl>

</div>
</div>
<a class="anchor" id="a82686bcb0526d9499a12346a1c58d73f"></a><!-- doxytag: member="clClientState::PollConnect" ref="a82686bcb0526d9499a12346a1c58d73f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clClientState::PollConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to determine status of handshaking process. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da8ffcc0a72b9ea4ec527c5bc89c2c890e">clNetworkingUtility::STILL_CONNECTING</a> if the handshaking process is in progress still </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da91a3fd8751354e5c4f32181268627d9f">clNetworkingUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da4ab4eb1108087cf8c17bff8585cf8270">clNetworkingUtility::TIMED_OUT</a> if the handshaking process timed out </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dafafd46790b41dc51910c2cc598024480">clNetworkingUtility::CONNECTION_ERROR</a> if an error occurred </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da1a0333d6bbf1103cfcdfa4621133e3a4">clNetworkingUtility::REFUSED</a> if the server is full and so the connection attempt failed </dd></dl>

</div>
</div>
<a class="anchor" id="a4aeba181b4a720a0d545c0e25caa205d"></a><!-- doxytag: member="clClientState::SendTCP" ref="a4aeba181b4a720a0d545c0e25caa205d" args="(size_t threadID, size_t clientID, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clClientState::SendTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via TCP to specified client </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="aff27b2186960a4b8279e77ba8df634d0"></a><!-- doxytag: member="clClientState::SendToUDP" ref="aff27b2186960a4b8279e77ba8df634d0" args="(size_t threadID, const clSingleAddr &amp;address, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clClientState::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via UDP to <em>address</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>remote address to send to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

<p>Implements <a class="el" href="classcl_instance_u_d_p.html#a2a429c537132c699c920b3deb2b96a43">clInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ab05b47be38699babada23180023604f9"></a><!-- doxytag: member="clClientState::SendUDP" ref="ab05b47be38699babada23180023604f9" args="(size_t threadID, size_t clientID, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clClientState::SendUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via UDP using this socket </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

<p>Implements <a class="el" href="classcl_instance_u_d_p.html#af56fb711b4bf6d5152c68912a3f10f13">clInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a33cd6903e101dfd02128a8a98bcbcb76"></a><!-- doxytag: member="clClientState::SetAutoResizeTCP" ref="a33cd6903e101dfd02128a8a98bcbcb76" args="(size_t threadID, size_t clientID, bool newAutoResizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd1442e1b167bb89c198582804bdb7c9"></a><!-- doxytag: member="clClientState::SetContainer" ref="afd1442e1b167bb89c198582804bdb7c9" args="(clInstanceContainer *container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::SetContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classcl_instance_container.html" title="Stores instances, allowing safe shutdown of instance.">clInstanceContainer</a> object containing this instance, <a class="el" href="classcl_instance_container.html" title="Stores instances, allowing safe shutdown of instance.">clInstanceContainer</a> should pass pointer to itself </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>container</em>&nbsp;</td><td>instance container that owns this instance </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcl_instance_u_d_p.html#a2b1ca50c2b076e37fecbff3269083c67">clInstanceUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a20219c44a86cfaf56479a9ab2fc673ad"></a><!-- doxytag: member="clClientState::SetMaxPacketSizeTCP" ref="a20219c44a86cfaf56479a9ab2fc673ad" args="(size_t threadID, size_t clientID, size_t newMaxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::SetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newMaxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manually changes the maximum packet size that can be received </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newMaxSize</em>&nbsp;</td><td>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if newMaxSize &lt; <a class="el" href="classcl_client_state.html#a114e8dfb1061a13b207b8e54e4ee4830">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab267f5f6408b8bd333557c262135210c"></a><!-- doxytag: member="clClientState::ShutdownTCP" ref="ab267f5f6408b8bd333557c262135210c" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::ShutdownTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops sending on TCP socket so that all further send operations will fail <br/>
 All data sent up till now will be received by recipient. This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf445888bd4e92122504654e7c74b5fb"></a><!-- doxytag: member="clClientState::StopConnect" ref="abf445888bd4e92122504654e7c74b5fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clClientState::StopConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancels a handshaking process. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>PollConnect should not be used after this command, it will fail </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4153db8a239f862cbd61bf8e75e25794"></a><!-- doxytag: member="clClientState::clientID" ref="a4153db8a239f862cbd61bf8e75e25794" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_client_state.html#a4153db8a239f862cbd61bf8e75e25794">clClientState::clientID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ID of client, filled during the handshaking process </p>

</div>
</div>
<a class="anchor" id="a97b10049b464fb11544d22bdb03ada4f"></a><!-- doxytag: member="clClientState::connectionStatus" ref="a97b10049b464fb11544d22bdb03ada4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_status.html">clStatus</a>&lt;<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&gt; <a class="el" href="classcl_client_state.html#a97b10049b464fb11544d22bdb03ada4f">clClientState::connectionStatus</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the state of the connection process <br/>
 Can be either: <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dabf4d0d3d12524780c743ee1262fbc278">clNetworkingUtility::CONNECTING</a>: connection is in progress <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dafad5daa966b363b76ea786a199121a28">clNetworkingUtility::DISCONNECTING</a>: connection was aborted but needs to be cleaned up <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da7ea7f5aa34e94ec65b905c2a37610583">clNetworkingUtility::NOT_CONNECTED</a>: connection is not in progress </p>

</div>
</div>
<a class="anchor" id="ab8feb66a89295b2ee744245aad8e86ba"></a><!-- doxytag: member="clClientState::decryptKey" ref="ab8feb66a89295b2ee744245aad8e86ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT_PTR <a class="el" href="classcl_client_state.html#ab8feb66a89295b2ee744245aad8e86ba">clClientState::decryptKey</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary store to communicate with handshaking thread, which may need to know this when creating modeUDP object </p>

</div>
</div>
<a class="anchor" id="a8a137584141df71f35ef6af70d1ec365"></a><!-- doxytag: member="clClientState::handshake" ref="a8a137584141df71f35ef6af70d1ec365" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE <a class="el" href="classcl_client_state.html#a8a137584141df71f35ef6af70d1ec365">clClientState::handshake</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores handle to connect handshake thread so that result of thread execution can be caught </p>

</div>
</div>
<a class="anchor" id="ad6d910b86977c982fe7d60689289fada"></a><!-- doxytag: member="clClientState::handshakeError" ref="ad6d910b86977c982fe7d60689289fada" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcl_error.html">clError</a> <a class="el" href="classcl_client_state.html#ad6d910b86977c982fe7d60689289fada">clClientState::handshakeError</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores error that occurred in handshake thread so that it can be thrown from a user function </p>

</div>
</div>
<a class="anchor" id="a5d655bd30abb4dc85baf932cafec8d41"></a><!-- doxytag: member="clClientState::handshakeErrorOccurred" ref="a5d655bd30abb4dc85baf932cafec8d41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcl_client_state.html#a5d655bd30abb4dc85baf932cafec8d41">clClientState::handshakeErrorOccurred</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if an error occurred in handshake thread </p>

</div>
</div>
<a class="anchor" id="ac4ab48651bcfd9249d396771f9bb7f58"></a><!-- doxytag: member="clClientState::recvSizeMinTCP" ref="ac4ab48651bcfd9249d396771f9bb7f58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcl_client_state.html#ac4ab48651bcfd9249d396771f9bb7f58">clClientState::recvSizeMinTCP</a> = 33<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum TCP buffer size necessary to maintain normal operations </p>

</div>
</div>
<a class="anchor" id="a0941e83ecbd7a734a83e9759e622c7a3"></a><!-- doxytag: member="clClientState::recvSizeMinUDP" ref="a0941e83ecbd7a734a83e9759e622c7a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcl_client_state.html#a0941e83ecbd7a734a83e9759e622c7a3">clClientState::recvSizeMinUDP</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum UDP buffer size necessary to maintain normal operations </p>

</div>
</div>
<a class="anchor" id="a3aaf9947d4f362c07cacc6f5ea89ba82"></a><!-- doxytag: member="clClientState::recvSizeUDP" ref="a3aaf9947d4f362c07cacc6f5ea89ba82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_client_state.html#a3aaf9947d4f362c07cacc6f5ea89ba82">clClientState::recvSizeUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary store to communicate with handshaking thread, which may need to know this when creating modeUDP object </p>

</div>
</div>
<a class="anchor" id="ac58716d4f5c67f88577540d0272f0804"></a><!-- doxytag: member="clClientState::socketTCP" ref="ac58716d4f5c67f88577540d0272f0804" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a>* <a class="el" href="classcl_client_state.html#ac58716d4f5c67f88577540d0272f0804">clClientState::socketTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Socket used to communicate with server via TCP </p>

</div>
</div>
<a class="anchor" id="aad6e8fb3e4c918cdd7596a1e5b7e8e5b"></a><!-- doxytag: member="clClientState::timeoutMilliseconds" ref="aad6e8fb3e4c918cdd7596a1e5b7e8e5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_client_state.html#aad6e8fb3e4c918cdd7596a1e5b7e8e5b">clClientState::timeoutMilliseconds</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum length of time that client would wait before giving up on connection process <br/>
 Exists to pass information to the handshaking thread </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_client_state_8h_source.html">clClientState.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clClientState.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:06 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
