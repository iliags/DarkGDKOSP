<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clPerClientUDP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clPerClientUDP Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clPerClientUDP" --><!-- doxytag: inherits="clSharedUDP" -->
<p>UDP mode where only in order packets are received, some in order packets may be discarded however.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_per_client_u_d_p_8h_source.html">clPerClientUDP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clPerClientUDP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_per_client_u_d_p.png" usemap="#clPerClientUDP_map" alt=""/>
  <map id="clPerClientUDP_map" name="clPerClientUDP_map">
<area href="classcl_shared_u_d_p.html" alt="clSharedUDP" shape="rect" coords="0,56,110,80"/>
<area href="classcl_shared_protocol.html" alt="clSharedProtocol" shape="rect" coords="0,0,110,24"/>
</map>
</div>

<p><a href="classcl_per_client_u_d_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a01f4f49f8c3aefd4a88f891b8346815c">clPerClientUDP</a> (size_t recvSize, size_t numClients, size_t numOperations, bool <a class="el" href="classcl_per_client_u_d_p.html#ae270ad0657e279032f9e1bebee3f0698">perOperation</a>, INT_PTR <a class="el" href="classcl_per_client_u_d_p.html#a997243e373a1d997f27b111d06cccd90">decryptKey</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#ab08cd50d1dda3900f42d99e15093deeb">~clPerClientUDP</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#abebbec5f47158b191db9108b824ab31d">clPerClientUDP</a> (const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a8401c5217b43d904b053e0fbcb0fa462">operator=</a> (const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a927ff441992e605aaa5caf2bcb0a19b6">Clone</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#ae7d279662aacd52fae6d64683820e653">Reset</a> (size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a650dc543709d94ea2826871a15e526f5">Reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#acf380c1466abb6941edb950801d09b20">DealWithData</a> (size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> recvFuncUDP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#ad56e31637dfbb161912701621da7ecf6">GetPacketAmount</a> (size_t clientID, size_t operationID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#ae5adb603508d2a61d53b95c48b077e73">GetPacketFromStore</a> (size_t clientID, size_t operationID, <a class="el" href="classcl_packet.html">clPacket</a> *destination)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">clock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a1b94d67fd8a10170e31f9b65c4901b0d">GetRecvCounter</a> (size_t clientID, size_t operationID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a97cce2497fa9687fa5854f2c0a3fc684">SetRecvCounter</a> (size_t clientID, size_t operationID, clock_t newCounter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_send.html">clSharedSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a33f25535cfef99e9abe9b2556928f364">GetSendObject</a> (const <a class="el" href="classcl_packet.html">clPacket</a> *packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#aa0f2be71b5dac611c2a6c6fd8b17c00a">GetProtocolMode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a3bfc57d56a06ce0a719d7c699029861b">GetNumOperations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a273adfddaf1db4ff56d6a17b10aa7674">GetNumClients</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a120350a3fece7004e731d883e1387426">_Copy</a> (const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;copyMe)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_store_vector.html">clStoreVector</a>&lt; <a class="el" href="classcl_store_vector.html">clStoreVector</a><br class="typebreak"/>
&lt; <a class="el" href="classcl_packet.html">clPacket</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a7ed46a6713cec6ebc3c788d7542bdc58">packetStore</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#ae270ad0657e279032f9e1bebee3f0698">perOperation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INT_PTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_per_client_u_d_p.html#a997243e373a1d997f27b111d06cccd90">decryptKey</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>UDP mode where only in order packets are received, some in order packets may be discarded however. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This UDP mode is most useful with slow languages which cannot deal with large numbers of packets. The UDP mode will only ever have one packet in its store, this will be the newest packet received. Due to the lack of a queue, the system cannot get clogged up dealing with too many packets.</p>
<p>The clock() value increments every millisecond and so acts as a counter. This should be changed to operate in the same way as <a class="el" href="classcl_catch_all_no_u_d_p.html" title="UDP mode where all ordered packets are received, out of order packets are discarded.">clCatchAllNoUDP</a> using an actual counter so that packet loss can be detected.</p>
<p>The prefix is 32 bits for the 32 bit version of this plugin and 64 bits for the 64 bit version.</p>
<p>This class is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a01f4f49f8c3aefd4a88f891b8346815c"></a><!-- doxytag: member="clPerClientUDP::clPerClientUDP" ref="a01f4f49f8c3aefd4a88f891b8346815c" args="(size_t recvSize, size_t numClients, size_t numOperations, bool perOperation, INT_PTR decryptKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clPerClientUDP::clPerClientUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numOperations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT_PTR&nbsp;</td>
          <td class="paramname"> <em>decryptKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>recvSize</em>&nbsp;</td><td>maximum size of UDP packet that can be received </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numClients</em>&nbsp;</td><td>number of clients that object needs to store received packets for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numOperations</em>&nbsp;</td><td>number of operations per client that object needs to store received packets for, ignored if <em>perOperation</em> is true </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perOperation</em>&nbsp;</td><td>if true operation ID will be extracted from packet and object is used in per client, per operation UDP mode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decryptKey</em>&nbsp;</td><td>ignored if NULL, otherwise represents memory address of <a class="el" href="classcl_encrypt_key.html">clEncryptKey</a> object used to decrypt incoming packets before reading them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab08cd50d1dda3900f42d99e15093deeb"></a><!-- doxytag: member="clPerClientUDP::~clPerClientUDP" ref="ab08cd50d1dda3900f42d99e15093deeb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clPerClientUDP::~clPerClientUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<a class="anchor" id="abebbec5f47158b191db9108b824ab31d"></a><!-- doxytag: member="clPerClientUDP::clPerClientUDP" ref="abebbec5f47158b191db9108b824ab31d" args="(const clPerClientUDP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clPerClientUDP::clPerClientUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a120350a3fece7004e731d883e1387426"></a><!-- doxytag: member="clPerClientUDP::_Copy" ref="a120350a3fece7004e731d883e1387426" args="(const clPerClientUDP &amp;copyMe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clPerClientUDP::_Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies <em>copyMe</em> into this object (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a927ff441992e605aaa5caf2bcb0a19b6"></a><!-- doxytag: member="clPerClientUDP::Clone" ref="a927ff441992e605aaa5caf2bcb0a19b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> * clPerClientUDP::Clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a deep copy of this object </dd></dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#a62267e9d085f8e6b72a91fadf4a55670">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="acf380c1466abb6941edb950801d09b20"></a><!-- doxytag: member="clPerClientUDP::DealWithData" ref="acf380c1466abb6941edb950801d09b20" args="(size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, clInstanceCore::RecvFunc recvFuncUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clPerClientUDP::DealWithData </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>udpRecvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deals with a recently received UDP packet <br/>
 Packet must be deemed new (based on its clock value) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread that packet was received on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>size of packet stored in <em>buffer</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>where newly received packet is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that packet was received from, 0 in client state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>instance that packet was received on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>udpRecvFunc</em>&nbsp;</td><td>method will be executed and data not added to the queue if this is non NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_shared_protocol.html#a2b6f3bd561af01c5ef02b06ebe24c5a0">clSharedProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a273adfddaf1db4ff56d6a17b10aa7674"></a><!-- doxytag: member="clPerClientUDP::GetNumClients" ref="a273adfddaf1db4ff56d6a17b10aa7674" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clPerClientUDP::GetNumClients </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of clients that this object can manage </dd></dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#afacd36fa8d2b7bb21bff349cf0c1b3c9">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a3bfc57d56a06ce0a719d7c699029861b"></a><!-- doxytag: member="clPerClientUDP::GetNumOperations" ref="a3bfc57d56a06ce0a719d7c699029861b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clPerClientUDP::GetNumOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of clients that this object can manage </dd>
<dd>
1 if in per client mode (not per client per operation) </dd></dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#a4018cccdd8593a0df78f7dd6f59c40c1">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ad56e31637dfbb161912701621da7ecf6"></a><!-- doxytag: member="clPerClientUDP::GetPacketAmount" ref="ad56e31637dfbb161912701621da7ecf6" args="(size_t clientID, size_t operationID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clPerClientUDP::GetPacketAmount </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of packets in the packet queue </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>operation ID of operation to check, ignored if <code>perOperation</code> is true </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID is out of bounds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if operationID is out of bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if a newly received packet exists in the packet queue for the specified clientID and operationID, 0 if not </dd></dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#ac27f28fb266c9faaf44ee7e515ab0727">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ae5adb603508d2a61d53b95c48b077e73"></a><!-- doxytag: member="clPerClientUDP::GetPacketFromStore" ref="ae5adb603508d2a61d53b95c48b077e73" args="(size_t clientID, size_t operationID, clPacket *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clPerClientUDP::GetPacketFromStore </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies a packet from the packet store into <em>destination</em> and clears the original packet indicating that it has been transferred to user </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>operation ID of operation to use, ignored if <code>perOperation</code> is true </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>pointer to a <a class="el" href="classcl_packet.html" title="Efficiently and safely stores and manipulates data.">clPacket</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in packet queue before this method was called </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID is out of bounds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if operationID is out of bounds </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#a8b6e71b0ce806b23e378fe7206a0d8a5">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f2be71b5dac611c2a6c6fd8b17c00a"></a><!-- doxytag: member="clPerClientUDP::GetProtocolMode" ref="aa0f2be71b5dac611c2a6c6fd8b17c00a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clPerClientUDP::GetProtocolMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP mode that this class represents </dd></dl>

<p>Implements <a class="el" href="classcl_shared_protocol.html#a473332c76ea2409937925e2390ac96a1">clSharedProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a1b94d67fd8a10170e31f9b65c4901b0d"></a><!-- doxytag: member="clPerClientUDP::GetRecvCounter" ref="a1b94d67fd8a10170e31f9b65c4901b0d" args="(size_t clientID, size_t operationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_t clPerClientUDP::GetRecvCounter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>operation ID of operation to use, ignored if <code>perOperation</code> is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>age of currently stored packet for specified client and operation </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID is out of bounds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if operationID is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33f25535cfef99e9abe9b2556928f364"></a><!-- doxytag: member="clPerClientUDP::GetSendObject" ref="a33f25535cfef99e9abe9b2556928f364" args="(const clPacket *packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_send.html">clSharedSend</a> * clPerClientUDP::GetSendObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a send object with a prefix of the return value of <code>clock()</code> casted to size_t which is the system timer </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>true if sending should be synchronous, false if sending should be asynchronous </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_shared_protocol.html#ae8ba1c07871850b15abc9d15ec475d8e">clSharedProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a8401c5217b43d904b053e0fbcb0fa462"></a><!-- doxytag: member="clPerClientUDP::operator=" ref="a8401c5217b43d904b053e0fbcb0fa462" args="(const clPerClientUDP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp; clPerClientUDP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_per_client_u_d_p.html">clPerClientUDP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment operator (deep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a650dc543709d94ea2826871a15e526f5"></a><!-- doxytag: member="clPerClientUDP::Reset" ref="a650dc543709d94ea2826871a15e526f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clPerClientUDP::Reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset all client's packet store </p>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#a086fea6811fed1dc76d54ba9cbf52763">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="ae7d279662aacd52fae6d64683820e653"></a><!-- doxytag: member="clPerClientUDP::Reset" ref="ae7d279662aacd52fae6d64683820e653" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clPerClientUDP::Reset </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset client's packet store, done when client leaves </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>clientID of client to reset </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_shared_u_d_p.html#a6985d2cd42ad37bc2477efb162bad157">clSharedUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a97cce2497fa9687fa5854f2c0a3fc684"></a><!-- doxytag: member="clPerClientUDP::SetRecvCounter" ref="a97cce2497fa9687fa5854f2c0a3fc684" args="(size_t clientID, size_t operationID, clock_t newCounter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clPerClientUDP::SetRecvCounter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_t&nbsp;</td>
          <td class="paramname"> <em>newCounter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>recvCounter</code> which indicates age of current data </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>operation ID of operation to use, ignored if <code>perOperation</code> is true </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newCounter</em>&nbsp;</td><td><code>recvCounter</code> will be set to this </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID is out of bounds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if operationID is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a997243e373a1d997f27b111d06cccd90"></a><!-- doxytag: member="clPerClientUDP::decryptKey" ref="a997243e373a1d997f27b111d06cccd90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT_PTR <a class="el" href="classcl_per_client_u_d_p.html#a997243e373a1d997f27b111d06cccd90">clPerClientUDP::decryptKey</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>decryptKey ignored if NULL, otherwise represents memory address of <a class="el" href="classcl_encrypt_key.html">clEncryptKey</a> object used to decrypt incoming packets before reading them </p>

</div>
</div>
<a class="anchor" id="a7ed46a6713cec6ebc3c788d7542bdc58"></a><!-- doxytag: member="clPerClientUDP::packetStore" ref="a7ed46a6713cec6ebc3c788d7542bdc58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_store_vector.html">clStoreVector</a>&lt;<a class="el" href="classcl_store_vector.html">clStoreVector</a>&lt;<a class="el" href="classcl_packet.html">clPacket</a>&gt; &gt; <a class="el" href="classcl_per_client_u_d_p.html#a7ed46a6713cec6ebc3c788d7542bdc58">clPerClientUDP::packetStore</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>2D vector that stores received packets and safely controls access </p>

</div>
</div>
<a class="anchor" id="ae270ad0657e279032f9e1bebee3f0698"></a><!-- doxytag: member="clPerClientUDP::perOperation" ref="ae270ad0657e279032f9e1bebee3f0698" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcl_per_client_u_d_p.html#ae270ad0657e279032f9e1bebee3f0698">clPerClientUDP::perOperation</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if object is used in 'per client, per operation' UDP mode, false if object is used in 'per client' UDP mode </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_per_client_u_d_p_8h_source.html">clPerClientUDP.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clPerClientUDP.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:08 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
