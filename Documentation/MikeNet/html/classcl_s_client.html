<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clSClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clSClient Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clSClient" --><!-- doxytag: inherits="clMultithread" -->
<p>object stores and manages individual clients  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_s_client_8h_source.html">clSClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clSClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_s_client.png" usemap="#clSClient_map" alt=""/>
  <map id="clSClient_map" name="clSClient_map">
<area href="classcl_multithread.html" alt="clMultithread" shape="rect" coords="0,0,85,24"/>
</map>
</div>

<p><a href="classcl_s_client-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a738a8350fb3fb861342d13b1b89fbccc">clSClient</a> (size_t <a class="el" href="classcl_s_client.html#ac5af0964e2af13aab950694923308512">clientID</a>, <a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *<a class="el" href="classcl_s_client.html#a7cc5ca2a86b8b3a96884ed174dffb0f3">socketTCP</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a9af97875b5c08340d81678e9a821bddc">~clSClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ad20ec8875bb3fb9fb3536d05ffc1f397">GetClientID</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#aa720bde21885b93a7428a10156aaebd4">GetConnectionState</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#aa63c3f33269e76af35326ace504cc759">GetConnectionStateTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#aaead23b701d0c8c75346e7cdd26fd8bc">SetConnectionState</a> (size_t threadID, <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">clock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#af044934846909919990d3cc1e0cb9307">GetClockStarted</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a29a4d9e44330e35810c6cf27ee78f6dc">SetClockStarted</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a1717c472aa382b90260e10fe569f4663">SetConnectCode</a> (size_t threadID, size_t element, int code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ac88dd15044e25a0a27c8c05671070c2f">GetConnectCode</a> (size_t threadID, size_t element) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a1ab3b96d9b2ec36ae14dd294c374b455">Authenticate</a> (size_t threadID, vector&lt; int &gt; codes) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ab9c1ea6a2196562e99b191a97dab058b">Disconnect</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#aa1c7fadc44fd30f44cc5d45af30b7b1e">GetSocketTCP</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#aad37f5b898ae869be612d90305186005">GetSocketTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a8757aa526a1ea94a1bc64deb7971cede">LoadTCP</a> (size_t threadID, SOCKET socket, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;addr, bool enabledUDP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ad4c7e64bbfd7bad34a52311d0d00609a">LoadUDP</a> (size_t threadID, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#af9978a7ddb66b6c041e2606a59e5c69d">SendHandshakingPacket</a> (size_t threadID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;serverInfo, size_t <a class="el" href="classcl_s_client.html#ac5af0964e2af13aab950694923308512">clientID</a>, bool enabledUDP, unsigned int sendTimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ad23a31beb4ec135a3f39da184999c696">GetRecvBufferLengthTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ab1de13b5c187540bae0e4af91db2685d">GetPartialPacketCurrentSizeTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a5cccbe5583ed198f97826a1c5108bb4a">GetMaxPacketSizeTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a88018b22e270d1e89feefe05c23af49e">SetMaxPacketSizeTCP</a> (size_t threadID, size_t newMaxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a586f33ed29909d3e2c0b6454e725b1eb">GetAutoResizeTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#afc6bdb1157707ea2cf21970602b86c5c">SetAutoResizeTCP</a> (size_t threadID, bool newAutoResizeTCP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a08ea258df61181a350a828aa1e3a9175">GetLocalAddressTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a74cd5fc9af94414af26cb79a15a25d49">GetConnectedAddressUDP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a7e1902d813deb1ef51d68532cd2c6d81">GetConnectedAddressTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a04890f0214cab7c74873de330317422c">FlushRecvTCP</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a7a08da8507499aa530a114d88b7e8cdf">GetPacketAmountTCP</a> (size_t threadID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#af2e8e590ab4ca21490b276cda540d263">ShutdownTCP</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a355e4804063ce95611ffcb6b72dec67b">GetPacketFromStoreTCP</a> (size_t threadID, <a class="el" href="classcl_packet.html">clPacket</a> *destination)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#af7a988045a68ed3e95e56fc1e8a9de0c">SendTCP</a> (size_t threadID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block, unsigned int timeout)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#ac5af0964e2af13aab950694923308512">clientID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_single_addr.html">clSingleAddr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a9caa557830e054fd916506b0b0b009ef">remoteAddrUDP</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a1c0884f02facf322bc8fb8a1b78a3e5f">connectionState</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">clock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a94a58dbecbb367d53535efd533602100">clockStarted</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a051064752aa82c8787204336927897c1">connectCode</a> [<a class="el" href="classcl_networking_utility.html#aa48d05605a3161f1b99b1dac14e05774">clNetworkingUtility::authenticationStrength</a>]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_s_client.html#a7cc5ca2a86b8b3a96884ed174dffb0f3">socketTCP</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>object stores and manages individual clients </p>
<p>Class is used by <a class="el" href="classcl_server_state.html" title="Server instance, designed to communicate with clients.">clServerState</a> and is never used independently <br/>
 <a class="el" href="classcl_multithread.html" title="Advanced concurrency control object.">clMultithread</a> is used in the following way:</p>
<ul>
<li>EnterWrite ONLY when changing connectionState</li>
<li>EnterRead when reading values</li>
<li>EnterRead when changing any value except connectionState</li>
</ul>
<p>This is to ensure that connectionState is not changed midway through a client related operation by another thread. It ensures that the <a class="el" href="classcl_s_client.html" title="object stores and manages individual clients">clSClient</a> object is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a738a8350fb3fb861342d13b1b89fbccc"></a><!-- doxytag: member="clSClient::clSClient" ref="a738a8350fb3fb861342d13b1b89fbccc" args="(size_t clientID, clSocketTCP *socketTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSClient::clSClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> *&nbsp;</td>
          <td class="paramname"> <em>socketTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID assigned to client </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socketTCP</em>&nbsp;</td><td>Socket used to communicate with client via TCP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9af97875b5c08340d81678e9a821bddc"></a><!-- doxytag: member="clSClient::~clSClient" ref="a9af97875b5c08340d81678e9a821bddc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSClient::~clSClient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1ab3b96d9b2ec36ae14dd294c374b455"></a><!-- doxytag: member="clSClient::Authenticate" ref="a1ab3b96d9b2ec36ae14dd294c374b455" args="(size_t threadID, vector&lt; int &gt; codes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSClient::Authenticate </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&nbsp;</td>
          <td class="paramname"> <em>codes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares <em>codes</em> with stored connect codes (connectCode) which were sent via TCP to the client, if the codes differ in any way then it is possible that a rogue client is trying to imitate the client that is mid way through its connection process and so any data from this rogue client should be ignored. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>

</div>
</div>
<a class="anchor" id="ab9c1ea6a2196562e99b191a97dab058b"></a><!-- doxytag: member="clSClient::Disconnect" ref="ab9c1ea6a2196562e99b191a97dab058b" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::Disconnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnect client from server forcefully and prepare this object so that it can store another client </p>

</div>
</div>
<a class="anchor" id="a04890f0214cab7c74873de330317422c"></a><!-- doxytag: member="clSClient::FlushRecvTCP" ref="a04890f0214cab7c74873de330317422c" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all fully received TCP packets from the packet queue <br/>
 Has no impact on the partial packet store </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a586f33ed29909d3e2c0b6454e725b1eb"></a><!-- doxytag: member="clSClient::GetAutoResizeTCP" ref="a586f33ed29909d3e2c0b6454e725b1eb" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSClient::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ad20ec8875bb3fb9fb3536d05ffc1f397"></a><!-- doxytag: member="clSClient::GetClientID" ref="ad20ec8875bb3fb9fb3536d05ffc1f397" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>client ID of object </dd></dl>

</div>
</div>
<a class="anchor" id="af044934846909919990d3cc1e0cb9307"></a><!-- doxytag: member="clSClient::GetClockStarted" ref="af044934846909919990d3cc1e0cb9307" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_t clSClient::GetClockStarted </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>clock value at which client began connecting </dd></dl>

</div>
</div>
<a class="anchor" id="ac88dd15044e25a0a27c8c05671070c2f"></a><!-- doxytag: member="clSClient::GetConnectCode" ref="ac88dd15044e25a0a27c8c05671070c2f" args="(size_t threadID, size_t element) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int clSClient::GetConnectCode </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>element</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>connection code to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>connection code at element <em>element</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e1902d813deb1ef51d68532cd2c6d81"></a><!-- doxytag: member="clSClient::GetConnectedAddressTCP" ref="a7e1902d813deb1ef51d68532cd2c6d81" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clSClient::GetConnectedAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="a74cd5fc9af94414af26cb79a15a25d49"></a><!-- doxytag: member="clSClient::GetConnectedAddressUDP" ref="a74cd5fc9af94414af26cb79a15a25d49" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clSClient::GetConnectedAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote address information. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="aa720bde21885b93a7428a10156aaebd4"></a><!-- doxytag: member="clSClient::GetConnectionState" ref="aa720bde21885b93a7428a10156aaebd4" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clSClient::GetConnectionState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>connection state of client </dd></dl>

</div>
</div>
<a class="anchor" id="aa63c3f33269e76af35326ace504cc759"></a><!-- doxytag: member="clSClient::GetConnectionStateTCP" ref="aa63c3f33269e76af35326ace504cc759" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clSClient::GetConnectionStateTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>connection state of client purely looking at the TCP socket </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>GetConnectionState and this method are unlinked </dd></dl>

</div>
</div>
<a class="anchor" id="a08ea258df61181a350a828aa1e3a9175"></a><!-- doxytag: member="clSClient::GetLocalAddressTCP" ref="a08ea258df61181a350a828aa1e3a9175" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clSClient::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="a5cccbe5583ed198f97826a1c5108bb4a"></a><!-- doxytag: member="clSClient::GetMaxPacketSizeTCP" ref="a5cccbe5583ed198f97826a1c5108bb4a" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </dd></dl>

</div>
</div>
<a class="anchor" id="a7a08da8507499aa530a114d88b7e8cdf"></a><!-- doxytag: member="clSClient::GetPacketAmountTCP" ref="a7a08da8507499aa530a114d88b7e8cdf" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetPacketAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of fully received TCP packets in the packet store </dd></dl>

</div>
</div>
<a class="anchor" id="a355e4804063ce95611ffcb6b72dec67b"></a><!-- doxytag: member="clSClient::GetPacketFromStoreTCP" ref="a355e4804063ce95611ffcb6b72dec67b" args="(size_t threadID, clPacket *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetPacketFromStoreTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a complete packet from the TCP packet store and copies it into <em>destination</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>destination to copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call </dd></dl>

</div>
</div>
<a class="anchor" id="ab1de13b5c187540bae0e4af91db2685d"></a><!-- doxytag: member="clSClient::GetPartialPacketCurrentSizeTCP" ref="ab1de13b5c187540bae0e4af91db2685d" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetPartialPacketCurrentSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current size of the TCP partial packet being received <br/>
 i.e. the number of bytes of the packet that have been received </dd></dl>

</div>
</div>
<a class="anchor" id="ad23a31beb4ec135a3f39da184999c696"></a><!-- doxytag: member="clSClient::GetRecvBufferLengthTCP" ref="ad23a31beb4ec135a3f39da184999c696" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSClient::GetRecvBufferLengthTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF used by the TCP socket. <br/>
 This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c7fadc44fd30f44cc5d45af30b7b1e"></a><!-- doxytag: member="clSClient::GetSocketTCP" ref="aa1c7fadc44fd30f44cc5d45af30b7b1e" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> * clSClient::GetSocketTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>returned pointer must be accessed with at least read control </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to TCP socket </dd></dl>

</div>
</div>
<a class="anchor" id="aad37f5b898ae869be612d90305186005"></a><!-- doxytag: member="clSClient::GetSocketTCP" ref="aad37f5b898ae869be612d90305186005" args="(size_t threadID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a> * clSClient::GetSocketTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>returned pointer must be accessed with at least read control </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to TCP socket </dd></dl>

</div>
</div>
<a class="anchor" id="a8757aa526a1ea94a1bc64deb7971cede"></a><!-- doxytag: member="clSClient::LoadTCP" ref="a8757aa526a1ea94a1bc64deb7971cede" args="(size_t threadID, SOCKET socket, const clSingleAddr &amp;addr, bool enabledUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::LoadTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKET&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabledUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads a new TCP socket and address of socket end point into this object <br/>
 Also updates connection status</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socket</em>&nbsp;</td><td>TCP winsock socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>TCP address of client </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabledUDP</em>&nbsp;</td><td>true if UDP is enabled for this client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4c7e64bbfd7bad34a52311d0d00609a"></a><!-- doxytag: member="clSClient::LoadUDP" ref="ad4c7e64bbfd7bad34a52311d0d00609a" args="(size_t threadID, const clSingleAddr &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::LoadUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads client's UDP remote address <br/>
 This is done in the final stages of the connection process by the completion port <br/>
 Also updates connection status</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>remote address of client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9978a7ddb66b6c041e2606a59e5c69d"></a><!-- doxytag: member="clSClient::SendHandshakingPacket" ref="af9978a7ddb66b6c041e2606a59e5c69d" args="(size_t threadID, const clPacket &amp;serverInfo, size_t clientID, bool enabledUDP, unsigned int sendTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int clSClient::SendHandshakingPacket </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>serverInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabledUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>sendTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a packet using this socket which contains information about the server and authenticates the client (upon reply). This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>clientID assigned by server to this client </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabledUDP</em>&nbsp;</td><td>true if UDP is enabled for this client </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>length of time in milliseconds to wait before canceling send operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if send operation completed successfully instantly </dd>
<dd>
1 if send operation was started, but has not yet completed </dd>
<dd>
-1 if send operation failed </dd>
<dd>
-2 if send operation failed and entity should be killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="af7a988045a68ed3e95e56fc1e8a9de0c"></a><!-- doxytag: member="clSClient::SendTCP" ref="af7a988045a68ed3e95e56fc1e8a9de0c" args="(size_t threadID, const clPacket &amp;packet, bool block, unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clSClient::SendTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via TCP to specified client </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>length of time in milliseconds to wait before canceling send operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="afc6bdb1157707ea2cf21970602b86c5c"></a><!-- doxytag: member="clSClient::SetAutoResizeTCP" ref="afc6bdb1157707ea2cf21970602b86c5c" args="(size_t threadID, bool newAutoResizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29a4d9e44330e35810c6cf27ee78f6dc"></a><!-- doxytag: member="clSClient::SetClockStarted" ref="a29a4d9e44330e35810c6cf27ee78f6dc" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::SetClockStarted </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>clockStarted</code> with return value of <code>clock()</code>. Should be used when handshaking process with client first starts. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1717c472aa382b90260e10fe569f4663"></a><!-- doxytag: member="clSClient::SetConnectCode" ref="a1717c472aa382b90260e10fe569f4663" args="(size_t threadID, size_t element, int code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::SetConnectCode </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>connection</code> code used to authenticate client via UDP. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>connection code to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code to set it to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaead23b701d0c8c75346e7cdd26fd8bc"></a><!-- doxytag: member="clSClient::SetConnectionState" ref="aaead23b701d0c8c75346e7cdd26fd8bc" args="(size_t threadID, clNetworkingUtility::ConnectionStatus state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::SetConnectionState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>new connection state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88018b22e270d1e89feefe05c23af49e"></a><!-- doxytag: member="clSClient::SetMaxPacketSizeTCP" ref="a88018b22e270d1e89feefe05c23af49e" args="(size_t threadID, size_t newMaxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::SetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newMaxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manually changes the maximum packet size that can be received </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newMaxSize</em>&nbsp;</td><td>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2e8e590ab4ca21490b276cda540d263"></a><!-- doxytag: member="clSClient::ShutdownTCP" ref="af2e8e590ab4ca21490b276cda540d263" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSClient::ShutdownTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops sending on TCP socket so that all further send operations will fail. <br/>
 All data sent up till now will be received by recipient. <br/>
 Recipient GetConnectionStateTCP will return <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6daf36e05d04ad267b00184a32d654c3989">clNetworkingUtility::NO_RECV</a>, or <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da049f6833fe3ed9d08cfe5047078b73e3">clNetworkingUtility::NO_SEND_RECV</a>. <br/>
 Our GetConnectionStateTCP will return <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dab8241425bb2dc77be7422346559bbb30">clNetworkingUtility::NO_SEND</a> or <a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da049f6833fe3ed9d08cfe5047078b73e3">clNetworkingUtility::NO_SEND_RECV</a>. <br/>
 This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac5af0964e2af13aab950694923308512"></a><!-- doxytag: member="clSClient::clientID" ref="ac5af0964e2af13aab950694923308512" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_s_client.html#ac5af0964e2af13aab950694923308512">clSClient::clientID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ID of client </p>

</div>
</div>
<a class="anchor" id="a94a58dbecbb367d53535efd533602100"></a><!-- doxytag: member="clSClient::clockStarted" ref="a94a58dbecbb367d53535efd533602100" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_t <a class="el" href="classcl_s_client.html#a94a58dbecbb367d53535efd533602100">clSClient::clockStarted</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>clock()</code> that handshaking process began, is used to timeout the client </p>

</div>
</div>
<a class="anchor" id="a051064752aa82c8787204336927897c1"></a><!-- doxytag: member="clSClient::connectCode" ref="a051064752aa82c8787204336927897c1" args="[clNetworkingUtility::authenticationStrength]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcl_s_client.html#a051064752aa82c8787204336927897c1">clSClient::connectCode</a>[<a class="el" href="classcl_networking_utility.html#aa48d05605a3161f1b99b1dac14e05774">clNetworkingUtility::authenticationStrength</a>]<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores the unique authentication code sent to client during handshaking process </p>

</div>
</div>
<a class="anchor" id="a1c0884f02facf322bc8fb8a1b78a3e5f"></a><!-- doxytag: member="clSClient::connectionState" ref="a1c0884f02facf322bc8fb8a1b78a3e5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> <a class="el" href="classcl_s_client.html#a1c0884f02facf322bc8fb8a1b78a3e5f">clSClient::connectionState</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connection state of client <br/>
 Take write control when changing this object </p>

</div>
</div>
<a class="anchor" id="a9caa557830e054fd916506b0b0b009ef"></a><!-- doxytag: member="clSClient::remoteAddrUDP" ref="a9caa557830e054fd916506b0b0b009ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_single_addr.html">clSingleAddr</a> <a class="el" href="classcl_s_client.html#a9caa557830e054fd916506b0b0b009ef">clSClient::remoteAddrUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UDP remote address client </p>

</div>
</div>
<a class="anchor" id="a7cc5ca2a86b8b3a96884ed174dffb0f3"></a><!-- doxytag: member="clSClient::socketTCP" ref="a7cc5ca2a86b8b3a96884ed174dffb0f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_socket_t_c_p.html">clSocketTCP</a>* <a class="el" href="classcl_s_client.html#a7cc5ca2a86b8b3a96884ed174dffb0f3">clSClient::socketTCP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to communicate via TCP with client </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_s_client_8h_source.html">clSClient.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clSClient.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:08 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
