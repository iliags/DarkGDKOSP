<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clServerState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clServerState Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clServerState" --><!-- doxytag: inherits="clInstanceUDP,clInstanceTCP" -->
<p>Server instance, designed to communicate with clients.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_server_state_8h_source.html">clServerState.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clServerState:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_server_state.png" usemap="#clServerState_map" alt=""/>
  <map id="clServerState_map" name="clServerState_map">
<area href="classcl_instance_u_d_p.html" alt="clInstanceUDP" shape="rect" coords="0,56,97,80"/>
<area href="classcl_instance_t_c_p.html" alt="clInstanceTCP" shape="rect" coords="107,56,204,80"/>
<area href="classcl_instance_core.html" alt="clInstanceCore" shape="rect" coords="0,0,97,24"/>
</map>
</div>

<p><a href="classcl_server_state-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#af58617f6176dafbd31bf7518f28caffe">GetRecvSizeMinUDP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a5c90cd631cdc4b2cd323e553433d4d16">GetRecvSizeMinTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#abf0e50dd728a1aa409d61294a618a4f6">clServerState</a> (size_t <a class="el" href="classcl_server_state.html#a78bea97e597f0122863a4ee259a24785">maxClients</a>, <a class="el" href="classcl_socket_listening.html">clSocketListening</a> *listeningSocket, <a class="el" href="classcl_socket_u_d_p.html">clSocketUDP</a> *<a class="el" href="classcl_instance_u_d_p.html#adabf31cb357eb5dada6ad5c8e57c611e">socketUDP</a>, bool <a class="el" href="classcl_instance_t_c_p.html#a4a35647e926d2c2c5abec877242f69fa">handshakeEnabled</a>, size_t <a class="el" href="classcl_instance_core.html#a05be31d3ac12930f23fb1a06c25b225c">sendTimeout</a>=INFINITE, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> <a class="el" href="classcl_instance_t_c_p.html#aae4ec2a4dd6ac904c67e53c0620e2843">recvFuncTCP</a>=NULL, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> <a class="el" href="classcl_instance_u_d_p.html#a71fd288aaec92fa83f45060bc15d1f1e">recvFuncUDP</a>=NULL, size_t connectionTimeout=<a class="el" href="classcl_server_state.html#aa61be479aa559af84ebad2a136c2173b">DEFAULT_CONNECTION_TIMEOUT</a>, size_t <a class="el" href="classcl_instance_core.html#ad3de74dbad74098dc2f010806186bf7f">instanceID</a>=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a9e3ba068464bfab6b9000ed412476801">clServerState</a> (size_t <a class="el" href="classcl_server_state.html#a78bea97e597f0122863a4ee259a24785">maxClients</a>, const <a class="el" href="classcl_instance_profile.html">clInstanceProfile</a> &amp;profile, size_t <a class="el" href="classcl_instance_core.html#ad3de74dbad74098dc2f010806186bf7f">instanceID</a>=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a8752bfaf6e69d575f483fb09ad2d1ade">init</a> (size_t <a class="el" href="classcl_server_state.html#a78bea97e597f0122863a4ee259a24785">maxClients</a>, bool <a class="el" href="classcl_instance_t_c_p.html#a4a35647e926d2c2c5abec877242f69fa">handshakeEnabled</a>, size_t connectionTimeout, <a class="el" href="classcl_socket_listening.html">clSocketListening</a> *<a class="el" href="classcl_server_state.html#a5420d87b6c3e42c7ab033d00273ffe51">socketListening</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aecbd792cf629712b55a673406c2111e9">~clServerState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aa20c329aee577aefe77e3a8b9c517686">AddDisconnect</a> (size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a1823d201b34aa75de541a7c14bd1d774">GetDisconnect</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a78cca781121c231c27b705ac04aa90c3">GetMaxClients</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a8aa76c5f0ae3202e74f3c85bb62a1710">GetServerTimeout</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#afc302a2ceb465e93a8e1396c1c69978d">SetServerTimeout</a> (size_t milliseconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a0c6c0c0c2db0181c66945c649ff016d4">SetAutoResize</a> (size_t threadID, bool autoResize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a4cb4d04f8f9d0292b406a633fdf4aaf1">DoRecvUDP</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a692ed17b33921c31f87941b2c95bf99a">DoRecvTCP</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ad484dd6b0de0014bafe361ba4b8aa19a">ErrorOccurred</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a74388f1a87e39ae71a67a796ed61da11">ClientConnected</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a8d559d88c2635a34110063c408b4440e">ClientJoined</a> (size_t threadID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ab595d445807ac565db31e922b22d58f8">DisconnectClient</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a31a4202c942e75d35bc5cfd325e383fd">GetServerInfo</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ad0e980f5aa1e93270092d67412aa2684">GetEnabledUDP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aa2bbcc834edc34008fa234a62e70e72c">GetModeUDP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a25076fc19a70980db2d575a0e0d4fb8c">GetRecvBufferLengthTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a657be97242d234350f5d5193bf1323fd">GetPartialPacketCurrentSizeTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ae65f7e9ed108d2ceee3e803be4663e21">GetMaxPacketSizeTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a69575a84cd634b4105187cb1644a9fe9">SetMaxPacketSizeTCP</a> (size_t threadID, size_t clientID, size_t newMaxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a40e9658d157664d28b4ff6764653ee52">GetAutoResizeTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aa324f4af4421895f4c06fed536826d40">SetAutoResizeTCP</a> (size_t threadID, size_t clientID, bool newAutoResizeTCP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a3458bc8c0e335c67243fe5f4225bc5e5">GetGracefulDisconnectEnabled</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aaedff3aeda921ce765c0d92a116d34b3">GetProtocolModeTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a417e525b8f5cd73c2051bf32040334cc">GetClientLocalAddressTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a43b1ac7de146c88e64bfeacb277a2b8f">GetLocalAddressTCP</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ac464bdb2b462528f5e08d8d044e052d5">GetConnectAddressTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ab76e0a98a18b26f5c9c90a2c30127228">GetConnectAddressUDP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ac139ec3acb06e1b28744339cbb9710d6">FlushRecvTCP</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a6293150ae0d2deee1e853e8de2fc6549">GetPacketAmountTCP</a> (size_t threadID, size_t clientID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ab6bb7ca048e12e276cfa85798bbca305">ShutdownTCP</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a434b7015edbb25a83593e60f7ee6f0f7">GetPacketFromStoreTCP</a> (size_t threadID, size_t clientID, <a class="el" href="classcl_packet.html">clPacket</a> *destination)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aa26a11694b770b75c58e3a5931fd387e">SendTCP</a> (size_t threadID, size_t clientID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ab3abf9a84501271ce55c2b1eda4d5fa3">SendAllTCP</a> (size_t threadID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block, size_t clientExclude)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a4c582a5907e427eb0091079bd4ada3b0">SendUDP</a> (size_t threadID, size_t clientID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a53e069f3cc1bc74202704ffb75e398f1">SendAllUDP</a> (size_t threadID, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block, size_t clientExclude)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ac2f8e109ed5f86a2feaebc04d2379b45">SendToUDP</a> (size_t threadID, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;address, const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ac5219f6dfbf0a4fc46c2f0b10f4777a4">GetPacketAmountUDP</a> (size_t threadID, size_t clientID, size_t operationID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a3e804dd8e1d0fb5ce0307f461d5a1e5e">FlushRecvUDP</a> (size_t threadID, size_t clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#acd70ba0bd1cf45ddc0f30cda86a1fbc5">GetPacketFromStoreUDP</a> (size_t threadID, size_t clientID, size_t operationID, <a class="el" href="classcl_packet.html">clPacket</a> *destination)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a8d2ff8fdba2c01906239b7f513140fd7">DealCompletion</a> (size_t threadID, <a class="el" href="classcl_completion_key.html">clCompletionKey</a> &amp;completionKey, DWORD bytes, const WSAOVERLAPPED *overlapped, BOOL success)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ae2bc69bbd2bff4071cb148da272bfe95">SetContainer</a> (<a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *container)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ae6d8460b8b124c1ece70b94440cea634">recvSizeMinUDP</a> = 20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a6f718c1f7be5673a45d04df644f7ce5b">recvSizeMinTCP</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#aa61be479aa559af84ebad2a136c2173b">DEFAULT_CONNECTION_TIMEOUT</a> = 10000</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a81e2910f7c99cfc1ed515932dadc7df9">_CheckClientID</a> (size_t clientID, size_t line, const char *file) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a6ff5552b881351ef18fc33df532c2ad6">FindClientByAddressUDP</a> (size_t threadID, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;addr)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_socket_listening.html">clSocketListening</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a5420d87b6c3e42c7ab033d00273ffe51">socketListening</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_counter.html">clCounter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a375603ab73421b96cfe100570d86300d">recvFailCounterUDP</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_store_vector.html">clStoreVector</a>&lt; <a class="el" href="classcl_s_client.html">clSClient</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a4d04e7fec349fb69ac9d7d4278c7e915">client</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a78bea97e597f0122863a4ee259a24785">maxClients</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_store_queue.html">clStoreQueue</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a1928a46878962bc4d2c804bf21074319">disconnected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_status.html">clStatus</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#ad8a53992b7a622816eeb6b70fd4fec25">timeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_packet.html">clPacket</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_server_state.html#a65f672655a8b980a21e84d939ad81841">serverInfo</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Server instance, designed to communicate with clients. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This instance uses TCP and UDP to communicate with clients. Most commonly it will be used to communicate with another entity running a <a class="el" href="classcl_client_state.html" title="Client instance, designed to communicate with servers.">clClientState</a> instance. However, this instance can also communicate with non DarkNet entities such as web clients. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abf0e50dd728a1aa409d61294a618a4f6"></a><!-- doxytag: member="clServerState::clServerState" ref="abf0e50dd728a1aa409d61294a618a4f6" args="(size_t maxClients, clSocketListening *listeningSocket, clSocketUDP *socketUDP, bool handshakeEnabled, size_t sendTimeout=INFINITE, clInstanceCore::RecvFunc recvFuncTCP=NULL, clInstanceCore::RecvFunc recvFuncUDP=NULL, size_t connectionTimeout=DEFAULT_CONNECTION_TIMEOUT, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clServerState::clServerState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_listening.html">clSocketListening</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketListening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_u_d_p.html">clSocketUDP</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_sendTimeout</em> = <code>INFINITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>p_recvFuncTCP</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>p_recvFuncUDP</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectionTimeout</em> = <code><a class="el" href="classcl_server_state.html#aa61be479aa559af84ebad2a136c2173b">DEFAULT_CONNECTION_TIMEOUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>maximum number of clients that can be connected to server at any one time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketListening</em>&nbsp;</td><td>socket to use to listen for new TCP connections </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketUDP</em>&nbsp;</td><td>socket to use to send and receive UDP data, NULL if UDP is disabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>true if the TCP handshaking process is enabled, false if not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_sendTimeout</em>&nbsp;</td><td>length of time in milliseconds to wait for a send operation to complete before disconnecting client (optional, default INFINITE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_recvFuncTCP</em>&nbsp;</td><td>method to be executed when new TCP packets are received (optional, default NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_recvFuncUDP</em>&nbsp;</td><td>method to be executed when new UDP packets are received (optional, default NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_connectionTimeout</em>&nbsp;</td><td>time in milliseconds that a connection attempt will be waited on before giving up (optional, default DEFAULT_CONNECTION_TIMEOUT) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>unique identifier for instance (optional, default 0) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="classcl_server_state.html#a5c90cd631cdc4b2cd323e553433d4d16">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e3ba068464bfab6b9000ed412476801"></a><!-- doxytag: member="clServerState::clServerState" ref="a9e3ba068464bfab6b9000ed412476801" args="(size_t maxClients, const clInstanceProfile &amp;profile, size_t instanceID=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clServerState::clServerState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_instance_profile.html">clInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_instanceID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>maximum number of clients that can be connected to server at any one time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_profile</em>&nbsp;</td><td>instance profile containing parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_instanceID</em>&nbsp;</td><td>unique identifier for instance (optional, default 0) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="classcl_server_state.html#a5c90cd631cdc4b2cd323e553433d4d16">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecbd792cf629712b55a673406c2111e9"></a><!-- doxytag: member="clServerState::~clServerState" ref="aecbd792cf629712b55a673406c2111e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clServerState::~clServerState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a81e2910f7c99cfc1ed515932dadc7df9"></a><!-- doxytag: member="clServerState::_CheckClientID" ref="a81e2910f7c99cfc1ed515932dadc7df9" args="(size_t clientID, size_t line, const char *file) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::_CheckClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks that client ID is within range </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>client ID to check </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if clientID &gt; maxClients </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa20c329aee577aefe77e3a8b9c517686"></a><!-- doxytag: member="clServerState::AddDisconnect" ref="aa20c329aee577aefe77e3a8b9c517686" args="(size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::AddDisconnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>client</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a client to the disconnect list, indicating that it has recently been disconnected </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>client</em>&nbsp;</td><td>client ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74388f1a87e39ae71a67a796ed61da11"></a><!-- doxytag: member="clServerState::ClientConnected" ref="a74388f1a87e39ae71a67a796ed61da11" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6d">clNetworkingUtility::ConnectionStatus</a> clServerState::ClientConnected </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to query the status of a clients connection. This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client who's connection status should be checked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da91a3fd8751354e5c4f32181268627d9f">clNetworkingUtility::CONNECTED</a>: fully connected </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da7ea7f5aa34e94ec65b905c2a37610583">clNetworkingUtility::NOT_CONNECTED</a>: not connected at all </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6daf36e05d04ad267b00184a32d654c3989">clNetworkingUtility::NO_RECV</a>: connected but new data cannot be received because <code>Shutdown</code> has been used by recipient (only possible if graceful disconnect is enabled) </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6dab8241425bb2dc77be7422346559bbb30">clNetworkingUtility::NO_SEND</a>: connected but data cannot be sent because <code>Shutdown</code> has been used (only possible if graceful disconnect is enabled) </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a15dd34683154e07d5843f8f5432fec6da049f6833fe3ed9d08cfe5047078b73e3">clNetworkingUtility::NO_SEND_RECV</a>: connected but data cannot be sent or received because <code>Shutdown</code> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if graceful disconnect is enabled) </dd></dl>

</div>
</div>
<a class="anchor" id="a8d559d88c2635a34110063c408b4440e"></a><!-- doxytag: member="clServerState::ClientJoined" ref="a8d559d88c2635a34110063c408b4440e" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::ClientJoined </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manages server side handshaking process with joining clients, clients cannot connect unless this method is called whilst they are attempting to connect. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no new clients joined during the method call </dd>
<dd>
&gt;0 if a new client joined, this number is the ID of the client </dd></dl>

</div>
</div>
<a class="anchor" id="a8d2ff8fdba2c01906239b7f513140fd7"></a><!-- doxytag: member="clServerState::DealCompletion" ref="a8d2ff8fdba2c01906239b7f513140fd7" args="(size_t threadID, clCompletionKey &amp;completionKey, DWORD bytes, const WSAOVERLAPPED *overlapped, BOOL success)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::DealCompletion </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_completion_key.html">clCompletionKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>completionKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSAOVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>overlapped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>success</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When send and receive operations are completed on this instance, this method is called. When data is received from an unlisted UDP address, i.e. an address that is not stored under any connected client ID, this method performs part of the <a class="el" href="handshake_page.html">handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>completionKey</em>&nbsp;</td><td>reference to completion key which provides information about the completed operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>number of bytes of data transferred in operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlapped</em>&nbsp;</td><td>pointer to overlapped operation associated with event </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>success</em>&nbsp;</td><td>TRUE if no error occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_core.html#afb72728b46b08c2928845cd67acc238d">clInstanceCore</a>.</p>

</div>
</div>
<a class="anchor" id="ab595d445807ac565db31e922b22d58f8"></a><!-- doxytag: member="clServerState::DisconnectClient" ref="ab595d445807ac565db31e922b22d58f8" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::DisconnectClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnects client of ID <em>clientID</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to disconnect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a692ed17b33921c31f87941b2c95bf99a"></a><!-- doxytag: member="clServerState::DoRecvTCP" ref="a692ed17b33921c31f87941b2c95bf99a" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::DoRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls socketTCP-&gt;Recv and deals with errors in a server specific way <br/>
 Use this INSTEAD OF socketTCP-&gt;Recv, never use socketTCP-&gt;Recv directly</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that receive operation should apply to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a680fdd73e7ea21c59da3029f30ab9409">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb4d04f8f9d0292b406a633fdf4aaf1"></a><!-- doxytag: member="clServerState::DoRecvUDP" ref="a4cb4d04f8f9d0292b406a633fdf4aaf1" args="(size_t threadID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::DoRecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls socketUDP-&gt;Recv and deals with errors in a server specific way <br/>
 Use this INSTEAD OF socketUDP-&gt;Recv, never use socketUDP-&gt;Recv directly</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad484dd6b0de0014bafe361ba4b8aa19a"></a><!-- doxytag: member="clServerState::ErrorOccurred" ref="ad484dd6b0de0014bafe361ba4b8aa19a" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::ErrorOccurred </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deals with error <br/>
 Client <em>clientID</em> is disconnected </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to disconnected, if 0 then no action is taken </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_core.html#ad5359146ac131598d7f6b86e10577738">clInstanceCore</a>.</p>

</div>
</div>
<a class="anchor" id="a6ff5552b881351ef18fc33df532c2ad6"></a><!-- doxytag: member="clServerState::FindClientByAddressUDP" ref="a6ff5552b881351ef18fc33df532c2ad6" args="(size_t threadID, const clSingleAddr &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::FindClientByAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches all connected clients and determines if <em>addr</em> is a remote UDP address for one of them, if it is then the client is connected via UDP. This method is used as part of the <a class="el" href="handshake_page.html">handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no client was found </dd>
<dd>
&gt;0 if client was found, this is the client ID of the client </dd></dl>

</div>
</div>
<a class="anchor" id="ac139ec3acb06e1b28744339cbb9710d6"></a><!-- doxytag: member="clServerState::FlushRecvTCP" ref="ac139ec3acb06e1b28744339cbb9710d6" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all fully received TCP packets from the packet queue <br/>
 Has no impact on the partial packet store </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#af99126459308bfabf259aa9a2170a36b">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a3e804dd8e1d0fb5ce0307f461d5a1e5e"></a><!-- doxytag: member="clServerState::FlushRecvUDP" ref="a3e804dd8e1d0fb5ce0307f461d5a1e5e" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::FlushRecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all fully received UDP packets from the packet queue <br/>
 Has no impact on the partial packet store </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>reimplemented to enforce multithreaded control rules </dd></dl>

</div>
</div>
<a class="anchor" id="a40e9658d157664d28b4ff6764653ee52"></a><!-- doxytag: member="clServerState::GetAutoResizeTCP" ref="a40e9658d157664d28b4ff6764653ee52" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clServerState::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a2680e4844a26f13f593634982fb77343">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a417e525b8f5cd73c2051bf32040334cc"></a><!-- doxytag: member="clServerState::GetClientLocalAddressTCP" ref="a417e525b8f5cd73c2051bf32040334cc" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clServerState::GetClientLocalAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="ac464bdb2b462528f5e08d8d044e052d5"></a><!-- doxytag: member="clServerState::GetConnectAddressTCP" ref="ac464bdb2b462528f5e08d8d044e052d5" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clServerState::GetConnectAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#ad702ce7451f0c80a59861b13c9a4d5d8">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ab76e0a98a18b26f5c9c90a2c30127228"></a><!-- doxytag: member="clServerState::GetConnectAddressUDP" ref="ab76e0a98a18b26f5c9c90a2c30127228" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clServerState::GetConnectAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

</div>
</div>
<a class="anchor" id="a1823d201b34aa75de541a7c14bd1d774"></a><!-- doxytag: member="clServerState::GetDisconnect" ref="a1823d201b34aa75de541a7c14bd1d774" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetDisconnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a client from the disconnect list, this client has been recently disconnected </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>client ID </dd></dl>

</div>
</div>
<a class="anchor" id="ad0e980f5aa1e93270092d67412aa2684"></a><!-- doxytag: member="clServerState::GetEnabledUDP" ref="ad0e980f5aa1e93270092d67412aa2684" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clServerState::GetEnabledUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if UDP is enabled, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a3458bc8c0e335c67243fe5f4225bc5e5"></a><!-- doxytag: member="clServerState::GetGracefulDisconnectEnabled" ref="a3458bc8c0e335c67243fe5f4225bc5e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clServerState::GetGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if true graceful disconnection is possible, where data is allowed to finish sending and receiving before the connection is closed </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#aad5a5af8e7fa2b973dc7b3ae6ba82dd4">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a43b1ac7de146c88e64bfeacb277a2b8f"></a><!-- doxytag: member="clServerState::GetLocalAddressTCP" ref="a43b1ac7de146c88e64bfeacb277a2b8f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp; clServerState::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP local address information of the specified client. This reference will remain valid and unmodified until the next call. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>is okay to return reference because <a class="el" href="classcl_single_addr.html" title="Stores a single address with IP and port.">clSingleAddr</a> is thread safe </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a16f0d87a9b4f577ae81b4f9fc3a3b182">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a78cca781121c231c27b705ac04aa90c3"></a><!-- doxytag: member="clServerState::GetMaxClients" ref="a78cca781121c231c27b705ac04aa90c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetMaxClients </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum number of clients that can be connected to the server at any one time (<code>maxClients</code>) <br/>
 Client IDs range from 1 inclusive to this value inclusive, client ID 0 is not used </dd></dl>

</div>
</div>
<a class="anchor" id="ae65f7e9ed108d2ceee3e803be4663e21"></a><!-- doxytag: member="clServerState::GetMaxPacketSizeTCP" ref="ae65f7e9ed108d2ceee3e803be4663e21" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a50e7cc70cb2e6e8a717c8f8fb6b4f21a">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aa2bbcc834edc34008fa234a62e70e72c"></a><!-- doxytag: member="clServerState::GetModeUDP" ref="aa2bbcc834edc34008fa234a62e70e72c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clServerState::GetModeUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the UDP protocol mode in use, describing how data is manipulated during sending and receiving </dd></dl>

</div>
</div>
<a class="anchor" id="a6293150ae0d2deee1e853e8de2fc6549"></a><!-- doxytag: member="clServerState::GetPacketAmountTCP" ref="a6293150ae0d2deee1e853e8de2fc6549" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetPacketAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of fully received TCP packets in the packet store </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a193776679f0af0fdb98ac91c6db6f3d1">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ac5219f6dfbf0a4fc46c2f0b10f4777a4"></a><!-- doxytag: member="clServerState::GetPacketAmountUDP" ref="ac5219f6dfbf0a4fc46c2f0b10f4777a4" args="(size_t threadID, size_t clientID, size_t operationID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetPacketAmountUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in the packet store </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>operation ID of operation to use, may be ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>reimplemented to enforce multithreaded control rules </dd></dl>

</div>
</div>
<a class="anchor" id="a434b7015edbb25a83593e60f7ee6f0f7"></a><!-- doxytag: member="clServerState::GetPacketFromStoreTCP" ref="a434b7015edbb25a83593e60f7ee6f0f7" args="(size_t threadID, size_t clientID, clPacket *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetPacketFromStoreTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a complete packet from the TCP packet store and copies it into <em>destination</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>destination to copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#afd639273cee92d3c612c40c761ec6d5b">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="acd70ba0bd1cf45ddc0f30cda86a1fbc5"></a><!-- doxytag: member="clServerState::GetPacketFromStoreUDP" ref="acd70ba0bd1cf45ddc0f30cda86a1fbc5" args="(size_t threadID, size_t clientID, size_t operationID, clPacket *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetPacketFromStoreUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a complete packet from the TCP packet store and copies it into <em>destination</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to use </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>destination to copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of packets in packet store before this method call </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>reimplemented to enforce multithreaded control rules </dd></dl>

</div>
</div>
<a class="anchor" id="a657be97242d234350f5d5193bf1323fd"></a><!-- doxytag: member="clServerState::GetPartialPacketCurrentSizeTCP" ref="a657be97242d234350f5d5193bf1323fd" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetPartialPacketCurrentSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current size of the TCP partial packet being received <br/>
 i.e. the number of bytes of the packet that have been received </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#aafa9f7579aaf64c135d0a386da496e07">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="aaedff3aeda921ce765c0d92a116d34b3"></a><!-- doxytag: member="clServerState::GetProtocolModeTCP" ref="aaedff3aeda921ce765c0d92a116d34b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clServerState::GetProtocolModeTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>protocol mode in use by instance </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a80ec758cf218a01fa6ad5ca77289b11a">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a25076fc19a70980db2d575a0e0d4fb8c"></a><!-- doxytag: member="clServerState::GetRecvBufferLengthTCP" ref="a25076fc19a70980db2d575a0e0d4fb8c" args="(size_t threadID, size_t clientID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetRecvBufferLengthTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF used by the TCP socket. <br/>
 This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#ac813fb12b20efbae4b5ea266309bfa85">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a5c90cd631cdc4b2cd323e553433d4d16"></a><!-- doxytag: member="clServerState::GetRecvSizeMinTCP" ref="a5c90cd631cdc4b2cd323e553433d4d16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetRecvSizeMinTCP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum size that the TCP receive buffer can be set to </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a14fbd5458779f3f5a569e8aa57362ee7">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="af58617f6176dafbd31bf7518f28caffe"></a><!-- doxytag: member="clServerState::GetRecvSizeMinUDP" ref="af58617f6176dafbd31bf7518f28caffe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetRecvSizeMinUDP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum size that the UDP receive buffer can be set to </dd></dl>

</div>
</div>
<a class="anchor" id="a31a4202c942e75d35bc5cfd325e383fd"></a><!-- doxytag: member="clServerState::GetServerInfo" ref="a31a4202c942e75d35bc5cfd325e383fd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcl_packet.html">clPacket</a> &amp; clServerState::GetServerInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>packet containing information about the server </dd></dl>

</div>
</div>
<a class="anchor" id="a8aa76c5f0ae3202e74f3c85bb62a1710"></a><!-- doxytag: member="clServerState::GetServerTimeout" ref="a8aa76c5f0ae3202e74f3c85bb62a1710" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clServerState::GetServerTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of milliseconds that connection attempt should be allowed to complete before entity is forcefully disconnected </dd></dl>

</div>
</div>
<a class="anchor" id="a8752bfaf6e69d575f483fb09ad2d1ade"></a><!-- doxytag: member="clServerState::init" ref="a8752bfaf6e69d575f483fb09ad2d1ade" args="(size_t maxClients, bool handshakeEnabled, size_t connectionTimeout, clSocketListening *socketListening)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::init </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>p_handshakeEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>p_connectionTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_socket_listening.html">clSocketListening</a> *&nbsp;</td>
          <td class="paramname"> <em>p_socketListening</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes object, used by constructors </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_maxClients</em>&nbsp;</td><td>maximum number of clients that can be connected to server at any one time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_handshakeEnabled</em>&nbsp;</td><td>true if the TCP handshaking process is enabled, false if not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_connectionTimeout</em>&nbsp;</td><td>time in milliseconds that a connection attempt will be waited on before giving up (optional, default DEFAULT_CONNECTION_TIMEOUT) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_socketListening</em>&nbsp;</td><td>socket to use to listen for new TCP connections </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>socketUDP must be initialized before using this method (is done in super class constructor) </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if p_socketListening-&gt;GetSocket()-&gt;GetMode()-&gt;GetMaxPacketSize() &lt; <a class="el" href="classcl_server_state.html#a5c90cd631cdc4b2cd323e553433d4d16">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

<p><p>Server info packet contains: 1: Maximum number of clients 2: Number of operations (UDP only) 3: UDP Mode (UDP only)</p>
</p>

</div>
</div>
<a class="anchor" id="ab3abf9a84501271ce55c2b1eda4d5fa3"></a><!-- doxytag: member="clServerState::SendAllTCP" ref="ab3abf9a84501271ce55c2b1eda4d5fa3" args="(size_t threadID, const clPacket &amp;packet, bool block, size_t clientExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SendAllTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>excludeClient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via TCP to specified client </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExclude</em>&nbsp;</td><td>clientID of client not to send to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53e069f3cc1bc74202704ffb75e398f1"></a><!-- doxytag: member="clServerState::SendAllUDP" ref="a53e069f3cc1bc74202704ffb75e398f1" args="(size_t threadID, const clPacket &amp;packet, bool block, size_t clientExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SendAllUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>excludeClient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via UDP to all connected clients </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExclude</em>&nbsp;</td><td>clientID of client not to send to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa26a11694b770b75c58e3a5931fd387e"></a><!-- doxytag: member="clServerState::SendTCP" ref="aa26a11694b770b75c58e3a5931fd387e" args="(size_t threadID, size_t clientID, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clServerState::SendTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via TCP to specified client </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to send to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a155def07aa6e36251e3d629111a70bc4">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ac2f8e109ed5f86a2feaebc04d2379b45"></a><!-- doxytag: member="clServerState::SendToUDP" ref="ac2f8e109ed5f86a2feaebc04d2379b45" args="(size_t threadID, const clSingleAddr &amp;address, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clServerState::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends <em>packet</em> via UDP to specified address </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>remote address to send to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent to all clients, note that this does not indicate that the packet has been received by all clients, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="a4c582a5907e427eb0091079bd4ada3b0"></a><!-- doxytag: member="clServerState::SendUDP" ref="a4c582a5907e427eb0091079bd4ada3b0" args="(size_t threadID, size_t clientID, const clPacket &amp;packet, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clServerState::SendUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a packet using this socket </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to send to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>if true the method will not return until <em>packet</em> is completely sent, note that this does not indicate that the packet has been received by the recipient, instead it simply means the packet is in transit. <br/>
 If false the method will return instantly even if the packet has not been sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="a0c6c0c0c2db0181c66945c649ff016d4"></a><!-- doxytag: member="clServerState::SetAutoResize" ref="a0c6c0c0c2db0181c66945c649ff016d4" args="(size_t threadID, bool autoResize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SetAutoResize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>paraAutoResize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the auto resize option for all clients <br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paraAutoResize</em>&nbsp;</td><td>if true then if a packet larger than the maximum is received, the maximum will be increased silently <br/>
 if false then an exception will be thrown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa324f4af4421895f4c06fed536826d40"></a><!-- doxytag: member="clServerState::SetAutoResizeTCP" ref="aa324f4af4421895f4c06fed536826d40" args="(size_t threadID, size_t clientID, bool newAutoResizeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>newAutoResizeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newAutoResizeTCP</em>&nbsp;</td><td>When true, if a packet larger than the max TCP packet size is received then the max size will be increased silently. When false, in this case an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#aa2f17e01ca732a1692d5c1abab70f343">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ae2bc69bbd2bff4071cb148da272bfe95"></a><!-- doxytag: member="clServerState::SetContainer" ref="ae2bc69bbd2bff4071cb148da272bfe95" args="(clInstanceContainer *container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SetContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <a class="el" href="classcl_instance_container.html" title="Stores instances, allowing safe shutdown of instance.">clInstanceContainer</a> object containing this instance, <a class="el" href="classcl_instance_container.html" title="Stores instances, allowing safe shutdown of instance.">clInstanceContainer</a> should pass pointer to itself </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>container</em>&nbsp;</td><td>instance container that owns this instance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_core.html#ad2eda53d7f3ba76c2fef2d08e868b81c">clInstanceCore</a>.</p>

</div>
</div>
<a class="anchor" id="a69575a84cd634b4105187cb1644a9fe9"></a><!-- doxytag: member="clServerState::SetMaxPacketSizeTCP" ref="a69575a84cd634b4105187cb1644a9fe9" args="(size_t threadID, size_t clientID, size_t newMaxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SetMaxPacketSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newMaxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manually changes the maximum packet size that can be received </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newMaxSize</em>&nbsp;</td><td>The size of the largest packet that can be received, packets larger than this will require an increase in memory size or an exception will be thrown </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structcl_error.html">clError</a></em>&nbsp;</td><td>if newMaxSize &lt; <a class="el" href="classcl_server_state.html#a5c90cd631cdc4b2cd323e553433d4d16">GetRecvSizeMinTCP()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#a614c842749f0dadca9da9aa825323c2e">clInstanceTCP</a>.</p>

</div>
</div>
<a class="anchor" id="afc302a2ceb465e93a8e1396c1c69978d"></a><!-- doxytag: member="clServerState::SetServerTimeout" ref="afc302a2ceb465e93a8e1396c1c69978d" args="(size_t milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::SetServerTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>milliseconds</em>&nbsp;</td><td>number of milliseconds that connection attempt should be allowed to complete before entity is forcefully disconnected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6bb7ca048e12e276cfa85798bbca305"></a><!-- doxytag: member="clServerState::ShutdownTCP" ref="ab6bb7ca048e12e276cfa85798bbca305" args="(size_t threadID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clServerState::ShutdownTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops sending on TCP socket so that all further send operations will fail <br/>
 All data sent up till now will be received by recipient. <br/>
 This method is part of the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread using this object. If not used by completion port then should be set to <a class="el" href="classcl_networking_utility.html#acb6168b9acdc70baeb9bc0fe7c5196bb">clNetworkingUtility::GetMainProcessThreadID()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcl_instance_t_c_p.html#acb97c70b1a0cdba98fd4ac0a658ed6ec">clInstanceTCP</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4d04e7fec349fb69ac9d7d4278c7e915"></a><!-- doxytag: member="clServerState::client" ref="a4d04e7fec349fb69ac9d7d4278c7e915" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_store_vector.html">clStoreVector</a>&lt;<a class="el" href="classcl_s_client.html">clSClient</a>&gt; <a class="el" href="classcl_server_state.html#a4d04e7fec349fb69ac9d7d4278c7e915">clServerState::client</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Client data <br/>
 A vector of <a class="el" href="classcl_s_client.html" title="object stores and manages individual clients">clSClient</a> objects </p>

</div>
</div>
<a class="anchor" id="aa61be479aa559af84ebad2a136c2173b"></a><!-- doxytag: member="clServerState::DEFAULT_CONNECTION_TIMEOUT" ref="aa61be479aa559af84ebad2a136c2173b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcl_server_state.html#aa61be479aa559af84ebad2a136c2173b">clServerState::DEFAULT_CONNECTION_TIMEOUT</a> = 10000<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default time in milliseconds that a connection attempt will be waited on before giving up </p>

</div>
</div>
<a class="anchor" id="a1928a46878962bc4d2c804bf21074319"></a><!-- doxytag: member="clServerState::disconnected" ref="a1928a46878962bc4d2c804bf21074319" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_store_queue.html">clStoreQueue</a>&lt;size_t&gt; <a class="el" href="classcl_server_state.html#a1928a46878962bc4d2c804bf21074319">clServerState::disconnected</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of recently disconnected clients to be used by <code>mnClientLeft</code> </p>

</div>
</div>
<a class="anchor" id="a78bea97e597f0122863a4ee259a24785"></a><!-- doxytag: member="clServerState::maxClients" ref="a78bea97e597f0122863a4ee259a24785" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_server_state.html#a78bea97e597f0122863a4ee259a24785">clServerState::maxClients</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of clients that can be connected to server at any one time </p>

</div>
</div>
<a class="anchor" id="a375603ab73421b96cfe100570d86300d"></a><!-- doxytag: member="clServerState::recvFailCounterUDP" ref="a375603ab73421b96cfe100570d86300d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_counter.html">clCounter</a> <a class="el" href="classcl_server_state.html#a375603ab73421b96cfe100570d86300d">clServerState::recvFailCounterUDP</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counter that keeps track of UDP receive failures, WSARecv can sometimes fail for reasons that should not result in catastrophic failure of the instance e.g. a WSASendTo operation to a remote address failed. For this reason we retry receive operations a number of times, when to give up is managed by this object. </p>

</div>
</div>
<a class="anchor" id="a6f718c1f7be5673a45d04df644f7ce5b"></a><!-- doxytag: member="clServerState::recvSizeMinTCP" ref="a6f718c1f7be5673a45d04df644f7ce5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcl_server_state.html#a6f718c1f7be5673a45d04df644f7ce5b">clServerState::recvSizeMinTCP</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum TCP buffer size necessary to maintain normal operations </p>

</div>
</div>
<a class="anchor" id="ae6d8460b8b124c1ece70b94440cea634"></a><!-- doxytag: member="clServerState::recvSizeMinUDP" ref="ae6d8460b8b124c1ece70b94440cea634" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcl_server_state.html#ae6d8460b8b124c1ece70b94440cea634">clServerState::recvSizeMinUDP</a> = 20<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum UDP buffer size necessary to maintain normal operations </p>

</div>
</div>
<a class="anchor" id="a65f672655a8b980a21e84d939ad81841"></a><!-- doxytag: member="clServerState::serverInfo" ref="a65f672655a8b980a21e84d939ad81841" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_packet.html">clPacket</a> <a class="el" href="classcl_server_state.html#a65f672655a8b980a21e84d939ad81841">clServerState::serverInfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Packet contains data that is sent to clients upon connection, The data describes key characteristics of the server </p>

</div>
</div>
<a class="anchor" id="a5420d87b6c3e42c7ab033d00273ffe51"></a><!-- doxytag: member="clServerState::socketListening" ref="a5420d87b6c3e42c7ab033d00273ffe51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_socket_listening.html">clSocketListening</a>* <a class="el" href="classcl_server_state.html#a5420d87b6c3e42c7ab033d00273ffe51">clServerState::socketListening</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Socket used to accept TCP connections from clients </p>

</div>
</div>
<a class="anchor" id="ad8a53992b7a622816eeb6b70fd4fec25"></a><!-- doxytag: member="clServerState::timeout" ref="ad8a53992b7a622816eeb6b70fd4fec25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_status.html">clStatus</a>&lt;size_t&gt; <a class="el" href="classcl_server_state.html#ad8a53992b7a622816eeb6b70fd4fec25">clServerState::timeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Time in milliseconds that a connection attempt will be waited on before giving up </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_server_state_8h_source.html">clServerState.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clServerState.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:08 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
