<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clSharedProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>clSharedProtocol Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clSharedProtocol" -->
<p>Protocol interface inherited by protocol objects such as <a class="el" href="classcl_shared_u_d_p.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">clSharedUDP</a> and <a class="el" href="classcl_shared_t_c_p.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">clSharedTCP</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_shared_protocol_8h_source.html">clSharedProtocol.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clSharedProtocol:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_shared_protocol.png" usemap="#clSharedProtocol_map" alt=""/>
  <map id="clSharedProtocol_map" name="clSharedProtocol_map">
<area href="classcl_shared_t_c_p.html" alt="clSharedTCP" shape="rect" coords="60,56,171,80"/>
<area href="classcl_shared_u_d_p.html" alt="clSharedUDP" shape="rect" coords="302,56,413,80"/>
<area href="classcl_int_prefix_t_c_p.html" alt="clIntPrefixTCP" shape="rect" coords="0,112,111,136"/>
<area href="classcl_postfix_t_c_p.html" alt="clPostfixTCP" shape="rect" coords="121,112,232,136"/>
<area href="classcl_catch_all_u_d_p.html" alt="clCatchAllUDP" shape="rect" coords="242,112,353,136"/>
<area href="classcl_per_client_u_d_p.html" alt="clPerClientUDP" shape="rect" coords="363,112,474,136"/>
<area href="classcl_catch_all_no_u_d_p.html" alt="clCatchAllNoUDP" shape="rect" coords="242,168,353,192"/>
</map>
</div>

<p><a href="classcl_shared_protocol-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47ba9f62bd1b819b8a5d53e6f0b679495c61">TM_SIZE</a>, 
<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47ba399adc08f122d7c09a83610197d24666">TM_RN</a>, 
<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47babacdf5be8acea89eddc85f01f7b74018">UM_PER_CLIENT</a>, 
<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47ba85523bd746d838b1620e0c4fc3da392e">UM_PER_CLIENT_PER_OPERATION</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47ba5315dd28370f0e13b26603c1b0a17c21">UM_CATCH_ALL</a>, 
<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47ba5780629b78f91735d369000983ce955e">UM_CATCH_ALL_NO</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcl_shared_send.html">clSharedSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#ae8ba1c07871850b15abc9d15ec475d8e">GetSendObject</a> (const <a class="el" href="classcl_packet.html">clPacket</a> *packet, bool block)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a473332c76ea2409937925e2390ac96a1">GetProtocolMode</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a2b6f3bd561af01c5ef02b06ebe24c5a0">DealWithData</a> (size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> recvFunc)=0</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#aac70aa1c3585a28ad5a4b502a0ba1153">ConvertToProtocolModeTCP</a> (int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a59665ab24750d32171d8cb7ccac25898">ConvertToProtocolModeUDP</a> (int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#acabf37df7540794029e577e1c32f6e95">ConvertToProtocolMode</a> (int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a0a087713788c58088aaac8331d70c74e">ValidateProtocolModeTCP</a> (<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_shared_protocol.html#a42d981813f39d61c52842c7ac361cb5d">ValidateProtocolModeUDP</a> (<a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a> mode)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Protocol interface inherited by protocol objects such as <a class="el" href="classcl_shared_u_d_p.html" title="UDP protocol class, provides a base for extensions to the protocol by UDP mode classes.">clSharedUDP</a> and <a class="el" href="classcl_shared_t_c_p.html" title="TCP protocol class, provides a base for extensions to the protocol by TCP mode classes.">clSharedTCP</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>Makes up the skeleton of a protocol object, providing virtual methods that are common to all protocol objects </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47b"></a><!-- doxytag: member="clSharedProtocol::ProtocolMode" ref="a4b0b9c82b8ae4eee78c6308c35afd47b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to identify what TCP or UDP mode is in use </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47ba9f62bd1b819b8a5d53e6f0b679495c61"></a><!-- doxytag: member="TM_SIZE" ref="a4b0b9c82b8ae4eee78c6308c35afd47ba9f62bd1b819b8a5d53e6f0b679495c61" args="" -->TM_SIZE</em>&nbsp;</td><td>
<p>A prefix of type size_t is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix indicates the amount of additional data (not including the prefix) that is in the packet. The prefix is not included as part of received packets. e.g. If the prefix of size_t is of value 10, then the actual packet's size is 10 + 8 which is 18. <br/>
<br/>
</p>
<p>Packets received are put into a queue and none are discarded.<br/>
<br/>
 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47ba399adc08f122d7c09a83610197d24666"></a><!-- doxytag: member="TM_RN" ref="a4b0b9c82b8ae4eee78c6308c35afd47ba399adc08f122d7c09a83610197d24666" args="" -->TM_RN</em>&nbsp;</td><td>
<p>A postfix which can consist of any data is automatically appended to the end of all packets being sent. Packets being received are expected to have this postfix and problems will occur if they don't. The postfix indicates the end of the packet and is not included as part of received packets.<br/>
<br/>
</p>
<p>Packets received are put into a queue and none are discarded.<br/>
<br/>
 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47babacdf5be8acea89eddc85f01f7b74018"></a><!-- doxytag: member="UM_PER_CLIENT" ref="a4b0b9c82b8ae4eee78c6308c35afd47babacdf5be8acea89eddc85f01f7b74018" args="" -->UM_PER_CLIENT</em>&nbsp;</td><td>
<p>A prefix of clock() is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is used to determine the age of the packet. clock() increments every millisecond and therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>In addition to this, the server (and only the server) must manually add the following prefix to the start of each packet:</p>
<ul>
<li>size_t: indicates the client that the packet is referring to. On the receiving end, the packet will then appear in that client's packet store without this prefix.<br/>
<br/>
</li>
</ul>
<p>On the client and server side there is a packet store for each client which stores the newest packet received from that client (in the case of server state) or referring to that client (in the case of client state). Each store contains only one packet, reducing the overhead of a queue.<br/>
<br/>
</p>
<p>This UDP mode is good where data can be organized into a per client basis and can be more efficient than UM_CATCH_ALL or UM_CATCH_ALL_NO due to there being no queue. Note that some in order packets may be discarded since there is no queue.<br/>
<br/>
 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47ba85523bd746d838b1620e0c4fc3da392e"></a><!-- doxytag: member="UM_PER_CLIENT_PER_OPERATION" ref="a4b0b9c82b8ae4eee78c6308c35afd47ba85523bd746d838b1620e0c4fc3da392e" args="" -->UM_PER_CLIENT_PER_OPERATION</em>&nbsp;</td><td>
<p>A prefix of clock() is automatically added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is used to determine the age of the packet. clock() increments every millisecond and therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>In addition to this, the server (and only the server) must manually add the following prefix to the start of each packet in the below order:</p>
<ul>
<li>size_t: client ID indicating the client that the packet is referring to. On the receiving end, the packet will then appear in that client's packet store without this part of the prefix.</li>
<li>size_t: operation ID indicating the operation that the packet applies to. On the receiving end, the packet will then appear in the packet store for that operation without this part of the prefix.<br/>
<br/>
</li>
</ul>
<p>The client (and only the client) must manually add the following prefix to the start of each packet in the below order:</p>
<ul>
<li>size_t: operation ID indicating the operation that the packet applies to. On the receiving end, the packet will then appear in the packet store for that operation without this prefix.<br/>
<br/>
</li>
</ul>
<p>On the client and server side there is a packet store for each client and each operation which stores the newest packet received from that client for that operation (in the case of server state) or referring to that client for that operation (in the case of client state). Each store contains only one packet, reducing the overhead of a queue. The packet store can be thought of as a 2D array which looks like: packetStore[maxClients][numOperations].<br/>
<br/>
</p>
<p>This UDP mode is good where data can be organized into a per client, per operation basis and can be more efficient than UM_CATCH_ALL or UM_CATCH_ALL_NO due to there being no queue. Note that some in order packets may be discarded since there is no queue.<br/>
<br/>
 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47ba5315dd28370f0e13b26603c1b0a17c21"></a><!-- doxytag: member="UM_CATCH_ALL" ref="a4b0b9c82b8ae4eee78c6308c35afd47ba5315dd28370f0e13b26603c1b0a17c21" args="" -->UM_CATCH_ALL</em>&nbsp;</td><td>
<p>The packet is sent unmodified and packets received are transfered straight to the application. This is unmodified UDP transfer and so out of order packets may be received. In addition this connection packets may be received in server state, as the client blasts UDP packets to the server which may arrive late, after the connection has completed. These packets always have a prefix of size_t of value 0. You can use this to single them out and discard them. For more information see the <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4b0b9c82b8ae4eee78c6308c35afd47ba5780629b78f91735d369000983ce955e"></a><!-- doxytag: member="UM_CATCH_ALL_NO" ref="a4b0b9c82b8ae4eee78c6308c35afd47ba5780629b78f91735d369000983ce955e" args="" -->UM_CATCH_ALL_NO</em>&nbsp;</td><td>
<p>A prefix of size_t is added to the start of all packets being sent. Packets being received are expected to have this prefix and problems will occur if they don't. The prefix is a counter which increments by 1 with every send operation. Therefore the higher the prefix the newer the packet. A record is kept of the newest packet received and any packets with a prefix lower than that are discarded as they are deemed out of order. Received packets will not have this prefix. <br/>
<br/>
</p>
<p>Received packets are put into a queue and no in order packets are discarded.<br/>
<br/>
 </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acabf37df7540794029e577e1c32f6e95"></a><!-- doxytag: member="clSharedProtocol::ConvertToProtocolMode" ref="acabf37df7540794029e577e1c32f6e95" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clSharedProtocol::ConvertToProtocolMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts integer into enum for ProtocolMode </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>integer to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum equivalent of <em>mode</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aac70aa1c3585a28ad5a4b502a0ba1153"></a><!-- doxytag: member="clSharedProtocol::ConvertToProtocolModeTCP" ref="aac70aa1c3585a28ad5a4b502a0ba1153" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clSharedProtocol::ConvertToProtocolModeTCP </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts integer into enum for ProtocolMode </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>integer to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum equivalent of <em>mode</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a59665ab24750d32171d8cb7ccac25898"></a><!-- doxytag: member="clSharedProtocol::ConvertToProtocolModeUDP" ref="a59665ab24750d32171d8cb7ccac25898" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">clSharedProtocol::ProtocolMode</a> clSharedProtocol::ConvertToProtocolModeUDP </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts integer into enum for ProtocolMode </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>integer to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum equivalent of <em>mode</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b6f3bd561af01c5ef02b06ebe24c5a0"></a><!-- doxytag: member="clSharedProtocol::DealWithData" ref="a2b6f3bd561af01c5ef02b06ebe24c5a0" args="(size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, clInstanceCore::RecvFunc recvFunc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clSharedProtocol::DealWithData </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread that packet was received on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>size of packet stored in <em>buffer</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>where newly received packet is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that packet was received from, 0 in client state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>instance that packet was received on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em></em>&nbsp;</td><td>method will be executed and data not added to the queue if this is non NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcl_int_prefix_t_c_p.html#afed2d255e78f2e77e4a7f08ace22e5a9">clIntPrefixTCP</a>, and <a class="el" href="classcl_per_client_u_d_p.html#acf380c1466abb6941edb950801d09b20">clPerClientUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a473332c76ea2409937925e2390ac96a1"></a><!-- doxytag: member="clSharedProtocol::GetProtocolMode" ref="a473332c76ea2409937925e2390ac96a1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a> clSharedProtocol::GetProtocolMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the protocol mode in use, describing how data is manipulated during sending and receiving </dd></dl>

<p>Implemented in <a class="el" href="classcl_catch_all_no_u_d_p.html#a93dceb605e7c892975772958e91f44b4">clCatchAllNoUDP</a>, <a class="el" href="classcl_catch_all_u_d_p.html#adacc5977909396017910dcb3ab44c395">clCatchAllUDP</a>, <a class="el" href="classcl_int_prefix_t_c_p.html#ae0abbe8a74edfe679b04df354aa023ec">clIntPrefixTCP</a>, <a class="el" href="classcl_per_client_u_d_p.html#aa0f2be71b5dac611c2a6c6fd8b17c00a">clPerClientUDP</a>, and <a class="el" href="classcl_postfix_t_c_p.html#a109cb621bfff71084c7e07ae580c4c5c">clPostfixTCP</a>.</p>

</div>
</div>
<a class="anchor" id="ae8ba1c07871850b15abc9d15ec475d8e"></a><!-- doxytag: member="clSharedProtocol::GetSendObject" ref="ae8ba1c07871850b15abc9d15ec475d8e" args="(const clPacket *packet, bool block)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcl_shared_send.html">clSharedSend</a>* clSharedProtocol::GetSendObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_packet.html">clPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a send object formatted for the specific protocol and mode </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>packet to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>true if sending should be synchronous, false if sending should be asynchronous </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcl_catch_all_no_u_d_p.html#ab617cfaf8427e415c591518fe36b95af">clCatchAllNoUDP</a>, <a class="el" href="classcl_catch_all_u_d_p.html#a6651f3534e139451f9bbabe16e00671c">clCatchAllUDP</a>, <a class="el" href="classcl_int_prefix_t_c_p.html#ae6f1975b0ccd8939ccbede12bad64fd9">clIntPrefixTCP</a>, <a class="el" href="classcl_per_client_u_d_p.html#a33f25535cfef99e9abe9b2556928f364">clPerClientUDP</a>, and <a class="el" href="classcl_postfix_t_c_p.html#a58ffdd4db7b50d29247969df69d93679">clPostfixTCP</a>.</p>

</div>
</div>
<a class="anchor" id="a0a087713788c58088aaac8331d70c74e"></a><!-- doxytag: member="clSharedProtocol::ValidateProtocolModeTCP" ref="a0a087713788c58088aaac8331d70c74e" args="(ProtocolMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSharedProtocol::ValidateProtocolModeTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>protocol mode to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if protocol mode is a valid TCP mode, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a42d981813f39d61c52842c7ac361cb5d"></a><!-- doxytag: member="clSharedProtocol::ValidateProtocolModeUDP" ref="a42d981813f39d61c52842c7ac361cb5d" args="(ProtocolMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSharedProtocol::ValidateProtocolModeUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_shared_protocol.html#a4b0b9c82b8ae4eee78c6308c35afd47b">ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>protocol mode to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if protocol mode is a valid UDP mode, false if not </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_shared_protocol_8h_source.html">clSharedProtocol.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clSharedProtocol.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:08 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
