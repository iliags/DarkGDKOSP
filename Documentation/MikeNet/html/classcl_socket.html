<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: clSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>clSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="clSocket" --><!-- doxytag: inherits="clSimpleSocket" -->
<p>Socket class providing more advanced functionality common to all protocols.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_socket_8h_source.html">clSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_socket.png" usemap="#clSocket_map" alt=""/>
  <map id="clSocket_map" name="clSocket_map">
<area href="classcl_simple_socket.html" alt="clSimpleSocket" shape="rect" coords="53,0,150,24"/>
<area href="classcl_socket_t_c_p.html" alt="clSocketTCP" shape="rect" coords="0,112,97,136"/>
<area href="classcl_socket_u_d_p.html" alt="clSocketUDP" shape="rect" coords="107,112,204,136"/>
</map>
</div>

<p><a href="classcl_socket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#aea097250d267f081b56c0bcda48e210f">clSocket</a> (size_t bufferLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a331fae974dc5e685d4814e2f2254208d">clSocket</a> (size_t bufferLength, <a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a9872767d3f8a21f6568b4a79c3bddee4">~clSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#ad5702fb888ecb38b07eb536273aa5414">clSocket</a> (const <a class="el" href="classcl_socket.html">clSocket</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_socket.html">clSocket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a04028c4342b924ffc1a6749c35d57c32">operator=</a> (const <a class="el" href="classcl_socket.html">clSocket</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a63910e1657650a9ff3e8c8cb6045e689">_DefaultVars</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a87f0f9dfc4b26d21efc45a3551ab988b">RemoveSend</a> (const OVERLAPPED *operation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#ae28db191f5750e83f187e37939b596ad">RemoveSend</a> (size_t element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#aacb725d66067230ade23633e34a0d02d">AddSend</a> (<a class="el" href="classcl_shared_send.html">clSharedSend</a> *send)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a2398b25d1c446b27f55f2e12632a0f17">ClearSend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#adfe8b1383f71d3569be05859ba1d55bd">FindSend</a> (const OVERLAPPED *operation) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#abdf3ff3b62ae2401576e5ae294ef53e3">SendEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a5ff0b79fb0cb1c43019e726ea085ec36">Close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a68a48be55c5638db5fbf61d652318de4">AssociateSocketCompletionPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a45284c4d4679469dd9cf11cf08faa86c">ClearRecv</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf64bc817795c6fcd5dd5f28c8ab6abb"></a><!-- doxytag: member="clSocket::Recv" ref="abf64bc817795c6fcd5dd5f28c8ab6abb" args="()=0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>Recv</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a6645de6f69b91fdf30b0195c221e4e7c">Send</a> (<a class="el" href="classcl_shared_send.html">clSharedSend</a> &amp;sendObject, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> *sendToAddr, unsigned int timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24c3eed54aabf41a4447b7d63b2f39f"></a><!-- doxytag: member="clSocket::Send" ref="ac24c3eed54aabf41a4447b7d63b2f39f" args="(const clPacket &amp;packet, bool block, const clSingleAddr *sendToAddr, unsigned int timeout)=0" -->
virtual <br class="typebreak"/>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>Send</b> (const <a class="el" href="classcl_packet.html">clPacket</a> &amp;packet, bool block, const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> *sendToAddr, unsigned int timeout)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a1652cf24e9f2a5d83a463da184903f4f">GetRecvBufferLength</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a46bfeb517dceec7b2dfb72f77e1a6c99">IsOurOverlapped</a> (const WSAOVERLAPPED *overlapped) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcl_simple_socket.html#affcd3d22c1abba5d20a0ae93472c576d">Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a8ce9d2d6fa68c1d70fa757122093f7ca">GetProtocol</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a4ddfb1b3168816c667e1193d1df42535">DealWithData</a> (size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, <a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a> recvFunc)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#ab024e22508a2490cc4e41ca285adc55f">GetCompletionPortCloseRequest</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a2ab21e84af02b22496fcc2e60549e9ce">CompletionPortRequestClose</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#aadcd5e50e5dd9495e433a3be3ff69c31">SetCompletionPortFinishRecvNotification</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_completion_key.html">clCompletionKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a13f7fb8c9c146df5b8b63a861b1d9b05">completionKey</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WSAOVERLAPPED&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#aec458d824ec2454b0db2869fc8f87623">recvOverlapped</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WSABUF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#aa33f69522e06a1ddaaf589cb21f0f60d">recvBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DWORD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a3d6b17db1b4743a14efcf02205113ae8">flags</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a8088a2405e76acca3b41175552bc0f6c">SetOverlappedEvent</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_status.html">clStatus</a>&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a119bea012ab04183f3a796a295438bd2">dealingWithData</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a00eb42e7e8c38331ef4ff6f16b3c9faa">AllocateBuffer</a> (size_t bufferLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#afe1d9f526b5ec117cec258fccd3dc50b">BaseInit</a> (size_t bufferLength)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_status.html">clStatus</a>&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#ae17183becacd182ade36644e561c1aca">completionPortCloseNotification</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_status.html">clStatus</a>&lt; vector&lt; <a class="el" href="classcl_shared_send.html">clSharedSend</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_socket.html#a9e241858d57abe94c6e600040882091e">sendCleanup</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Socket class providing more advanced functionality common to all protocols. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Michael Pryor, 6/28/2010.</dd></dl>
<p>This class provides functionality for interacting with the completion port and for sending data.<br/>
<br/>
</p>
<p>This class is not inherently thread safe. Send is thread safe. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aea097250d267f081b56c0bcda48e210f"></a><!-- doxytag: member="clSocket::clSocket" ref="aea097250d267f081b56c0bcda48e210f" args="(size_t bufferLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSocket::clSocket </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a331fae974dc5e685d4814e2f2254208d"></a><!-- doxytag: member="clSocket::clSocket" ref="a331fae974dc5e685d4814e2f2254208d" args="(size_t bufferLength, clInstanceContainer *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSocket::clSocket </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_container.html">clInstanceContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance</em>&nbsp;</td><td>pointer to instance that owns this object, use other constructor if no instance does </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9872767d3f8a21f6568b4a79c3bddee4"></a><!-- doxytag: member="clSocket::~clSocket" ref="a9872767d3f8a21f6568b4a79c3bddee4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSocket::~clSocket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor <br/>
 Closes socket and cleans up object </p>

</div>
</div>
<a class="anchor" id="ad5702fb888ecb38b07eb536273aa5414"></a><!-- doxytag: member="clSocket::clSocket" ref="ad5702fb888ecb38b07eb536273aa5414" args="(const clSocket &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clSocket::clSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_socket.html">clSocket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor (deep) </p>
<dl class="note"><dt><b>Note:</b></dt><dd>only copies recvBuffer (but not its contents, just its size), all other variables are newly initialized</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a63910e1657650a9ff3e8c8cb6045e689"></a><!-- doxytag: member="clSocket::_DefaultVars" ref="a63910e1657650a9ff3e8c8cb6045e689" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::_DefaultVars </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets variables to default </p>

<p>Reimplemented from <a class="el" href="classcl_simple_socket.html#ad535ecb38b4ceb63a98d2ed3106ac792">clSimpleSocket</a>.</p>

</div>
</div>
<a class="anchor" id="aacb725d66067230ade23633e34a0d02d"></a><!-- doxytag: member="clSocket::AddSend" ref="aacb725d66067230ade23633e34a0d02d" args="(clSharedSend *send)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::AddSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_shared_send.html">clSharedSend</a> *&nbsp;</td>
          <td class="paramname"> <em>send</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a send operation to the cleanup vector </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>send</em>&nbsp;</td><td>send operation to add to cleanup vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00eb42e7e8c38331ef4ff6f16b3c9faa"></a><!-- doxytag: member="clSocket::AllocateBuffer" ref="a00eb42e7e8c38331ef4ff6f16b3c9faa" args="(size_t bufferLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::AllocateBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets up WSABUF, allocating memory to it</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68a48be55c5638db5fbf61d652318de4"></a><!-- doxytag: member="clSocket::AssociateSocketCompletionPort" ref="a68a48be55c5638db5fbf61d652318de4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::AssociateSocketCompletionPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associates <code>winsockSocket</code> with completion port, the completion port takes over the following jobs:</p>
<ul>
<li>Cleaning up send operations</li>
<li>Receiving data and dealing with it </li>
</ul>

</div>
</div>
<a class="anchor" id="afe1d9f526b5ec117cec258fccd3dc50b"></a><!-- doxytag: member="clSocket::BaseInit" ref="afe1d9f526b5ec117cec258fccd3dc50b" args="(size_t bufferLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::BaseInit </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize objects <br/>
 Does initialization shared between objects</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>length of receive buffer in bytes; this is the maximum amount of data that can be received in one receive operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45284c4d4679469dd9cf11cf08faa86c"></a><!-- doxytag: member="clSocket::ClearRecv" ref="a45284c4d4679469dd9cf11cf08faa86c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::ClearRecv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears receive overlapped object ready for next receive <br/>
 Must be done before every receive operation <br/>
 </p>

<p>Reimplemented in <a class="el" href="classcl_socket_u_d_p.html#a6c7f4b4f575e0c466f6b59d18717bd2a">clSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a2398b25d1c446b27f55f2e12632a0f17"></a><!-- doxytag: member="clSocket::ClearSend" ref="a2398b25d1c446b27f55f2e12632a0f17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::ClearSend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empties send cleanup vector, cleaning up all send operations </p>

</div>
</div>
<a class="anchor" id="a5ff0b79fb0cb1c43019e726ea085ec36"></a><!-- doxytag: member="clSocket::Close" ref="a5ff0b79fb0cb1c43019e726ea085ec36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes <code>winsockSocket</code> <br/>
 Process is multithread safe where method is used outside of completion port! <br/>
 -winsockSocket is closed so all pending operations fail -this method waits for all send operations to be cleaned up, once <a class="el" href="classcl_socket.html#abdf3ff3b62ae2401576e5ae294ef53e3">SendEmpty()</a> returns true the entire cleanup process is finished so any send cleanup objects can safely be cleaned up -this method waits for all winsock receive operations to finish -this method waits for finished receive operations to be dealt with -at this point the completion port is no longer using the socket </p>

<p>Reimplemented from <a class="el" href="classcl_simple_socket.html#a755206da4d4b36d15353949c9a248398">clSimpleSocket</a>.</p>

<p>Reimplemented in <a class="el" href="classcl_socket_t_c_p.html#a8f1031669c4093bf2aacb788f97c1adf">clSocketTCP</a>, and <a class="el" href="classcl_socket_u_d_p.html#aa4f23e02e1c4803535e94fcfa97698ea">clSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab21e84af02b22496fcc2e60549e9ce"></a><!-- doxytag: member="clSocket::CompletionPortRequestClose" ref="a2ab21e84af02b22496fcc2e60549e9ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::CompletionPortRequestClose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that socket should be closed </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>should only be used by completion port </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>only used on stand alone sockets (sockets not associated with an instance) </dd></dl>

</div>
</div>
<a class="anchor" id="a4ddfb1b3168816c667e1193d1df42535"></a><!-- doxytag: member="clSocket::DealWithData" ref="a4ddfb1b3168816c667e1193d1df42535" args="(size_t threadID, size_t completionBytes, const WSABUF &amp;buffer, size_t clientID, size_t instanceID, clInstanceCore::RecvFunc recvFunc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clSocket::DealWithData </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>threadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>completionBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WSABUF &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_instance_core.html#afa96c2a2c0b26b6a9256b87798bf9587">clInstanceCore::RecvFunc</a>&nbsp;</td>
          <td class="paramname"> <em>recvFunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deals with newly received data </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadID</em>&nbsp;</td><td>ID of thread that packet was received on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completionBytes</em>&nbsp;</td><td>size of packet stored in <em>buffer</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>where newly received packet is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client that packet was received from, 0 in client state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>instance that packet was received on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvFunc</em>&nbsp;</td><td>method will be executed and data not added to the queue if this is non NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcl_socket_t_c_p.html#a1b168f8a28b7100d6b837201b766e05a">clSocketTCP</a>, and <a class="el" href="classcl_socket_u_d_p.html#a5dbfc8b8689613b2def26ed5a322ba5f">clSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="adfe8b1383f71d3569be05859ba1d55bd"></a><!-- doxytag: member="clSocket::FindSend" ref="adfe8b1383f71d3569be05859ba1d55bd" args="(const OVERLAPPED *operation) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSocket::FindSend </td>
          <td>(</td>
          <td class="paramtype">const OVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>operation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches for the send operation that is using the specified overlapped object in the send cleanup list</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>pointer to overlapped object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the send operation that is using the specified overlapped object was found in the send cleanup list </dd></dl>

</div>
</div>
<a class="anchor" id="ab024e22508a2490cc4e41ca285adc55f"></a><!-- doxytag: member="clSocket::GetCompletionPortCloseRequest" ref="ab024e22508a2490cc4e41ca285adc55f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSocket::GetCompletionPortCloseRequest </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if completion port wants this socket to be closed </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>only used on stand alone sockets (sockets not associated with an instance) </dd></dl>

</div>
</div>
<a class="anchor" id="a8ce9d2d6fa68c1d70fa757122093f7ca"></a><!-- doxytag: member="clSocket::GetProtocol" ref="a8ce9d2d6fa68c1d70fa757122093f7ca" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcl_simple_socket.html#affcd3d22c1abba5d20a0ae93472c576d">Protocol</a> clSocket::GetProtocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Protocol type that socket represents </dd></dl>

<p>Implemented in <a class="el" href="classcl_socket_t_c_p.html#ad465fce0e99ce328cafe5c77cbc8cef9">clSocketTCP</a>, and <a class="el" href="classcl_socket_u_d_p.html#a4016f07d693331c87be1649aa69df9f6">clSocketUDP</a>.</p>

</div>
</div>
<a class="anchor" id="a1652cf24e9f2a5d83a463da184903f4f"></a><!-- doxytag: member="clSocket::GetRecvBufferLength" ref="a1652cf24e9f2a5d83a463da184903f4f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t clSocket::GetRecvBufferLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the buffer size of the WSABUF. <br/>
 This is the maximum amount of data that can be received with one WSARecv operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a46bfeb517dceec7b2dfb72f77e1a6c99"></a><!-- doxytag: member="clSocket::IsOurOverlapped" ref="a46bfeb517dceec7b2dfb72f77e1a6c99" args="(const WSAOVERLAPPED *overlapped) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSocket::IsOurOverlapped </td>
          <td>(</td>
          <td class="paramtype">const WSAOVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>overlapped</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>overlapped</em> pointer points to the overlapped object stored by this object </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlapped</em>&nbsp;</td><td>overlapped pointer to compare </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04028c4342b924ffc1a6749c35d57c32"></a><!-- doxytag: member="clSocket::operator=" ref="a04028c4342b924ffc1a6749c35d57c32" args="(const clSocket &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_socket.html">clSocket</a> &amp; clSocket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_socket.html">clSocket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyMe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment operator (deep) </p>
<dl class="note"><dt><b>Note:</b></dt><dd>only copies recvBuffer (but not its contents, just its size), all other variables are ignored</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>copyMe</em>&nbsp;</td><td>Object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a87f0f9dfc4b26d21efc45a3551ab988b"></a><!-- doxytag: member="clSocket::RemoveSend" ref="a87f0f9dfc4b26d21efc45a3551ab988b" args="(const OVERLAPPED *operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSocket::RemoveSend </td>
          <td>(</td>
          <td class="paramtype">const OVERLAPPED *&nbsp;</td>
          <td class="paramname"> <em>operation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the send operation that is using the specified overlapped object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>pointer to overlapped operation of send operation we wish to cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an operation was cleaned up, false if not </dd></dl>

<p><p>Check that object is not in use The object will only be in use at this point if it is still executing the internal function it was doing when it added itself to the cleanup queue. It may still need to use some internal variables e.g. if it is blocking for completion and so we must wait before we clean it up. We must release the critical section BEFORE cleaning it up.</p>
</p>

</div>
</div>
<a class="anchor" id="ae28db191f5750e83f187e37939b596ad"></a><!-- doxytag: member="clSocket::RemoveSend" ref="ae28db191f5750e83f187e37939b596ad" args="(size_t element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::RemoveSend </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the send operation at the specified element </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>element to cleanup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6645de6f69b91fdf30b0195c221e4e7c"></a><!-- doxytag: member="clSocket::Send" ref="a6645de6f69b91fdf30b0195c221e4e7c" args="(clSharedSend &amp;sendObject, const clSingleAddr *sendToAddr, unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803">clNetworkingUtility::SendStatus</a> clSocket::Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_shared_send.html">clSharedSend</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sendObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_single_addr.html">clSingleAddr</a> *&nbsp;</td>
          <td class="paramname"> <em>sendToAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a send object</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendObject</em>&nbsp;</td><td>object to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendToAddr</em>&nbsp;</td><td>address to send to, if NULL then object is sent to address that socket is connected to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>length of time in milliseconds to wait before canceling send operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803abaa42412f2920363cef741fd5b2e202a">clNetworkingUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a807b2f9dcc901c6012549316bccfe407">clNetworkingUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803a583b1181229130ff739548c8f8de363c">clNetworkingUtility::SEND_FAILED</a> if the send operation failed </dd>
<dd>
<a class="el" href="classcl_networking_utility.html#a19389cda12603396e03caa9d82073803ab06ce588df19988e79b503398b720c79">clNetworkingUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. client disconnected) </dd></dl>

</div>
</div>
<a class="anchor" id="abdf3ff3b62ae2401576e5ae294ef53e3"></a><!-- doxytag: member="clSocket::SendEmpty" ref="abdf3ff3b62ae2401576e5ae294ef53e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clSocket::SendEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the send cleanup vector is empty </dd></dl>

</div>
</div>
<a class="anchor" id="aadcd5e50e5dd9495e433a3be3ff69c31"></a><!-- doxytag: member="clSocket::SetCompletionPortFinishRecvNotification" ref="aadcd5e50e5dd9495e433a3be3ff69c31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::SetCompletionPortFinishRecvNotification </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that the entire receiving process has finished </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>should only be used by completion port </dd></dl>

</div>
</div>
<a class="anchor" id="a8088a2405e76acca3b41175552bc0f6c"></a><!-- doxytag: member="clSocket::SetOverlappedEvent" ref="a8088a2405e76acca3b41175552bc0f6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clSocket::SetOverlappedEvent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manually set overlapped event <br/>
 This is necassary when an overlapped recv operation fails before pending as in this case the overlapped event object is not automatically signalled </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a13f7fb8c9c146df5b8b63a861b1d9b05"></a><!-- doxytag: member="clSocket::completionKey" ref="a13f7fb8c9c146df5b8b63a861b1d9b05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_completion_key.html">clCompletionKey</a> <a class="el" href="classcl_socket.html#a13f7fb8c9c146df5b8b63a861b1d9b05">clSocket::completionKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unique completion key used by completion port to identify this object </p>

</div>
</div>
<a class="anchor" id="ae17183becacd182ade36644e561c1aca"></a><!-- doxytag: member="clSocket::completionPortCloseNotification" ref="ae17183becacd182ade36644e561c1aca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_status.html">clStatus</a>&lt;bool&gt; <a class="el" href="classcl_socket.html#ae17183becacd182ade36644e561c1aca">clSocket::completionPortCloseNotification</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if completion port wants this socket to be closed </p>
<dl class="note"><dt><b>Note:</b></dt><dd>must take control of object's critical section when using this object </dd>
<dd>
completion port does not close socket directly in order to simplify multithreaded architecture </dd></dl>

</div>
</div>
<a class="anchor" id="a119bea012ab04183f3a796a295438bd2"></a><!-- doxytag: member="clSocket::dealingWithData" ref="a119bea012ab04183f3a796a295438bd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_status.html">clStatus</a>&lt;bool&gt; <a class="el" href="classcl_socket.html#a119bea012ab04183f3a796a295438bd2">clSocket::dealingWithData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true after a receive operation has been initiated, only false when the operation has finished AND all data has been dealt with. This is important during the socket closure process so that resources being used are not cleaned up </p>

</div>
</div>
<a class="anchor" id="a3d6b17db1b4743a14efcf02205113ae8"></a><!-- doxytag: member="clSocket::flags" ref="a3d6b17db1b4743a14efcf02205113ae8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD <a class="el" href="classcl_socket.html#a3d6b17db1b4743a14efcf02205113ae8">clSocket::flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Filled when TCP receive operation completes, is ignored by me but required by winsock </p>

</div>
</div>
<a class="anchor" id="aa33f69522e06a1ddaaf589cb21f0f60d"></a><!-- doxytag: member="clSocket::recvBuffer" ref="aa33f69522e06a1ddaaf589cb21f0f60d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSABUF <a class="el" href="classcl_socket.html#aa33f69522e06a1ddaaf589cb21f0f60d">clSocket::recvBuffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Winsock buffer that is filled with newly received data </p>

</div>
</div>
<a class="anchor" id="aec458d824ec2454b0db2869fc8f87623"></a><!-- doxytag: member="clSocket::recvOverlapped" ref="aec458d824ec2454b0db2869fc8f87623" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSAOVERLAPPED <a class="el" href="classcl_socket.html#aec458d824ec2454b0db2869fc8f87623">clSocket::recvOverlapped</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Winsock overlapped operation used to identify when a receive operation has completed <br/>
 The overlapped event object goes through the following stages: <br/>
 1. Starts signaled <br/>
 2. Begins operation, becomes unsignaled <br/>
 3. Finishes operation successfully and becomes signaled <br/>
 4. OR fails to complete operation and is manually signaled (to prevent deadlock) </p>

</div>
</div>
<a class="anchor" id="a9e241858d57abe94c6e600040882091e"></a><!-- doxytag: member="clSocket::sendCleanup" ref="a9e241858d57abe94c6e600040882091e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_status.html">clStatus</a>&lt;vector&lt;<a class="el" href="classcl_shared_send.html">clSharedSend</a>*&gt; &gt; <a class="el" href="classcl_socket.html#a9e241858d57abe94c6e600040882091e">clSocket::sendCleanup</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This vector is filled with send operations that are in progress <br/>
 Upon completion, a completion thread compares the overlapped pointer to determine which send operation should be cleaned up. <br/>
 When cleaned up the send operation is removed from this vector. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>vector should not be used if socket is not associated with completion port </dd>
<dd>
made mutable because vector CPP class is not const correct </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/<a class="el" href="cl_socket_8h_source.html">clSocket.h</a></li>
<li>C:/Users/Michael Pryor/Desktop/Deoxygen Files/Source Files/clSocket.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 2 2010 10:34:08 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
