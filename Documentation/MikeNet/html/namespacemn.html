<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DarkNet: mn Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>mn Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Commands for procedural programming, that wrap around internal classes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a33f31fabf86b8a77c70215819b77f7fc">GetVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a string containing version information for this API.  <a href="#a33f31fabf86b8a77c70215819b77f7fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4452d09215e972009fc5985a61ae7d04">Start</a> (size_t numInstances, size_t numThreads)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts up the networking module.  <a href="#a4452d09215e972009fc5985a61ae7d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a99612581b485e5059ba0c1c6e6d4d548">Finish</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleans up an instance, or the entire networking module.  <a href="#a99612581b485e5059ba0c1c6e6d4d548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a99d80371f7aecc638eb1ef1f74534794">DNS_B</a> (const char *hostName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the IP address of the specified host name.  <a href="#a99d80371f7aecc638eb1ef1f74534794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a06a84484274b0f3184c226b5e70496ef">GetLocalInterfaceAmount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of local interfaces available.  <a href="#a06a84484274b0f3184c226b5e70496ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6344a20d5c370b8956113db7e1b2e6d4">GetLocalInterfaceStr</a> (size_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a local interface.  <a href="#a6344a20d5c370b8956113db7e1b2e6d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a50d1939a356ab07a100762ef29ab6748">GetHostName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the name of the computer.  <a href="#a50d1939a356ab07a100762ef29ab6748"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <br class="typebreak"/>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab9399b132dc43e4b46d578a25f422bc0">Connect</a> (size_t instanceID, const char *connectIP_TCP, unsigned short connectPort_TCP, const char *connectIP_UDP, unsigned short connectPort_UDP, size_t timeoutMilliseconds, bool block, __int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a client instance into the specified instance ID.  <a href="#ab9399b132dc43e4b46d578a25f422bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac35052139b0152c092a1097d065e0c2f">StartServer</a> (size_t instanceID, size_t maxClients, __int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a server instance into the specified instance ID.  <a href="#ac35052139b0152c092a1097d065e0c2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2b85e7da0cf4c6a1cf5ff67f580b29b5">StartBroadcast</a> (size_t instanceID, const char *connectAddressIP, unsigned short connectAddressPort, bool sendEnabled, bool recvEnabled, __int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a broadcasting instance into the specified instance ID.  <a href="#a2b85e7da0cf4c6a1cf5ff67f580b29b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae2c290babcdf8190d0502331f2799c93">DisconnectClient</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnects the specified client.  <a href="#ae2c290babcdf8190d0502331f2799c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a214c9fac7be21f994a50f11f6dbd1fd5">SetServerTimeout</a> (size_t instanceID, size_t timeoutMilliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a214c9fac7be21f994a50f11f6dbd1fd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a90e71b91823a065bb587a82939edf97d">GetServerTimeout</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a90e71b91823a065bb587a82939edf97d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133">ClientJoined</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manages incoming connections from clients.  <a href="#aa88fef80cdb3574c2b6ba46931f8a133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a">ClientLeft</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps track of who has disconnected recently.  <a href="#a24fc1fbd520a0e0095810ad6fec20c5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a796619854a3fa47f837e1a07dfea315f">GetClientIPTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote TCP IP of a currently connected client.  <a href="#a796619854a3fa47f837e1a07dfea315f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a793ffb4d1c671e27ff1e1a2c72642c42">GetClientPortTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote TCP port of a currently connected client.  <a href="#a793ffb4d1c671e27ff1e1a2c72642c42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a43a0cdd23d509a9c04dc266d381bb690">GetClientIPUDP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote UDP IP of a currently connected client.  <a href="#a43a0cdd23d509a9c04dc266d381bb690"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3a7965d08132aef367e2c767c845c781">GetClientPortUDP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote UDP port of a currently connected client.  <a href="#a3a7965d08132aef367e2c767c845c781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6bb3498a01e2cccb3b0b29a30cb87eb1">GetClientFrom</a> (__int64 <a class="el" href="class_packet.html">Packet</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the client ID of the client that received the specified packet.  <a href="#a6bb3498a01e2cccb3b0b29a30cb87eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aabf2e7fc125113e54f60f4b018faa8a5">ShutdownClient</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins the graceful disconnection process.  <a href="#aabf2e7fc125113e54f60f4b018faa8a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <br class="typebreak"/>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a182830933908a7e2338d710565c2bbb4">ClientConnected</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the specified client is connected, and what stage of the graceful disconnection process it is at.  <a href="#a182830933908a7e2338d710565c2bbb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4dc2d3891cf1703bf452b5e2aa478f2e">FlushRecvTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the TCP received packet queue.  <a href="#a4dc2d3891cf1703bf452b5e2aa478f2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9e9638697d08de4e65a85864cc4524aa">FlushRecvUDP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the UDP received packet queue.  <a href="#a9e9638697d08de4e65a85864cc4524aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab9b1a02847005a257c1c08e96558c162">ChangeBufferSizeTCP</a> (size_t instanceID, size_t clientID, size_t newSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the size of the largest TCP packet that can be received; packets larger than this will require an increase in memory size or an error will be thrown.  <a href="#ab9b1a02847005a257c1c08e96558c162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aaba22ec864ee20e4c2811bb2ad2ec3bf">SetAutoResizeTCP</a> (size_t instanceID, size_t clientID, bool autoResize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the auto resize TCP option.  <a href="#aaba22ec864ee20e4c2811bb2ad2ec3bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4cbae8de856869fefcf8c36ade5fca5a">GetConnectIPTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the IP address that the client is connected to via TCP.  <a href="#a4cbae8de856869fefcf8c36ade5fca5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a54dcaef89c8ec481ba82d1712d2c49f3">GetConnectPortTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the port that the client is connected to via TCP.  <a href="#a54dcaef89c8ec481ba82d1712d2c49f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a27b42cb739a01d6c4ec8f368a9f1536e">GetConnectIPUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the IP address that the client is connected to via UDP.  <a href="#a27b42cb739a01d6c4ec8f368a9f1536e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a34127d93b6b2ee3724a048a4c4a2d3fe">GetConnectPortUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the port that the client is connected to via UDP.  <a href="#a34127d93b6b2ee3724a048a4c4a2d3fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <br class="typebreak"/>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3f6e329576ac7a8c036f2040bd6314a3">PollConnect</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the status of the <a class="el" href="handshake_page.html">handshaking process</a>.  <a href="#a3f6e329576ac7a8c036f2040bd6314a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a384075204fa1db1a7fdd21a0219662ba">StopConnect</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels the <a class="el" href="handshake_page.html">handshaking process</a>.  <a href="#a384075204fa1db1a7fdd21a0219662ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0b816e5fdb5c2dad588d1ab66251cce2">GetConnecting</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the client is in the process of connecting to a server.  <a href="#a0b816e5fdb5c2dad588d1ab66251cce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a110e66fb2f7eb5b19466874b11cca947">GetClientID</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the client ID that the server has assigned the client.  <a href="#a110e66fb2f7eb5b19466874b11cca947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a74def948c7f024a65f2d645450378ab3">GetMaxClients</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the maximum number of clients that can be connected to the server at any one time.  <a href="#a74def948c7f024a65f2d645450378ab3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa67e3ecf996a52772f41a221cec84579">GetMaxOperations</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of UDP operation IDs available.  <a href="#aa67e3ecf996a52772f41a221cec84579"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa2ad2574ea8e6b8d63111443be1b1bd1">GetRecvSizeUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the size of the UDP receive buffer.  <a href="#aa2ad2574ea8e6b8d63111443be1b1bd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a05bbe5425db98835e70e03845d3ae3f2">GetThreads</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of completion port threads in operation.  <a href="#a05bbe5425db98835e70e03845d3ae3f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3132d0d328f9bbdd4fccbd36fc6dff3d">GetNumInstances</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of instances available (including inactive ones).  <a href="#a3132d0d328f9bbdd4fccbd36fc6dff3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdc">NetInstance::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8925f1bd923a24ad5f9576f02305c61e">GetState</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the state that the instance is in.  <a href="#a8925f1bd923a24ad5f9576f02305c61e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2d1f3ad5255ffc87da23a5fdbe965736">GetModeUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP mode in use.  <a href="#a2d1f3ad5255ffc87da23a5fdbe965736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac7a3b25259daf42c56da1e677a551e77">GetEnabledUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP is enabled.  <a href="#ac7a3b25259daf42c56da1e677a551e77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7413d0cbb69dc342c868d68395143dd8">GetPercentTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines how much of the packet currently being receives has been received as a percentage.  <a href="#a7413d0cbb69dc342c868d68395143dd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a5065424be63fbe66753762e67f4c35e0">GetRecvSizeTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP buffer size.  <a href="#a5065424be63fbe66753762e67f4c35e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aae8cbaca06592adf7e07e7e8dbb58ff1">GetBytesTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines how much of the packet currently being receives has been received in bytes.  <a href="#aae8cbaca06592adf7e07e7e8dbb58ff1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a42c695fef33766c040ec92ee2101c4d2">GetHandshakeEnabledTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the handshaking process is enabled.  <a href="#a42c695fef33766c040ec92ee2101c4d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7f8b463f4a6a05a984fde1e5aea119e7">GetModeTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP mode in use.  <a href="#a7f8b463f4a6a05a984fde1e5aea119e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9d06820302a364d7a75c5442268de3b8">GetGracefulDisconnectEnabledTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the graceful disconnect process is enabled.  <a href="#a9d06820302a364d7a75c5442268de3b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a17dff75b4f61b5e954752b6f64b0cd64">GetSendTimeout</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the length of time that send operations are allowed to take before the entity that initiated them is disconnected forcefully.  <a href="#a17dff75b4f61b5e954752b6f64b0cd64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae2db35a7c9ec4e2e1fc7abe98749c130">GetStoreAmountTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of packets stored in the TCP received packet queue.  <a href="#ae2db35a7c9ec4e2e1fc7abe98749c130"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8d54cf87355792acd2b5b9d2ffb4120b">GetStoreAmountUDP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of packets stored in the UDP received packet queue.  <a href="#a8d54cf87355792acd2b5b9d2ffb4120b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a045102b8bf3bad5643f32b747f63b3ca">GetPostfixTCP</a> (size_t instanceID, __int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP postfix in use.  <a href="#a045102b8bf3bad5643f32b747f63b3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aedb6bc9412d06ec6d088175141793497">GetNagleEnabledTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the nagle algorithm is enabled.  <a href="#aedb6bc9412d06ec6d088175141793497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af599d054cbe64887252f1c6ef73b2bb2">GetAutoResizeTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the TCP buffer size will automatically increase if necessary.  <a href="#af599d054cbe64887252f1c6ef73b2bb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a77eed9348dab0a1ee0f9d882687ac6bc">GetLocalIPTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP IP of the specified instance.  <a href="#a77eed9348dab0a1ee0f9d882687ac6bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a44e66800abe59f00297e397ea4cf7bb0">GetLocalPortTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP port of the specified instance.  <a href="#a44e66800abe59f00297e397ea4cf7bb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a561d26c7aad0f25d9a627eea6c62e714">GetLocalIPUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP IP of the specified instance.  <a href="#a561d26c7aad0f25d9a627eea6c62e714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8172bc9d62d2d54dae57340a052c1575">GetLocalPortUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP port of the specified instance.  <a href="#a8172bc9d62d2d54dae57340a052c1575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#adfe8471ae07cd596fe9215a890faac69">RecvTCP</a> (size_t instanceID, __int64 destinationPacket, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a TCP packet from the TCP received packet queue.  <a href="#adfe8471ae07cd596fe9215a890faac69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a62627020941d9c6cdd1e3e3d1919c28b">RecvUDP</a> (size_t instanceID, __int64 destinationPacket, size_t clientID, size_t operationID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a UDP packet from the UDP received packet queue.  <a href="#a62627020941d9c6cdd1e3e3d1919c28b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af9ce5db9b08f558c31f581c791ae422c">SendUDP</a> (size_t instanceID, __int64 packet, size_t clientID, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends UDP data to a client on the specified instance.  <a href="#af9ce5db9b08f558c31f581c791ae422c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4576cc65008a1552f1185340b7c3e581">SendToUDP</a> (size_t instanceID, __int64 packet, const char *addrIP, unsigned short addrPort, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends UDP data to an unconnected entity, identified only by its remote address.  <a href="#a4576cc65008a1552f1185340b7c3e581"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6f052556b3373d7c8b39f8c93514850d">SendTCP</a> (size_t instanceID, __int64 packet, size_t clientID, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends TCP data to a client on the specified instance.  <a href="#a6f052556b3373d7c8b39f8c93514850d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a908c1d799a28850891e7432d7ad08d54">SendAllTCP</a> (size_t instanceID, __int64 packet, bool keep, bool block, size_t clientExcludeID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a TCP packet to all clients on the specified instance.  <a href="#a908c1d799a28850891e7432d7ad08d54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#adbcf7335bfdbdcc3a2fbb7e9de792256">SendAllUDP</a> (size_t instanceID, __int64 packet, bool keep, bool block, size_t clientExcludeID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a UDP packet to all clients on the specified instance.  <a href="#adbcf7335bfdbdcc3a2fbb7e9de792256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a014728aa15cb725505b6062e8abf9142">AddUnsignedInt</a> (__int64 packet, unsigned int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned integer to the specified packet.  <a href="#a014728aa15cb725505b6062e8abf9142"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a55b7a2af579d2a8a49a96dd23ab8b3a3">AddInt</a> (__int64 packet, int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an integer to the specified packet.  <a href="#a55b7a2af579d2a8a49a96dd23ab8b3a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a627c50f822de74e537d995c97d7e7157">AddLongInt</a> (__int64 packet, long int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a long integer to the specified packet.  <a href="#a627c50f822de74e537d995c97d7e7157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a13d6eed8b77ec2dda29e05439e74a362">AddLongLongInt</a> (__int64 packet, long long int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an long long integer to the specified packet.  <a href="#a13d6eed8b77ec2dda29e05439e74a362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a5a2b8af8c6c80b9426179184af910cc5">AddFloat</a> (__int64 packet, float Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a float to the specified packet.  <a href="#a5a2b8af8c6c80b9426179184af910cc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a567b66268ff1f61419d14a0bccb00ccc">AddUnsignedByte</a> (__int64 packet, unsigned char Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned byte to the specified packet.  <a href="#a567b66268ff1f61419d14a0bccb00ccc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a05539f2bdb0fb27245b5ab8b997391e7">AddByte</a> (__int64 packet, char Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a byte to the specified packet.  <a href="#a05539f2bdb0fb27245b5ab8b997391e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aadfe7586ddbb5a7db38a1039305bbfdd">AddSignedByte</a> (__int64 packet, signed char Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a signed byte to the specified packet.  <a href="#aadfe7586ddbb5a7db38a1039305bbfdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad372ea8cead9fcb5a917c5ec2b71d0f3">AddDouble</a> (__int64 packet, double Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a double to the specified packet.  <a href="#ad372ea8cead9fcb5a917c5ec2b71d0f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa84c596e872485bd5f6cc2d3942f7b04">AddLongDouble</a> (__int64 packet, long double Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a long double to the specified packet.  <a href="#aa84c596e872485bd5f6cc2d3942f7b04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a964d359bc5323cce38f4e74445394f0e">AddShortInt</a> (__int64 packet, short int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a short integer to the specified packet.  <a href="#a964d359bc5323cce38f4e74445394f0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a590134153518dcccb80a21eed60d194d">AddUnsignedShortInt</a> (__int64 packet, unsigned short int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned short integer to the specified packet.  <a href="#a590134153518dcccb80a21eed60d194d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a59131fe114eb83ccc8816dfb015956d9">AddUnsignedLongInt</a> (__int64 packet, unsigned long int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned long int to the specified packet.  <a href="#a59131fe114eb83ccc8816dfb015956d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a032a2dc3f99830a39d36db8036969a35">AddUnsignedLongLongInt</a> (__int64 packet, unsigned long long int Add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned long long integer to the specified packet.  <a href="#a032a2dc3f99830a39d36db8036969a35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab28c93686b6e27a980d244971a83bc43">AddSizeT</a> (__int64 packet, size_t add)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an unsigned short integer to the specified packet.  <a href="#ab28c93686b6e27a980d244971a83bc43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af0362f4b04ef52ae68a71e64a102e898">AddStringC</a> (__int64 packet, const char *source, size_t length, bool prefix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a C string to the specified packet.  <a href="#af0362f4b04ef52ae68a71e64a102e898"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0ef3d1df4730cc5bf008979274154b99">GetPacketRemainder</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the number of unread bytes in the specified packet.  <a href="#a0ef3d1df4730cc5bf008979274154b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6431cbaca9a7e390377b112050ccd688">GetUnsignedInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned integer from the specified packet.  <a href="#a6431cbaca9a7e390377b112050ccd688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af529e8b437a2d3c8d782da1ab47dbe77">GetInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an integer from the specified packet.  <a href="#af529e8b437a2d3c8d782da1ab47dbe77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab9270e6721c7a7f3753d069e9c99f679">GetLongInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a long integer from the specified packet.  <a href="#ab9270e6721c7a7f3753d069e9c99f679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL long long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a88b9312e83b83b46465a7b1f69e6451d">GetLongLongInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a long long integer from the specified packet.  <a href="#a88b9312e83b83b46465a7b1f69e6451d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9e7ab9d44114450fd851d6ce89f174d0">GetFloat</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a float from the specified packet.  <a href="#a9e7ab9d44114450fd851d6ce89f174d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#acf8fbb993d19953809ddea61666e9798">GetUnsignedByte</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned byte from the specified packet.  <a href="#acf8fbb993d19953809ddea61666e9798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a82b01bd653c6ea90546ebb31f0130fdd">GetByte</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a byte from the specified packet.  <a href="#a82b01bd653c6ea90546ebb31f0130fdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL signed char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aff4353e5aa9c8fce36fe9a88e6f9b82b">GetSignedByte</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a signed byte from the specified packet.  <a href="#aff4353e5aa9c8fce36fe9a88e6f9b82b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a46a7e0633c22ff33afa589606673e20d">GetDouble</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a double from the specified packet.  <a href="#a46a7e0633c22ff33afa589606673e20d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2a1faf5fdf08a9c5fee7e3507d1ec6df">GetLongDouble</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a long double from the specified packet.  <a href="#a2a1faf5fdf08a9c5fee7e3507d1ec6df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a39671a53d16a304d993465efd819a57d">GetShortInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a short integer from the specified packet.  <a href="#a39671a53d16a304d993465efd819a57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3d09a445de8ecd6241d758b218426cd5">GetUnsignedShortInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned short integer from the specified packet.  <a href="#a3d09a445de8ecd6241d758b218426cd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a68b28730fe0c294b9c9e7594617b5c7b">GetStringC</a> (__int64 packet, size_t length, bool nullTerminated)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a C string from the specified packet, allocating new memory to that string.  <a href="#a68b28730fe0c294b9c9e7594617b5c7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a49b801f3e32ae023a557d277e76812d2">GetStringC_B</a> (__int64 packet, char *dest, size_t length, bool nullTerminated)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a C string from the specified packet, copying into previously allocated memory.  <a href="#a49b801f3e32ae023a557d277e76812d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL unsigned long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a46d1c79f605b4dcb321d1618415b065a">GetUnsignedLongInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned long integer from the specified packet.  <a href="#a46d1c79f605b4dcb321d1618415b065a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL unsigned long long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa24b3cfab35ce088892686c676fd4463">GetUnsignedLongLongInt</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned long long integer from the specified packet.  <a href="#aa24b3cfab35ce088892686c676fd4463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aca38e8b5229e1e4d13a0d904685c5af8">GetSizeT</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an unsigned long long integer from the specified packet.  <a href="#aca38e8b5229e1e4d13a0d904685c5af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6155af5ab3e18ae4746b1b9c06ee6509">GetAge</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the clock value of the specified packet, indicating the packet's age.  <a href="#a6155af5ab3e18ae4746b1b9c06ee6509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac9394252d9c10089e465248ff97a0b17">GetOperation</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the operation ID of the specified packet, indicating what operation the packet was received on.  <a href="#ac9394252d9c10089e465248ff97a0b17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0a6d7eb9d9bf8b6013de4497c410c824">GetErrorOperation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the operation that was being performed when the error that is saved globally occurred.  <a href="#a0a6d7eb9d9bf8b6013de4497c410c824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae9a66f2cfec02b7b48d162c614fc1c75">GetInstance</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the instance ID of the specified packet, indicating the ID of the instance that the packet was received on.  <a href="#ae9a66f2cfec02b7b48d162c614fc1c75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2d701ece0f90e9234eb8bd9cf67691b3">ClearPacket</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the specified packet, erasing all data stored.  <a href="#a2d701ece0f90e9234eb8bd9cf67691b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#adcd416fad1bd4e97075d610dd89c5501">AddPacket</a> (__int64 dest, __int64 source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines two packets together.  <a href="#adcd416fad1bd4e97075d610dd89c5501"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a11a1517b94d11908e08bd1a5edfecbce">AssignPacket</a> (__int64 dest, __int64 source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns a source packet to another destination packet, overwriting anything in the destination packet.  <a href="#a11a1517b94d11908e08bd1a5edfecbce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a67b272ded28669e8c163b425f8893351">ComparePacket</a> (__int64 packet1, __int64 packet2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two packets.  <a href="#a67b272ded28669e8c163b425f8893351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3bd0a3da67665406c73878e2f4ae92b0">CreatePacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new empty packet.  <a href="#a3bd0a3da67665406c73878e2f4ae92b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad2934b8fb371f044330f7ddb4e7f5c01">DeletePacket</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified packet.  <a href="#ad2934b8fb371f044330f7ddb4e7f5c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7c01a84cc17bd2b5e7b78a471c1d7b18">SetMemorySize</a> (__int64 packet, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the memory size of the packet, overwriting any packet data in the process.  <a href="#a7c01a84cc17bd2b5e7b78a471c1d7b18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad3e77a7a0d7ce4a2f1b33ab61ac268e5">GetMemorySize</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the memory size of the packet.  <a href="#ad3e77a7a0d7ce4a2f1b33ab61ac268e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad552a2a89165470686778f966d65bdc9">SetUsedSize</a> (__int64 packet, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the used size of the packet.  <a href="#ad552a2a89165470686778f966d65bdc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aea5a6460be64a0d83240fd2c234cd4ed">GetUsedSize</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the used size of the packet.  <a href="#aea5a6460be64a0d83240fd2c234cd4ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a46a0362cea289b80f8ae8bffda655fd8">SetCursor</a> (__int64 packet, size_t cursor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the cursor position of the specified packet.  <a href="#a46a0362cea289b80f8ae8bffda655fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0">GetCursor</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the cursor position of the specified packet.  <a href="#a5e5f17a4f67ee287b3cb90295c5177d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af0bc7781b53d5d452fa74eca83c50482">Erase</a> (__int64 packet, size_t startPos, size_t amount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases part of the packet, decreasing used size and cursor position by the amount erased.  <a href="#af0bc7781b53d5d452fa74eca83c50482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a30c227a71645e05ea87051ce801152d6">Insert</a> (__int64 packet, size_t amount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts an empty space in the packet at the cursor position, increasing used size by the amount inserted.  <a href="#a30c227a71645e05ea87051ce801152d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a41ac732588a37b91a93fc7783f9d0657">CreatePacketFromPacket</a> (__int64 fromPacket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new packet, copying the contents of another packet.  <a href="#a41ac732588a37b91a93fc7783f9d0657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#accd76b26c54e28e3ddce1fc4047ae57f">CreatePacketFromString</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new packet, copying the contents of a C string.  <a href="#accd76b26c54e28e3ddce1fc4047ae57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac8aa2b803caa49c0acc6867a4bef5258">ComparePacketString</a> (__int64 packet, const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares a packet with a C string.  <a href="#ac8aa2b803caa49c0acc6867a4bef5258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a5cc568b9943fa823a3225e940c0733f9">ChangeMemorySize</a> (__int64 packet, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the memory size of the specified packet, without overwriting any packet data in the process.  <a href="#a5cc568b9943fa823a3225e940c0733f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a33df0d6b17fdd07525fb57e6f27bca88">AssignPacketString</a> (__int64 destination, const char *from)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns a C string to the specified packet.  <a href="#a33df0d6b17fdd07525fb57e6f27bca88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2c5e3fe22cb5b8d539321dd2060edf35">GetStringSize</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the size of a string by reading its prefix.  <a href="#a2c5e3fe22cb5b8d539321dd2060edf35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a95028f94c38fb9fd07800bbe66cc824e">Encrypt</a> (__int64 packet, __int64 key, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encrypts the specified packet.  <a href="#a95028f94c38fb9fd07800bbe66cc824e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a199dd8a98388fbfc77ac02c37a1598c6">Decrypt</a> (__int64 packet, __int64 key, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrypts the specified packet.  <a href="#a199dd8a98388fbfc77ac02c37a1598c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a46022e0f42b0e7fb083f200bfc0dabf0">GetLastEncryptionOperationFinished</a> (__int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the last encryption or decryption operation that was started on the specified packet has finished.  <a href="#a46022e0f42b0e7fb083f200bfc0dabf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac37658be31dcd70bd731e59f9731df4e">GetErrorFlag</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if an error is saved globally.  <a href="#ac37658be31dcd70bd731e59f9731df4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31dcd88a8b685fb8763617c9ea5f4c4"></a><!-- doxytag: member="mn::SetErrorFlag" ref="ae31dcd88a8b685fb8763617c9ea5f4c4" args="()" -->
DBP_CPP_DLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae31dcd88a8b685fb8763617c9ea5f4c4">SetErrorFlag</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the error flag to true so that <a class="el" href="namespacemn.html#ac37658be31dcd70bd731e59f9731df4e" title="Determines if an error is saved globally.">mn::GetErrorFlag</a> returns true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69089c1151b679a76f30ffcfcf604b91"></a><!-- doxytag: member="mn::ClearErrorFlag" ref="a69089c1151b679a76f30ffcfcf604b91" args="()" -->
DBP_CPP_DLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a69089c1151b679a76f30ffcfcf604b91">ClearErrorFlag</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the error flag so that <a class="el" href="namespacemn.html#ac37658be31dcd70bd731e59f9731df4e" title="Determines if an error is saved globally.">mn::GetErrorFlag</a> returns false. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad53407751aa123a13b1480610cbff41f">GetErrorCommand</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the command that caused the error that is saved globally.  <a href="#ad53407751aa123a13b1480610cbff41f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae78660a00605a9b3839788c92e41bbcc">GetErrorFile</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the name of the file that the error that is saved globally occurred in.  <a href="#ae78660a00605a9b3839788c92e41bbcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4fbd35964159f82775dd96022c16cad7">GetErrorFull</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an error message based on the global error report.  <a href="#a4fbd35964159f82775dd96022c16cad7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a2549f5831570f5109df5840719b407ae">GetErrorCode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the error code associated with the error that is saved globally.  <a href="#a2549f5831570f5109df5840719b407ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7ed53c036e816ff140be2084f6c7912e">GetErrorLine</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the line number at which the error that is saved globally occurred.  <a href="#a7ed53c036e816ff140be2084f6c7912e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa0e91e83b9cc8642ff935854764820c2">SetProfileBufferSizes</a> (__int64 profile, size_t recvSizeTCP, size_t recvSizeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifies the specified instance profile, loading it with buffer sizes.  <a href="#aa0e91e83b9cc8642ff935854764820c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad2fa263955d14ec167e70a857af2aaab">SetProfileEnabledUDP</a> (__int64 profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables or enables UDP.  <a href="#ad2fa263955d14ec167e70a857af2aaab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab410089cf457da4cb7ba8e56b8c8b013">SetProfileAutoResizeTCP</a> (__int64 profile, bool autoResize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the auto resize TCP option.  <a href="#ab410089cf457da4cb7ba8e56b8c8b013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0599cc2661f22695799eb75861133737">SetProfileHandshakeEnabled</a> (__int64 profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables or enables the handshaking option for the specified instance profile.  <a href="#a0599cc2661f22695799eb75861133737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6eef27da5b215a832d533e3f23ec17b2">SetProfileModeTCP</a> (__int64 profile, char modeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP mode for the specified instance profile.  <a href="#a6eef27da5b215a832d533e3f23ec17b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#abfa7ac2dada8b706375f283e6ca7d9c8">SetProfileGracefulDisconnectEnabled</a> (__int64 profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile.  <a href="#abfa7ac2dada8b706375f283e6ca7d9c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#afdce8fa11b7c1689deb1c2274e5f5f38">SetProfileSendTimeout</a> (__int64 profile, unsigned int timeoutMilliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the send timeout option for the specified instance profile. Send operations are allowed this amount of time to complete before the entity that initiated the operation is dropped.  <a href="#afdce8fa11b7c1689deb1c2274e5f5f38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a1934cbe74210d9d2911170ded6a0a978">SetProfilePostfixTCP</a> (__int64 profile, __int64 packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This command changes the postfix option of the specified instance profile.  <a href="#a1934cbe74210d9d2911170ded6a0a978"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae50662bc5a7f605697468cd7f65fc7ab">SetProfileNagleEnabledTCP</a> (__int64 profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This command changes the nagle algorithm option.  <a href="#ae50662bc5a7f605697468cd7f65fc7ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0764e70a254c557b528e1fa4a9d16a4d">SetProfileLocalTCP</a> (__int64 profile, const char *IP, unsigned short port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local TCP address of the specified instance profile.  <a href="#a0764e70a254c557b528e1fa4a9d16a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac0972b0ace59cbdec2c987d1028ae2e2">SetProfileLocalUDP</a> (__int64 profile, const char *IP, unsigned short port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local UDP address of the specified instance profile.  <a href="#ac0972b0ace59cbdec2c987d1028ae2e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab3a68a1529a25353794e70ac1892b016">SetProfileLocal</a> (__int64 profile, const char *IP_TCP, unsigned short portTCP, const char *IP_UDP, unsigned short portUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local TCP and UDP address of the specified instance profile.  <a href="#ab3a68a1529a25353794e70ac1892b016"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9d64e3c108c8aab36271ac4751dd0c56">SetProfileDecryptKeyUDP</a> (__int64 profile, __int64 key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the encryption key used to decrypt incoming UDP packets.  <a href="#a9d64e3c108c8aab36271ac4751dd0c56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9c3118c75c09780b67a93126237385d6">SetProfileServerTimeout</a> (__int64 profile, size_t timeoutMilliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a9c3118c75c09780b67a93126237385d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a26e692b76b3c7de234bdc106241bb0ec">SetProfileModeUDP</a> (__int64 profile, char modeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the UDP mode for the specified instance profile.  <a href="#a26e692b76b3c7de234bdc106241bb0ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae8c0e5371300f58773ee06e0a24484ae">SetProfileReusableUDP</a> (__int64 profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the reusable UDP option. If reusable other applications, instances and sockets can bind to the same UDP address.  <a href="#ae8c0e5371300f58773ee06e0a24484ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#abdc6d771977a7314824360236da3e966">SetProfileNumOperationsUDP</a> (__int64 profile, size_t numOperations)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>.  <a href="#abdc6d771977a7314824360236da3e966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a638da78b6da3fa2b3f1e9c89ad20233b">GetProfileBufferSizeTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP receive buffer size set for the specified instance profile.  <a href="#a638da78b6da3fa2b3f1e9c89ad20233b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a544aa1d33e22e88c562cca5c0024ab1f">GetProfileBufferSizeUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP receive buffer size set for the specified instance profile.  <a href="#a544aa1d33e22e88c562cca5c0024ab1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a523d1b974c9785f00f2e7f5b26c5c2c2">GetProfileLocalIPTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP IP address stored in the specified instance profile.  <a href="#a523d1b974c9785f00f2e7f5b26c5c2c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a689199a271d286090871df67a789b6df">GetProfileLocalPortTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP port stored in the specified instance profile.  <a href="#a689199a271d286090871df67a789b6df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPP_DLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aacce68da4e111d9e4633612660ed4b07">GetProfileLocalIPUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP IP address stored in the specified instance profile.  <a href="#aacce68da4e111d9e4633612660ed4b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a465182dbc176f30ec2e46a0a700a69ea">GetProfileLocalPortUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP port stored in the specified instance profile.  <a href="#a465182dbc176f30ec2e46a0a700a69ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a395289f6266e2ee08091c3099b235302">GetProfileEnabledUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP is enabled for the specified instance profile.  <a href="#a395289f6266e2ee08091c3099b235302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#afd73e16d7b1f93fe61ea1779350aca18">GetProfileDecryptKeyLoadedUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a decryption key has been set.  <a href="#afd73e16d7b1f93fe61ea1779350aca18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a479f9bfb83337581115f69cac70ba8bd">GetProfileDecryptKeyUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the encryption key used to decrypt incoming UDP packets.  <a href="#a479f9bfb83337581115f69cac70ba8bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4c8fbfebb44500e7957b551adec86059">GetProfileHandshakeEnabled</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the TCP handshake process is enabled for the specified instance profile.  <a href="#a4c8fbfebb44500e7957b551adec86059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9b7066e85fc1d4c14209a60e2c86bb13">GetProfileModeTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP mode for the specified instance profile.  <a href="#a9b7066e85fc1d4c14209a60e2c86bb13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#adc65c37445c956f898dd99bf12ed83a4">GetProfileModeUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP mode for the specified instance profile.  <a href="#adc65c37445c956f898dd99bf12ed83a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7d5b31e606b2fad59d6c92e8f896af47">GetProfileAutoResizeTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the auto resize TCP option is enabled.  <a href="#a7d5b31e606b2fad59d6c92e8f896af47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8b32e26ca40b7d1e7318bc3d4d9a29bc">GetProfileSendTimeout</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the send timeout option for the specified instance profile. Send operations are allowed this length of time to complete before the entity that initiated them is forcefully disconnected.  <a href="#a8b32e26ca40b7d1e7318bc3d4d9a29bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af44ffb1aa298412b6f62ab90ea11cfd8">GetProfileGracefulDisconnectEnabled</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile.  <a href="#af44ffb1aa298412b6f62ab90ea11cfd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a367cd31a98fa72fd8a15d45ccc4376ce">GetProfileNagleEnabledTCP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the nagle algorithm option from the specified instance profile.  <a href="#a367cd31a98fa72fd8a15d45ccc4376ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a75ec773a0f4496d15438bdc9b87b7836">GetProfilePostfixTCP</a> (__int64 profile, __int64 destination)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the postfix option of the specified instance profile. This option only apples to instances in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode.  <a href="#a75ec773a0f4496d15438bdc9b87b7836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aaba1cc458821e0784f123aaf44daf8e9">GetProfileReusableUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP should be reusable. If reusable other applications, instances and sockets can bind to the same UDP address.  <a href="#aaba1cc458821e0784f123aaf44daf8e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a1466e9a3ae29a949efe1ce5acdd4ad5f">GetProfileServerTimeout</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a1466e9a3ae29a949efe1ce5acdd4ad5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ada5cdd9d36f80d959853aa4fdd3e34d3">GetProfileNumOperationsUDP</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>.  <a href="#ada5cdd9d36f80d959853aa4fdd3e34d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a048256bb7a8ee6ab812d4696cefd61af">CreateInstanceProfile</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance profile, filled with default options.  <a href="#a048256bb7a8ee6ab812d4696cefd61af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9f8d86986cd43ca15ab482b4abe99945">CreateInstanceProfileFrom</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new instance profile, copying the data of a pre-existing instance profile.  <a href="#a9f8d86986cd43ca15ab482b4abe99945"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a49327f5b522c5c0d6d18a84c975cd2aa">DeleteInstanceProfile</a> (__int64 profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified instance profile.  <a href="#a49327f5b522c5c0d6d18a84c975cd2aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a46ad175039e272f22babeee09229fc25">AssignInstanceProfile</a> (__int64 dest, __int64 source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns the contents of a source profile into a destination profile.  <a href="#a46ad175039e272f22babeee09229fc25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a63ef4ffbab0e24d8c68058b43dcce3c3">CompareInstanceProfile</a> (__int64 profile1, __int64 profile2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares <em>profile1</em> and <em>profile2</em>.  <a href="#a63ef4ffbab0e24d8c68058b43dcce3c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7dbb56094130ab288e1379defacb3f90">ToggleErrorMode</a> (int errorMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles error mode.  <a href="#a7dbb56094130ab288e1379defacb3f90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6e2a2ce91d0eb804d0ee01a68e5f9ccc">SetErrorMode</a> (int errorMode, bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables an error mode.  <a href="#a6e2a2ce91d0eb804d0ee01a68e5f9ccc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a62c409059881908699a72a3722eacfbe">GetErrorMode</a> (int errorMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether an error mode is enabled.  <a href="#a62c409059881908699a72a3722eacfbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a820eed66d32aac0dff3130edfe8c2fc5">CreateKey256</a> (__int64 key1, __int64 key2, __int64 key3, __int64 key4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an encryption key of bit strength 256.  <a href="#a820eed66d32aac0dff3130edfe8c2fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad552576288521cb5b06a62a475979019">CreateKey192</a> (__int64 key1, __int64 key2, __int64 key3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an encryption key of bit strength 192.  <a href="#ad552576288521cb5b06a62a475979019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aa7965082be8c8c750040b600b4983751">CreateKey128</a> (__int64 key1, __int64 key2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an encryption key of bit strength 128.  <a href="#aa7965082be8c8c750040b600b4983751"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#acb38ba4db45ea37eb762d9fe22045025">DeleteKey</a> (__int64 Key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified encryption key.  <a href="#acb38ba4db45ea37eb762d9fe22045025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBP_CPP_DLL size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#acaad9f6d77fe2ebd20db513978949fc7">GetLogicalCPU</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of logical cores on the system.  <a href="#acaad9f6d77fe2ebd20db513978949fc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a03e4a7849d9aa386ca0e139367d5c36f">DNS_A</a> (const char *hostName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the IP address of the specified host name.  <a href="#a03e4a7849d9aa386ca0e139367d5c36f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a629161ab269f8c863a3177abba2a3055">GetLocalInterface</a> (size_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a local interface.  <a href="#a629161ab269f8c863a3177abba2a3055"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4c829125861bed7e33afcf3cfd25b834">Connect</a> (size_t instanceID, const <a class="el" href="class_net_address.html">NetAddress</a> *connectAddrTCP, const <a class="el" href="class_net_address.html">NetAddress</a> *connectAddrUDP, size_t timeoutMilliseconds, bool block, const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a client instance into the specified instance ID.  <a href="#a4c829125861bed7e33afcf3cfd25b834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae6efe6a55174aa31805c0d7768f3e08c">StartServer</a> (size_t instanceID, size_t maxClients, const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a server instance into the specified instance ID.  <a href="#ae6efe6a55174aa31805c0d7768f3e08c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a286e995f3afa08292c38838bb3908fb9">StartBroadcast</a> (size_t instanceID, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;connectAddress, bool sendEnabled, bool recvEnabled, const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a broadcasting instance into the specified instance ID.  <a href="#a286e995f3afa08292c38838bb3908fb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a999a5af217f64d3c18ee9a94c1f94b4d">GetClientAddressTCP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote TCP address of a currently connected client.  <a href="#a999a5af217f64d3c18ee9a94c1f94b4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae287dc45367896e319d1514aefe3c87f">GetClientAddressUDP</a> (size_t instanceID, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the remote UDP address of a currently connected client.  <a href="#ae287dc45367896e319d1514aefe3c87f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a539cbc714e7b5a1ea1f19bca9b9b2ba1">GetConnectAddressTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the address that the client is connected to via TCP.  <a href="#a539cbc714e7b5a1ea1f19bca9b9b2ba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a21d78dd4a2693e3924f71f148319a5bd">GetConnectAddressUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the address that the client is connected to via UDP.  <a href="#a21d78dd4a2693e3924f71f148319a5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7fbec55bb4f503c2afdd1aa48cbd141e">GetPostfixTCP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP postfix in use.  <a href="#a7fbec55bb4f503c2afdd1aa48cbd141e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9607086d552b4334905d2db5c1256cce">GetLocalAddressTCP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP address of the specified instance.  <a href="#a9607086d552b4334905d2db5c1256cce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a3079e11eb9cbd6f70b8d9c756f33b01b">GetLocalAddressUDP</a> (size_t instanceID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP address of the specified instance.  <a href="#a3079e11eb9cbd6f70b8d9c756f33b01b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af95cb95140c98a5eeb54d7ef29ff1480">RecvTCP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;destinationPacket, size_t clientID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a TCP packet from the TCP received packet queue.  <a href="#af95cb95140c98a5eeb54d7ef29ff1480"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7ff7c0406f00568fbe51571ba3f87be1">RecvUDP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;destinationPacket, size_t clientID, size_t operationID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a UDP packet from the UDP received packet queue.  <a href="#a7ff7c0406f00568fbe51571ba3f87be1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad57dddf4d781b354113e5e3d74dc3a5a">SendUDP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet, size_t clientID, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends UDP data to a client on the specified instance.  <a href="#ad57dddf4d781b354113e5e3d74dc3a5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a24c13b82fd717671e16d1d4dd9f5e16d">SendToUDP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;address, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends UDP data to an unconnected entity, identified only by its remote address.  <a href="#a24c13b82fd717671e16d1d4dd9f5e16d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a93916238ec8d933a6e874660f7d3cc47">SendTCP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet, size_t clientID, bool keep, bool block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends TCP data to a client on the specified instance.  <a href="#a93916238ec8d933a6e874660f7d3cc47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0294004c6f4549d4c1dc403551ccd6d1">SendAllTCP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool keep, bool block, size_t clientExcludeID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a TCP packet to all clients on the specified instance.  <a href="#a0294004c6f4549d4c1dc403551ccd6d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a83608bf51559da75a3ea3411d2a386ad">SendAllUDP</a> (size_t instanceID, <a class="el" href="class_packet.html">Packet</a> &amp;packet, bool keep, bool block, size_t clientExcludeID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a UDP packet to all clients on the specified instance.  <a href="#a83608bf51559da75a3ea3411d2a386ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ad500886a9ca404e1fd2a4c4568e42a4b">SetProfileModeUDP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> modeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the UDP mode for the specified instance profile.  <a href="#ad500886a9ca404e1fd2a4c4568e42a4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7487a6626a20e589983d4b513f965343">GetProfileModeUDP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP mode for the specified instance profile.  <a href="#a7487a6626a20e589983d4b513f965343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a55055a7e62d51d95aa6532f730d0a581">SetProfileBufferSizes</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, size_t recvSizeTCP, size_t recvSizeUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifies the specified instance profile, loading it with buffer sizes.  <a href="#a55055a7e62d51d95aa6532f730d0a581"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4ab287e14e0b6bc85f580ce81b756261">SetProfileEnabledUDP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables or enables UDP.  <a href="#a4ab287e14e0b6bc85f580ce81b756261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8119c03dd576a92ae38d126c56595f60">SetProfileAutoResizeTCP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, bool autoResize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the auto resize TCP option.  <a href="#a8119c03dd576a92ae38d126c56595f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a7c1a4cfa1663b13abfaed2b1b8476780">SetProfileHandshakeEnabled</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables or enables the handshaking option for the specified instance profile.  <a href="#a7c1a4cfa1663b13abfaed2b1b8476780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae56c4d95f9ecc254b04cccd03f4a8a88">SetProfileModeTCP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> modeTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP mode for the specified instance profile.  <a href="#ae56c4d95f9ecc254b04cccd03f4a8a88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#acd97640f8602438193812c272b829dd1">SetProfileGracefulDisconnectEnabled</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile.  <a href="#acd97640f8602438193812c272b829dd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#abc9793b165372548ed3c10b470244efd">SetProfileSendTimeout</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, unsigned int timeoutMilliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the send timeout option for the specified instance profile. Send operations are allowed this amount of time to complete before the entity that initiated the operation is dropped.  <a href="#abc9793b165372548ed3c10b470244efd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a751e72752dfd6b8fe814951f0580bd38">SetProfilePostfixTCP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, const <a class="el" href="class_packet.html">Packet</a> &amp;packet)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This command changes the postfix option of the specified instance profile.  <a href="#a751e72752dfd6b8fe814951f0580bd38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aaf460a06d05ca0a65cd284aeb02b7f89">SetProfileNagleEnabledTCP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, bool option)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This command changes the nagle algorithm option.  <a href="#aaf460a06d05ca0a65cd284aeb02b7f89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a5dd58ab1e4ed9f76eca562f3da2b4f8e">SetProfileLocalTCP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addressTCP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local TCP address of the specified instance profile.  <a href="#a5dd58ab1e4ed9f76eca562f3da2b4f8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac0959be09dc2abd364d9c209fe6296b6">SetProfileLocalUDP</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addressUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local UDP address of the specified instance profile.  <a href="#ac0959be09dc2abd364d9c209fe6296b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a93163a023edd6728be16cc372102410e">SetProfileLocal</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addressTCP, const <a class="el" href="class_net_address.html">NetAddress</a> &amp;addressUDP)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the local TCP and UDP address of the specified instance profile.  <a href="#a93163a023edd6728be16cc372102410e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a8efc5de6466f9709510161e20a8375ff">SetProfileServerTimeout</a> (<a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile, size_t timeoutMilliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a8efc5de6466f9709510161e20a8375ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a56025854b599712a4787d1e5cd8ce502">GetProfileServerTimeout</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped.  <a href="#a56025854b599712a4787d1e5cd8ce502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac2ee4d9e630c70d78f6e1b88aae40f08">GetProfileFunctionTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP function set for the specified instance profile.  <a href="#ac2ee4d9e630c70d78f6e1b88aae40f08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4a14f8b971fbcb6bf71d8b0b68a3b31c">GetProfileFunctionUDP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP function set for the specified instance profile.  <a href="#a4a14f8b971fbcb6bf71d8b0b68a3b31c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a48fb0065708925bdfbaf6417fb8cf5ba">GetProfileBufferSizeTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP receive buffer size set for the specified instance profile.  <a href="#a48fb0065708925bdfbaf6417fb8cf5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#abd94f490a1309bd014054ccec0a0ec37">GetProfileBufferSizeUDP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UDP receive buffer size set for the specified instance profile.  <a href="#abd94f490a1309bd014054ccec0a0ec37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a1e4a81f4292c441f96a3c4570ad478f4">GetProfileEnabledUDP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether UDP is enabled for the specified instance profile.  <a href="#a1e4a81f4292c441f96a3c4570ad478f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ac03adfd09e27f61434b7a596ac09ac04">GetProfileAutoResizeTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the auto resize TCP option is enabled.  <a href="#ac03adfd09e27f61434b7a596ac09ac04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ab3988fac0c174c504420effad77d4060">GetProfileHandshakeEnabled</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the TCP handshake process is enabled for the specified instance profile.  <a href="#ab3988fac0c174c504420effad77d4060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a9d39472596d65f39e019a1ca459c17c6">GetProfileModeTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the TCP mode for the specified instance profile.  <a href="#a9d39472596d65f39e019a1ca459c17c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a954a7dd680e686b203ff77a77dd5ab91">GetProfileGracefulDisconnectEnabled</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile.  <a href="#a954a7dd680e686b203ff77a77dd5ab91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a6cbfb2045db8a67cf6d02b372512018b">GetProfileSendTimeout</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the send timeout option for the specified instance profile. Send operations are allowed this length of time to complete before the entity that initiated them is forcefully disconnected.  <a href="#a6cbfb2045db8a67cf6d02b372512018b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a87cddb55f8b9e37e079da963fcb3ffc2">GetProfilePostfixTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the postfix option of the specified instance profile.  <a href="#a87cddb55f8b9e37e079da963fcb3ffc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a391ffe530a30a3016f8d11e6a3d0068d">GetProfileNagleEnabledTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the nagle algorithm option from the specified instance profile.  <a href="#a391ffe530a30a3016f8d11e6a3d0068d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#ae8a6606bc8aef43bd3ca74772ee7118d">GetProfileLocalAddressTCP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local TCP address stored in the specified instance profile.  <a href="#ae8a6606bc8aef43bd3ca74772ee7118d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_address.html">NetAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a4ba287b3bb8e2f01357028db198d0249">GetProfileLocalAddressUDP</a> (const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the local UDP address stored in the specified instance profile.  <a href="#a4ba287b3bb8e2f01357028db198d0249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a0a01e895d4f298c3ed9481d1f544cfef">ToggleErrorMode</a> (<a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a> errorMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles error mode.  <a href="#a0a01e895d4f298c3ed9481d1f544cfef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#af9e7e2b2efefe79f68bb72dca9212fd2">SetErrorMode</a> (<a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a> errorMode, bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables an error mode.  <a href="#af9e7e2b2efefe79f68bb72dca9212fd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#a282e7ed695df1c16ee6abad63175bf1d">GetErrorMode</a> (<a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a> errorMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether an error mode is enabled.  <a href="#a282e7ed695df1c16ee6abad63175bf1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemn.html#aae72e4f0b526ae1d6b187c2bbe13dadc">TestClass</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests class.  <a href="#aae72e4f0b526ae1d6b187c2bbe13dadc"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Commands for procedural programming, that wrap around internal classes. </p>
<p>These commands exist for those who prefer procedural programming over object orientated. They wrap around the classes of the networking module and deal with errors differently dependent on the error mode we are in. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a05539f2bdb0fb27245b5ab8b997391e7"></a><!-- doxytag: member="mn::AddByte" ref="a05539f2bdb0fb27245b5ab8b997391e7" args="(__int64 packet, char Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a byte to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ad372ea8cead9fcb5a917c5ec2b71d0f3"></a><!-- doxytag: member="mn::AddDouble" ref="ad372ea8cead9fcb5a917c5ec2b71d0f3" args="(__int64 packet, double Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddDouble </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a double to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a5a2b8af8c6c80b9426179184af910cc5"></a><!-- doxytag: member="mn::AddFloat" ref="a5a2b8af8c6c80b9426179184af910cc5" args="(__int64 packet, float Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddFloat </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a float to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a55b7a2af579d2a8a49a96dd23ab8b3a3"></a><!-- doxytag: member="mn::AddInt" ref="a55b7a2af579d2a8a49a96dd23ab8b3a3" args="(__int64 packet, int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="aa84c596e872485bd5f6cc2d3942f7b04"></a><!-- doxytag: member="mn::AddLongDouble" ref="aa84c596e872485bd5f6cc2d3942f7b04" args="(__int64 packet, long double Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddLongDouble </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a long double to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a627c50f822de74e537d995c97d7e7157"></a><!-- doxytag: member="mn::AddLongInt" ref="a627c50f822de74e537d995c97d7e7157" args="(__int64 packet, long int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a long integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a13d6eed8b77ec2dda29e05439e74a362"></a><!-- doxytag: member="mn::AddLongLongInt" ref="a13d6eed8b77ec2dda29e05439e74a362" args="(__int64 packet, long long int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddLongLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an long long integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="adcd416fad1bd4e97075d610dd89c5501"></a><!-- doxytag: member="mn::AddPacket" ref="adcd416fad1bd4e97075d610dd89c5501" args="(__int64 dest, __int64 source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddPacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combines two packets together. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that <em>source</em> should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that should be added to <em>dest</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a964d359bc5323cce38f4e74445394f0e"></a><!-- doxytag: member="mn::AddShortInt" ref="a964d359bc5323cce38f4e74445394f0e" args="(__int64 packet, short int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddShortInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a short integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="aadfe7586ddbb5a7db38a1039305bbfdd"></a><!-- doxytag: member="mn::AddSignedByte" ref="aadfe7586ddbb5a7db38a1039305bbfdd" args="(__int64 packet, signed char Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddSignedByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a signed byte to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ab28c93686b6e27a980d244971a83bc43"></a><!-- doxytag: member="mn::AddSizeT" ref="ab28c93686b6e27a980d244971a83bc43" args="(__int64 packet, size_t add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddSizeT </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned short integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
<p>Use this command when adding client IDs and operation IDs in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abb3d396c14fdec8b8e5fd8a785dfba45">NetMode::UDP_PER_CLIENT</a> and <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a>. </p>

</div>
</div>
<a class="anchor" id="af0362f4b04ef52ae68a71e64a102e898"></a><!-- doxytag: member="mn::AddStringC" ref="af0362f4b04ef52ae68a71e64a102e898" args="(__int64 packet, const char *source, size_t length, bool prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddStringC </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a C string to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to add data to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>String to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>If 0 <em>source</em> must be a null terminated string, otherwise length must be the number of bytes of <em>source</em> that should be added. Note that if the string is null terminated, the null terminator is not added to the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>If true a prefix will be added to the packet, indicating the size of the remaining string. On the receiving end this prefix can be used by specifying a length of 0 using <a class="el" href="namespacemn.html#a68b28730fe0c294b9c9e7594617b5c7b" title="Retrieves a C string from the specified packet, allocating new memory to that string.">mn::GetStringC</a>. This removes the need to know the size of the string before extracting it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a567b66268ff1f61419d14a0bccb00ccc"></a><!-- doxytag: member="mn::AddUnsignedByte" ref="a567b66268ff1f61419d14a0bccb00ccc" args="(__int64 packet, unsigned char Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddUnsignedByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned byte to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a014728aa15cb725505b6062e8abf9142"></a><!-- doxytag: member="mn::AddUnsignedInt" ref="a014728aa15cb725505b6062e8abf9142" args="(__int64 packet, unsigned int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a59131fe114eb83ccc8816dfb015956d9"></a><!-- doxytag: member="mn::AddUnsignedLongInt" ref="a59131fe114eb83ccc8816dfb015956d9" args="(__int64 packet, unsigned long int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddUnsignedLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned long int to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a032a2dc3f99830a39d36db8036969a35"></a><!-- doxytag: member="mn::AddUnsignedLongLongInt" ref="a032a2dc3f99830a39d36db8036969a35" args="(__int64 packet, unsigned long long int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::AddUnsignedLongLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned long long integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a590134153518dcccb80a21eed60d194d"></a><!-- doxytag: member="mn::AddUnsignedShortInt" ref="a590134153518dcccb80a21eed60d194d" args="(__int64 packet, unsigned short int Add)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AddUnsignedShortInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short int&nbsp;</td>
          <td class="paramname"> <em>add</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an unsigned short integer to the specified packet. </p>
<p>Adds an unsigned integer to the specified packet. </p>
<p>The data is is copied into the packet's data buffer and is stores as a series of bytes. Data is added at the current cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>) and the cursor position is increased by the size of the data added. Used size is increased by the size of the data added assuming the data is added at the end of the packet; if not, used size is only increased if more memory is used. Memory size is increased if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that data should be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add</em>&nbsp;</td><td>Data to add to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a46ad175039e272f22babeee09229fc25"></a><!-- doxytag: member="mn::AssignInstanceProfile" ref="a46ad175039e272f22babeee09229fc25" args="(__int64 dest, __int64 source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 mn::AssignInstanceProfile </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns the contents of a source profile into a destination profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Location to copy into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Location to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>dest</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a11a1517b94d11908e08bd1a5edfecbce"></a><!-- doxytag: member="mn::AssignPacket" ref="a11a1517b94d11908e08bd1a5edfecbce" args="(__int64 dest, __int64 source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AssignPacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns a source packet to another destination packet, overwriting anything in the destination packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that <em>source</em> should be copied into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that should be copied into <em>dest</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a33df0d6b17fdd07525fb57e6f27bca88"></a><!-- doxytag: member="mn::AssignPacketString" ref="a33df0d6b17fdd07525fb57e6f27bca88" args="(__int64 destination, const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::AssignPacketString </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns a C string to the specified packet. </p>
<p><em>destination's</em> used size will equal <em>from's</em> string length. The contents of <em>destination</em> will equal the contents of <em>from</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>NULL terminated string to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b1a02847005a257c1c08e96558c162"></a><!-- doxytag: member="mn::ChangeBufferSizeTCP" ref="ab9b1a02847005a257c1c08e96558c162" args="(size_t instanceID, size_t clientID, size_t newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ChangeBufferSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the size of the largest TCP packet that can be received; packets larger than this will require an increase in memory size or an error will be thrown. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Attempting to decrease the size may not be effective. If data exists in the buffer this will not be discarded. The buffer will decrease as much as possible without discarding data. If an attempt is made to decrease the buffer size below the minimum for that instance then an error will occur. <br/>
<br/>
</dd></dl>
<p>Can only be used on an active TCP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newSize</em>&nbsp;</td><td>New buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cc568b9943fa823a3225e940c0733f9"></a><!-- doxytag: member="mn::ChangeMemorySize" ref="a5cc568b9943fa823a3225e940c0733f9" args="(__int64 packet, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ChangeMemorySize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the memory size of the specified packet, without overwriting any packet data in the process. </p>
<p>Only memory size, cursor position and used size are changed.<br/>
<br/>
</p>
<p>The memory size determines how much data can be stored in the packet. Although the packet automatically increases in memory size as data is added, it is best to set the memory size initially to avoid unnecessary reallocation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>New memory size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d701ece0f90e9234eb8bd9cf67691b3"></a><!-- doxytag: member="mn::ClearPacket" ref="a2d701ece0f90e9234eb8bd9cf67691b3" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ClearPacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the specified packet, erasing all data stored. </p>
<p>Memory size is unchanged. The main actions taken are to reset cursor position and used size, meaning that this operation is very efficient.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a182830933908a7e2338d710565c2bbb4"></a><!-- doxytag: member="mn::ClientConnected" ref="a182830933908a7e2338d710565c2bbb4" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> mn::ClientConnected </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the specified client is connected, and what stage of the graceful disconnection process it is at. </p>
<p>In server state this command is used to check if the specified client ID is in use. <br/>
 In client state this command is used to check that the client is still connected to the server (<em>clientID</em> is ignored). <br/>
 In other states this command returns <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> indicating that the instance is active or <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6daef8b7210b8ae3961e19fcde743ee08af">NetUtility::NOT_CONNECTED</a> indicating that the instance is inactive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a>: Fully connected/operational. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6daef8b7210b8ae3961e19fcde743ee08af">NetUtility::NOT_CONNECTED</a>: Not connected at all. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dad749d5c33d1f4fda670efe634f651885">NetUtility::NO_RECV</a>: Connected but new data cannot be received because <code>Shutdown</code> has been used by recipient (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da1bcc92a56bd754f0e02e33787f7f9e38">NetUtility::NO_SEND</a>: Connected but data cannot be sent because <code>Shutdown</code> has been used (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabfdb16770f1140f86d621739ffe89560">NetUtility::NO_SEND_RECV</a>: Connected but data cannot be sent or received because <code>Shutdown</code> has been used on both sides, only data that has already been received and is in the packet queue can be received (only possible if graceful disconnect is enabled). </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a>: If an error occurred whilst connecting or whilst executing this command. </dd></dl>

</div>
</div>
<a class="anchor" id="aa88fef80cdb3574c2b6ba46931f8a133"></a><!-- doxytag: member="mn::ClientJoined" ref="aa88fef80cdb3574c2b6ba46931f8a133" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::ClientJoined </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manages incoming connections from clients. </p>
<p>For a client to connect, this command must have been called several times during the handshaking process. It is best to call this continuously in a loop that runs this networking module. <br/>
<br/>
</p>
<p>Connection requests will be rejected if the maximum number of clients has been reached.<br/>
<br/>
</p>
<p>This command can be used only on an active server instance.<br/>
<br/>
</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;0 if a client was accepted, this is the client ID that was assigned to that client. </dd>
<dd>
0 if no new clients were accepted in this call. </dd></dl>

</div>
</div>
<a class="anchor" id="a24fc1fbd520a0e0095810ad6fec20c5a"></a><!-- doxytag: member="mn::ClientLeft" ref="a24fc1fbd520a0e0095810ad6fec20c5a" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::ClientLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keeps track of who has disconnected recently. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;0 if a client has disconnected since the last call to this method, this is the ID of that client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ef4ffbab0e24d8c68058b43dcce3c3"></a><!-- doxytag: member="mn::CompareInstanceProfile" ref="a63ef4ffbab0e24d8c68058b43dcce3c3" args="(__int64 profile1, __int64 profile2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::CompareInstanceProfile </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares <em>profile1</em> and <em>profile2</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile1</em>&nbsp;</td><td>An instance profile to compare with <em>profile2</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile2</em>&nbsp;</td><td>An instance profile to compare with <em>profile1</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <em>profile1</em> and <em>profile2</em> are identical. </dd>
<dd>
0 if <em>profile1</em> and <em>profile2</em> are different in any way. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a67b272ded28669e8c163b425f8893351"></a><!-- doxytag: member="mn::ComparePacket" ref="a67b272ded28669e8c163b425f8893351" args="(__int64 packet1, __int64 packet2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ComparePacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet1</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to compare with <em>packet2</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet2</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to compare with <em>packet1</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <em>packet1</em> is identical to <em>packet2</em>. </dd>
<dd>
0 if <em>packet1</em> is different in any way to <em>packet2</em>. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8aa2b803caa49c0acc6867a4bef5258"></a><!-- doxytag: member="mn::ComparePacketString" ref="ac8aa2b803caa49c0acc6867a4bef5258" args="(__int64 packet, const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ComparePacketString </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares a packet with a C string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>NULL terminated string to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <em>packet</em> contains <em>str</em> and if the used size of <em>packet</em> is equal to the length of <em>str</em>. </dd>
<dd>
0 if <em>packet</em> doesn't contain <em>str</em> or if <em>str</em> length is not equal to <em>packet</em> used size. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c829125861bed7e33afcf3cfd25b834"></a><!-- doxytag: member="mn::Connect" ref="a4c829125861bed7e33afcf3cfd25b834" args="(size_t instanceID, const NetAddress *connectAddrTCP, const NetAddress *connectAddrUDP, size_t timeoutMilliseconds, bool block, const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> mn::Connect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>connectAddrTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>connectAddrUDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a client instance into the specified instance ID. </p>
<p>The client instance attempts to connect to the specified address. Once the connection process is complete the instance is fully active. Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance ID that new instance should be stored in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectAddrTCP</em>&nbsp;</td><td>Address to connect to via TCP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectAddrUDP</em>&nbsp;</td><td>Address to connect to via UDP. Can be NULL if UDP is disabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Length of time in milliseconds to wait before giving up on the connection attempt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true this command will block until <em>timeoutMilliseconds</em> has expired or the connection process has completed. <br/>
 If false this command will return instantly and <a class="el" href="namespacemn.html#a3f6e329576ac7a8c036f2040bd6314a3" title="Retrieves the status of the handshaking process.">mn::PollConnect</a> should be used on the instance to poll on the connection process and determine its success/failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile containing additional instance settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>if block is true: <br/>
 </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabc894c2de7a4404e353f3bcc1193e90b">NetUtility::REFUSED</a> if the server is full and so the connection attempt failed.<br/>
<br/>
</dd>
<dd>
if <em>block</em> is false:<br/>
 </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da86caa623f8ffc60da40df3c2ab17532c">NetUtility::STILL_CONNECTING</a> indicating that the connection process has begun and <a class="el" href="namespacemn.html#a3f6e329576ac7a8c036f2040bd6314a3" title="Retrieves the status of the handshaking process.">mn::PollConnect</a> should be used to check its status. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9399b132dc43e4b46d578a25f422bc0"></a><!-- doxytag: member="mn::Connect" ref="ab9399b132dc43e4b46d578a25f422bc0" args="(size_t instanceID, const char *connectIP_TCP, unsigned short connectPort_TCP, const char *connectIP_UDP, unsigned short connectPort_UDP, size_t timeoutMilliseconds, bool block, __int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> mn::Connect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connectIP_TCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>connectPort_TCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connectIP_UDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>connectPort_UDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a client instance into the specified instance ID. </p>
<p>The client instance attempts to connect to the specified address. Once the connection process is complete the instance is fully active. Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Instance ID that new instance should be stored in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectIP_TCP</em>&nbsp;</td><td>IP address to connect to via TCP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectPort_TCP</em>&nbsp;</td><td>Port to connect to via TCP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectIP_UDP</em>&nbsp;</td><td>IP address to connect to via UDP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectPort_UDP</em>&nbsp;</td><td>Port to connect to via UDP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Length of time in milliseconds to wait before giving up on the connection attempt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true this command will block until <em>timeoutMilliseconds</em> has expired or the connection process has completed. <br/>
 If false this command will return instantly and <a class="el" href="namespacemn.html#a3f6e329576ac7a8c036f2040bd6314a3" title="Retrieves the status of the handshaking process.">mn::PollConnect</a> should be used on the instance to poll on the connection process and determine its success/failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Pointer (cast to __int64) to instance profile containing additional instance settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>if block is true: <br/>
 </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabc894c2de7a4404e353f3bcc1193e90b">NetUtility::REFUSED</a> if the server is full and so the connection attempt failed.<br/>
<br/>
</dd>
<dd>
if <em>block</em> is false:<br/>
 </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da86caa623f8ffc60da40df3c2ab17532c">NetUtility::STILL_CONNECTING</a> indicating that the connection process has begun and <a class="el" href="namespacemn.html#a3f6e329576ac7a8c036f2040bd6314a3" title="Retrieves the status of the handshaking process.">mn::PollConnect</a> should be used to check its status. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a048256bb7a8ee6ab812d4696cefd61af"></a><!-- doxytag: member="mn::CreateInstanceProfile" ref="a048256bb7a8ee6ab812d4696cefd61af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 mn::CreateInstanceProfile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance profile, filled with default options. </p>
<p>An instance profile is an object that contains a variety of options specific to instances. Any instance can have an instance profile loaded into it during initialization. Each option has a default value, which often does not need to be changed. By using instance profiles lengthy constructors are avoided. As well as this, similar profiles with similar settings can use the same profile; this is a neat way of sharing options between instances.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>instance profile with default settings. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f8d86986cd43ca15ab482b4abe99945"></a><!-- doxytag: member="mn::CreateInstanceProfileFrom" ref="a9f8d86986cd43ca15ab482b4abe99945" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 mn::CreateInstanceProfileFrom </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new instance profile, copying the data of a pre-existing instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new Instance profile. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7965082be8c8c750040b600b4983751"></a><!-- doxytag: member="mn::CreateKey128" ref="aa7965082be8c8c750040b600b4983751" args="(__int64 key1, __int64 key2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreateKey128 </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an encryption key of bit strength 128. </p>
<p>The same key must be used to encrypt as is used to decrypt if the decrypted data is to make sense.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key1</em>&nbsp;</td><td>The first key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key2</em>&nbsp;</td><td>The second key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>encryption key. </dd></dl>

</div>
</div>
<a class="anchor" id="ad552576288521cb5b06a62a475979019"></a><!-- doxytag: member="mn::CreateKey192" ref="ad552576288521cb5b06a62a475979019" args="(__int64 key1, __int64 key2, __int64 key3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreateKey192 </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an encryption key of bit strength 192. </p>
<p>The same key must be used to encrypt as is used to decrypt if the decrypted data is to make sense.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key1</em>&nbsp;</td><td>The first key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key2</em>&nbsp;</td><td>The second key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key3</em>&nbsp;</td><td>The third key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>encryption key. </dd></dl>

</div>
</div>
<a class="anchor" id="a820eed66d32aac0dff3130edfe8c2fc5"></a><!-- doxytag: member="mn::CreateKey256" ref="a820eed66d32aac0dff3130edfe8c2fc5" args="(__int64 key1, __int64 key2, __int64 key3, __int64 key4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreateKey256 </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an encryption key of bit strength 256. </p>
<p>The same key must be used to encrypt as is used to decrypt if the decrypted data is to make sense.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key1</em>&nbsp;</td><td>The first key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key2</em>&nbsp;</td><td>The second key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key3</em>&nbsp;</td><td>The third key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key4</em>&nbsp;</td><td>The fourth key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>encryption key. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bd0a3da67665406c73878e2f4ae92b0"></a><!-- doxytag: member="mn::CreatePacket" ref="a3bd0a3da67665406c73878e2f4ae92b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreatePacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new empty packet. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new empty packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a41ac732588a37b91a93fc7783f9d0657"></a><!-- doxytag: member="mn::CreatePacketFromPacket" ref="a41ac732588a37b91a93fc7783f9d0657" args="(__int64 fromPacket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreatePacketFromPacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>fromPacket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new packet, copying the contents of another packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fromPacket</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new packet created based on <em>fromPacket</em>, this packet is identical to <em>fromPacket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="accd76b26c54e28e3ddce1fc4047ae57f"></a><!-- doxytag: member="mn::CreatePacketFromString" ref="accd76b26c54e28e3ddce1fc4047ae57f" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::CreatePacketFromString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new packet, copying the contents of a C string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new packet created based on <em>str</em>, this packet contains <em>str</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a199dd8a98388fbfc77ac02c37a1598c6"></a><!-- doxytag: member="mn::Decrypt" ref="a199dd8a98388fbfc77ac02c37a1598c6" args="(__int64 packet, __int64 key, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Decrypt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrypts the specified packet. </p>
<p>Note that you must not read or write data to the packet while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the command will not return until the packet is fully decrypted. If false the command will return straight away and <a class="el" href="namespacemn.html#a46022e0f42b0e7fb083f200bfc0dabf0" title="Determines whether the last encryption or decryption operation that was started on the specified pack...">mn::GetLastEncryptionOperationFinished</a> should be used to determine when it has finished its operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a49327f5b522c5c0d6d18a84c975cd2aa"></a><!-- doxytag: member="mn::DeleteInstanceProfile" ref="a49327f5b522c5c0d6d18a84c975cd2aa" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::DeleteInstanceProfile </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="acb38ba4db45ea37eb762d9fe22045025"></a><!-- doxytag: member="mn::DeleteKey" ref="acb38ba4db45ea37eb762d9fe22045025" args="(__int64 Key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::DeleteKey </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>Key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the specified encryption key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Key</em>&nbsp;</td><td>The key to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2934b8fb371f044330f7ddb4e7f5c01"></a><!-- doxytag: member="mn::DeletePacket" ref="ad2934b8fb371f044330f7ddb4e7f5c01" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::DeletePacket </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the specified packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c290babcdf8190d0502331f2799c93"></a><!-- doxytag: member="mn::DisconnectClient" ref="ae2c290babcdf8190d0502331f2799c93" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::DisconnectClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects the specified client. </p>
<p>In server state the specified client is dropped and the client ID freed. <br/>
 In other states the instance is deactivated and freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a03e4a7849d9aa386ca0e139367d5c36f"></a><!-- doxytag: member="mn::DNS_A" ref="a03e4a7849d9aa386ca0e139367d5c36f" args="(const char *hostName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; mn::DNS_A </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the IP address of the specified host name. </p>
<p>If <em>str</em> contains an IP address already then the return value will be that IP address unchanged.<br/>
<br/>
</p>
<p>This method is thread safe. The return value will remain valid and unmodified until the next call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostName</em>&nbsp;</td><td>Domain name to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IP address representation of <em>addr</em>. </dd></dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd>an empty <a class="el" href="class_net_address.html" title="Stores a single address with IP and port.">NetAddress</a> structure if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a99d80371f7aecc638eb1ef1f74534794"></a><!-- doxytag: member="mn::DNS_B" ref="a99d80371f7aecc638eb1ef1f74534794" args="(const char *hostName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL const char * mn::DNS_B </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the IP address of the specified host name. </p>
<p>If <em>str</em> contains an IP address already then the return value will be that IP address unchanged.<br/>
<br/>
</p>
<p>This method is thread safe. The return value will remain valid and unmodified until the next call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostName</em>&nbsp;</td><td>Domain name to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IP address representation of <em>addr</em>. </dd></dl>
 <dl class="return"><dt><b>Returns:</b></dt><dd>an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a95028f94c38fb9fd07800bbe66cc824e"></a><!-- doxytag: member="mn::Encrypt" ref="a95028f94c38fb9fd07800bbe66cc824e" args="(__int64 packet, __int64 key, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Encrypt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encrypts the specified packet. </p>
<p>Note that you must not read or write data to the packet while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If true the command will not return until the packet is fully encrypted. If false the command will return straight away and <a class="el" href="namespacemn.html#a46022e0f42b0e7fb083f200bfc0dabf0" title="Determines whether the last encryption or decryption operation that was started on the specified pack...">mn::GetLastEncryptionOperationFinished</a> should be used to determine when it has finished its operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="af0bc7781b53d5d452fa74eca83c50482"></a><!-- doxytag: member="mn::Erase" ref="af0bc7781b53d5d452fa74eca83c50482" args="(__int64 packet, size_t startPos, size_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Erase </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>amount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases part of the packet, decreasing used size and cursor position by the amount erased. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>Position to start erasing data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amount</em>&nbsp;</td><td>Number of bytes to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a99612581b485e5059ba0c1c6e6d4d548"></a><!-- doxytag: member="mn::Finish" ref="a99612581b485e5059ba0c1c6e6d4d548" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Finish </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up an instance, or the entire networking module. </p>
<p>Shuts down the networking module if <em>instanceID</em> is -1. <br/>
 Shuts down the instance of ID <em>instanceID</em> if <em>instanceID</em> is &gt; -1.</p>
<p>If the module or instance is not active then this command will do nothing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>ID of instance to shutdown, or -1 if the entire networking module should be unloaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc2d3891cf1703bf452b5e2aa478f2e"></a><!-- doxytag: member="mn::FlushRecvTCP" ref="a4dc2d3891cf1703bf452b5e2aa478f2e" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::FlushRecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the TCP received packet queue. </p>
<p>When TCP packets are received and a receive function has not been set using mn::SetFunction, packets are put into a queue and received using <a class="el" href="namespacemn.html#adfe8471ae07cd596fe9215a890faac69" title="Retrieves a TCP packet from the TCP received packet queue.">mn::RecvTCP</a>. If the queue gets too big newer packets may not be received for some time and so it can be useful to empty the queue. This command discards everything in the queue.<br/>
<br/>
</p>
<p>Can only be used on an active TCP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e9638697d08de4e65a85864cc4524aa"></a><!-- doxytag: member="mn::FlushRecvUDP" ref="a9e9638697d08de4e65a85864cc4524aa" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::FlushRecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties the UDP received packet queue. </p>
<p>When UDP packets are received and a receive function has not been set using mn::SetFunction, packets are put into a queue and received using <a class="el" href="namespacemn.html#a62627020941d9c6cdd1e3e3d1919c28b" title="Retrieves a UDP packet from the UDP received packet queue.">mn::RecvUDP</a>. If the queue gets too big newer packets may not be received for some time and so it can be useful to empty the queue. This command discards everything in the queue.<br/>
<br/>
</p>
<p>Can only be used on an active UDP instance. Has no impact unless in UDP mode CATCH_ALL or CATCH_ALL_NO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a6155af5ab3e18ae4746b1b9c06ee6509"></a><!-- doxytag: member="mn::GetAge" ref="a6155af5ab3e18ae4746b1b9c06ee6509" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetAge </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the clock value of the specified packet, indicating the packet's age. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. <p>Retrieves <a class="el" href="class_packet.html#af82113a0e0b36819fcbe4b8245db579e" title="Value indicating packet age.">Packet::age</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af599d054cbe64887252f1c6ef73b2bb2"></a><!-- doxytag: member="mn::GetAutoResizeTCP" ref="af599d054cbe64887252f1c6ef73b2bb2" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the TCP buffer size will automatically increase if necessary. </p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb" title="Default value for NetInstanceProfile::autoResizeTCP.">NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if auto resize is enabled; this means that if a packet larger than <a class="el" href="namespacemn.html#a5065424be63fbe66753762e67f4c35e0" title="Retrieves the TCP buffer size.">mn::GetRecvSizeTCP()</a> size is received then the max size will be increased silently. </dd>
<dd>
0 if auto resize is disabled; this means that an exception will be thrown if a packet larger than <a class="el" href="namespacemn.html#a5065424be63fbe66753762e67f4c35e0" title="Retrieves the TCP buffer size.">mn::GetRecvSizeTCP()</a> is received. In server state the client will be silently disconnected and in client state an error will occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a82b01bd653c6ea90546ebb31f0130fdd"></a><!-- doxytag: member="mn::GetByte" ref="a82b01bd653c6ea90546ebb31f0130fdd" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL char mn::GetByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a byte from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="aae8cbaca06592adf7e07e7e8dbb58ff1"></a><!-- doxytag: member="mn::GetBytesTCP" ref="aae8cbaca06592adf7e07e7e8dbb58ff1" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetBytesTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines how much of the packet currently being receives has been received in bytes. </p>
<p>This command can be used only on an active TCP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current size of the TCP partial packet being received i.e. The number of bytes of the packet that have been received. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a999a5af217f64d3c18ee9a94c1f94b4d"></a><!-- doxytag: member="mn::GetClientAddressTCP" ref="a999a5af217f64d3c18ee9a94c1f94b4d" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetClientAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote TCP address of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>remote TCP address of the specified client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae287dc45367896e319d1514aefe3c87f"></a><!-- doxytag: member="mn::GetClientAddressUDP" ref="ae287dc45367896e319d1514aefe3c87f" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetClientAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote UDP address of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>remote UDP address of the specified client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb3498a01e2cccb3b0b29a30cb87eb1"></a><!-- doxytag: member="mn::GetClientFrom" ref="a6bb3498a01e2cccb3b0b29a30cb87eb1" args="(__int64 Packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetClientFrom </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the client ID of the client that received the specified packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>Pointer to packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the client ID of the client that sent us the specified packet. </dd>
<dd>
0 if the specified packet was not received from a client. </dd></dl>

</div>
</div>
<a class="anchor" id="a110e66fb2f7eb5b19466874b11cca947"></a><!-- doxytag: member="mn::GetClientID" ref="a110e66fb2f7eb5b19466874b11cca947" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetClientID </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the client ID that the server has assigned the client. </p>
<p>Can only be used in <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a> state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>ID of client (as allocated by server), filled during the handshaking process. </p>
 </dd>
<dd>
0 if the client is not fully connected to the server. </dd></dl>

</div>
</div>
<a class="anchor" id="a796619854a3fa47f837e1a07dfea315f"></a><!-- doxytag: member="mn::GetClientIPTCP" ref="a796619854a3fa47f837e1a07dfea315f" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetClientIPTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote TCP IP of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remote TCP IP of the specified client. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a43a0cdd23d509a9c04dc266d381bb690"></a><!-- doxytag: member="mn::GetClientIPUDP" ref="a43a0cdd23d509a9c04dc266d381bb690" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetClientIPUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote UDP IP of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remote UDP IP of the specified client. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a793ffb4d1c671e27ff1e1a2c72642c42"></a><!-- doxytag: member="mn::GetClientPortTCP" ref="a793ffb4d1c671e27ff1e1a2c72642c42" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetClientPortTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote TCP port of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remote TCP port of the specified client. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a7965d08132aef367e2c767c845c781"></a><!-- doxytag: member="mn::GetClientPortUDP" ref="a3a7965d08132aef367e2c767c845c781" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetClientPortUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the remote UDP port of a currently connected client. </p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remote UDP port of the specified client. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a539cbc714e7b5a1ea1f19bca9b9b2ba1"></a><!-- doxytag: member="mn::GetConnectAddressTCP" ref="a539cbc714e7b5a1ea1f19bca9b9b2ba1" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetConnectAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the address that the client is connected to via TCP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote address information of the specified client. </dd></dl>

</div>
</div>
<a class="anchor" id="a21d78dd4a2693e3924f71f148319a5bd"></a><!-- doxytag: member="mn::GetConnectAddressUDP" ref="a21d78dd4a2693e3924f71f148319a5bd" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetConnectAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the address that the client is connected to via UDP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote address information of the specified client. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b816e5fdb5c2dad588d1ab66251cce2"></a><!-- doxytag: member="mn::GetConnecting" ref="a0b816e5fdb5c2dad588d1ab66251cce2" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL bool mn::GetConnecting </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the client is in the process of connecting to a server. </p>
<p>Can only be used in <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a> state.</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if connecting, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cbae8de856869fefcf8c36ade5fca5a"></a><!-- doxytag: member="mn::GetConnectIPTCP" ref="a4cbae8de856869fefcf8c36ade5fca5a" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetConnectIPTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the IP address that the client is connected to via TCP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote IP of the specified client. This pointer will remain valid and unmodified until the next call. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b42cb739a01d6c4ec8f368a9f1536e"></a><!-- doxytag: member="mn::GetConnectIPUDP" ref="a27b42cb739a01d6c4ec8f368a9f1536e" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetConnectIPUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the IP address that the client is connected to via UDP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote IP of the specified client. This pointer will remain valid and unmodified until the next call. </dd>
<dd>
an empty string if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a54dcaef89c8ec481ba82d1712d2c49f3"></a><!-- doxytag: member="mn::GetConnectPortTCP" ref="a54dcaef89c8ec481ba82d1712d2c49f3" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetConnectPortTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the port that the client is connected to via TCP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP remote port of the specified client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a34127d93b6b2ee3724a048a4c4a2d3fe"></a><!-- doxytag: member="mn::GetConnectPortUDP" ref="a34127d93b6b2ee3724a048a4c4a2d3fe" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetConnectPortUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the port that the client is connected to via UDP. </p>
<p>Can only be used on instances of type <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP remote port of the specified client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e5f17a4f67ee287b3cb90295c5177d0"></a><!-- doxytag: member="mn::GetCursor" ref="a5e5f17a4f67ee287b3cb90295c5177d0" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetCursor </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the cursor position of the specified packet. </p>
<p>The cursor indicates where Get commands that extract data should begin reading from and where add commands that add data should begin adding data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the cursor position. </dd></dl>

</div>
</div>
<a class="anchor" id="a46a7e0633c22ff33afa589606673e20d"></a><!-- doxytag: member="mn::GetDouble" ref="a46a7e0633c22ff33afa589606673e20d" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL double mn::GetDouble </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a double from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="ac7a3b25259daf42c56da1e677a551e77"></a><!-- doxytag: member="mn::GetEnabledUDP" ref="ac7a3b25259daf42c56da1e677a551e77" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetEnabledUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP is enabled. </p>
<p>This command can be used only on an active UDP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if UDP is enabled. </dd>
<dd>
0 if UDP is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a2549f5831570f5109df5840719b407ae"></a><!-- doxytag: member="mn::GetErrorCode" ref="a2549f5831570f5109df5840719b407ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::GetErrorCode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the error code associated with the error that is saved globally. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the error code. </dd>
<dd>
0 if none is loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ad53407751aa123a13b1480610cbff41f"></a><!-- doxytag: member="mn::GetErrorCommand" ref="ad53407751aa123a13b1480610cbff41f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetErrorCommand </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the command that caused the error that is saved globally. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the command that caused the error. </dd>
<dd>
NULL if none is loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ae78660a00605a9b3839788c92e41bbcc"></a><!-- doxytag: member="mn::GetErrorFile" ref="ae78660a00605a9b3839788c92e41bbcc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetErrorFile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the name of the file that the error that is saved globally occurred in. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the file that the error occurred in. </dd>
<dd>
NULL if none is loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ac37658be31dcd70bd731e59f9731df4e"></a><!-- doxytag: member="mn::GetErrorFlag" ref="ac37658be31dcd70bd731e59f9731df4e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL bool mn::GetErrorFlag </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if an error is saved globally. </p>
<p>Errors are only saved globally when <a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683a8ab8b12d7e1c3dcc392f15390ca1bb92">ErrorReport::EM_SAVE</a> is enabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an error is saved, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fbd35964159f82775dd96022c16cad7"></a><!-- doxytag: member="mn::GetErrorFull" ref="a4fbd35964159f82775dd96022c16cad7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetErrorFull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an error message based on the global error report. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error message. When done with this string you should deallocate it using delete[]. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ed53c036e816ff140be2084f6c7912e"></a><!-- doxytag: member="mn::GetErrorLine" ref="a7ed53c036e816ff140be2084f6c7912e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned __int64 mn::GetErrorLine </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the line number at which the error that is saved globally occurred. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the line number at which the error occurred. </dd>
<dd>
0 if none is loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a62c409059881908699a72a3722eacfbe"></a><!-- doxytag: member="mn::GetErrorMode" ref="a62c409059881908699a72a3722eacfbe" args="(int errorMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetErrorMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errorMode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether an error mode is enabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to check. See <a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683" title="Error mode describes how errors should be dealt with.">ErrorReport::ErrorMode</a> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the error mode is enabled, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a282e7ed695df1c16ee6abad63175bf1d"></a><!-- doxytag: member="mn::GetErrorMode" ref="a282e7ed695df1c16ee6abad63175bf1d" args="(ErrorReport::ErrorMode errorMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a>&nbsp;</td>
          <td class="paramname"> <em>errorMode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether an error mode is enabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the error mode is enabled, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a6d7eb9d9bf8b6013de4497c410c824"></a><!-- doxytag: member="mn::GetErrorOperation" ref="a0a6d7eb9d9bf8b6013de4497c410c824" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetErrorOperation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the operation that was being performed when the error that is saved globally occurred. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the operation that was being performed when the error occurred. </dd>
<dd>
NULL if none is loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7ab9d44114450fd851d6ce89f174d0"></a><!-- doxytag: member="mn::GetFloat" ref="a9e7ab9d44114450fd851d6ce89f174d0" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL float mn::GetFloat </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a float from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a9d06820302a364d7a75c5442268de3b8"></a><!-- doxytag: member="mn::GetGracefulDisconnectEnabledTCP" ref="a9d06820302a364d7a75c5442268de3b8" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetGracefulDisconnectEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the graceful disconnect process is enabled. </p>
<p>For more information see the <a class="el" href="graceful_disconnect_page.html">graceful disconnection page</a>.<br/>
<br/>
</p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is enabled. </dd>
<dd>
0 if <a class="el" href="graceful_disconnect_page.html">graceful disconnection</a> is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a42c695fef33766c040ec92ee2101c4d2"></a><!-- doxytag: member="mn::GetHandshakeEnabledTCP" ref="a42c695fef33766c040ec92ee2101c4d2" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetHandshakeEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the handshaking process is enabled. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the <a class="el" href="handshake_page.html">handshake process</a> is enabled. </dd>
<dd>
0 if the <a class="el" href="handshake_page.html">handshake process</a> is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a50d1939a356ab07a100762ef29ab6748"></a><!-- doxytag: member="mn::GetHostName" ref="a50d1939a356ab07a100762ef29ab6748" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetHostName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the name of the computer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the computer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a66f2cfec02b7b48d162c614fc1c75"></a><!-- doxytag: member="mn::GetInstance" ref="ae9a66f2cfec02b7b48d162c614fc1c75" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetInstance </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the instance ID of the specified packet, indicating the ID of the instance that the packet was received on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. <p>Retrieves <a class="el" href="class_packet.html#afce0ae0cb900f81df3cb1aaa2d197495" title="ID of instance that packet was received on.">Packet::instance</a>. </p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af529e8b437a2d3c8d782da1ab47dbe77"></a><!-- doxytag: member="mn::GetInt" ref="af529e8b437a2d3c8d782da1ab47dbe77" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a46022e0f42b0e7fb083f200bfc0dabf0"></a><!-- doxytag: member="mn::GetLastEncryptionOperationFinished" ref="a46022e0f42b0e7fb083f200bfc0dabf0" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetLastEncryptionOperationFinished </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the last encryption or decryption operation that was started on the specified packet has finished. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the operation has finished. </dd>
<dd>
0 if the operation is still in progress. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a9607086d552b4334905d2db5c1256cce"></a><!-- doxytag: member="mn::GetLocalAddressTCP" ref="a9607086d552b4334905d2db5c1256cce" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetLocalAddressTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP address of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP address of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a3079e11eb9cbd6f70b8d9c756f33b01b"></a><!-- doxytag: member="mn::GetLocalAddressUDP" ref="a3079e11eb9cbd6f70b8d9c756f33b01b" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetLocalAddressUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP address of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP address of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a629161ab269f8c863a3177abba2a3055"></a><!-- doxytag: member="mn::GetLocalInterface" ref="a629161ab269f8c863a3177abba2a3055" args="(size_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_net_address.html">NetAddress</a> &amp; mn::GetLocalInterface </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a local interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>ID of interface, interface IDs range from 0 inclusive to number of local interfaces exclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>local interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a06a84484274b0f3184c226b5e70496ef"></a><!-- doxytag: member="mn::GetLocalInterfaceAmount" ref="a06a84484274b0f3184c226b5e70496ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetLocalInterfaceAmount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of local interfaces available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of local interfaces available, interface IDs range from 0 inclusive to number of local interfaces exclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a6344a20d5c370b8956113db7e1b2e6d4"></a><!-- doxytag: member="mn::GetLocalInterfaceStr" ref="a6344a20d5c370b8956113db7e1b2e6d4" args="(size_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetLocalInterfaceStr </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a local interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>ID of interface, interface IDs range from 0 inclusive to number of local interfaces exclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>local interface. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a77eed9348dab0a1ee0f9d882687ac6bc"></a><!-- doxytag: member="mn::GetLocalIPTCP" ref="a77eed9348dab0a1ee0f9d882687ac6bc" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetLocalIPTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP IP of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP IP of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a561d26c7aad0f25d9a627eea6c62e714"></a><!-- doxytag: member="mn::GetLocalIPUDP" ref="a561d26c7aad0f25d9a627eea6c62e714" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetLocalIPUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP IP of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP IP of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e66800abe59f00297e397ea4cf7bb0"></a><!-- doxytag: member="mn::GetLocalPortTCP" ref="a44e66800abe59f00297e397ea4cf7bb0" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetLocalPortTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP port of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP port of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a8172bc9d62d2d54dae57340a052c1575"></a><!-- doxytag: member="mn::GetLocalPortUDP" ref="a8172bc9d62d2d54dae57340a052c1575" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetLocalPortUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP port of the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP port of the specified instance. </dd></dl>

</div>
</div>
<a class="anchor" id="acaad9f6d77fe2ebd20db513978949fc7"></a><!-- doxytag: member="mn::GetLogicalCPU" ref="acaad9f6d77fe2ebd20db513978949fc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetLogicalCPU </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of logical cores on the system. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of logical cores on the system. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1faf5fdf08a9c5fee7e3507d1ec6df"></a><!-- doxytag: member="mn::GetLongDouble" ref="a2a1faf5fdf08a9c5fee7e3507d1ec6df" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL long double mn::GetLongDouble </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a long double from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="ab9270e6721c7a7f3753d069e9c99f679"></a><!-- doxytag: member="mn::GetLongInt" ref="ab9270e6721c7a7f3753d069e9c99f679" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL long int mn::GetLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a long integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a88b9312e83b83b46465a7b1f69e6451d"></a><!-- doxytag: member="mn::GetLongLongInt" ref="a88b9312e83b83b46465a7b1f69e6451d" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL long long int mn::GetLongLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a long long integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a74def948c7f024a65f2d645450378ab3"></a><!-- doxytag: member="mn::GetMaxClients" ref="a74def948c7f024a65f2d645450378ab3" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetMaxClients </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the maximum number of clients that can be connected to the server at any one time. </p>
<p>This command can be used only on an active server or client instance. <br/>
<br/>
</p>
<p>Client IDs range from 1 inclusive to this value inclusive, client ID 0 can be used to identify the server, as it will not be assigned to any client.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>in server state: The maximum number of clients that can be connected to the server at any one time. </dd>
<dd>
in client state: The maximum number of clients that can be connected to the server at any one time that the client is connected to. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aa67e3ecf996a52772f41a221cec84579"></a><!-- doxytag: member="mn::GetMaxOperations" ref="aa67e3ecf996a52772f41a221cec84579" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetMaxOperations </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of UDP operation IDs available. </p>
<p>This command can be used only on an active UDP instance.<br/>
<br/>
</p>
<p>In client state this value is retrieved from the server during the handshaking process.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a23a92f33275c72e9f999e80a9acfe8e3" title="Default value for NetInstanceProfile::numOperations.">NetInstanceProfile::DEFAULT_NUM_OPERATIONS</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of UDP operation IDs available. Operation IDs range from 0 inclusive to number of operations exclusive. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3e77a7a0d7ce4a2f1b33ab61ac268e5"></a><!-- doxytag: member="mn::GetMemorySize" ref="ad3e77a7a0d7ce4a2f1b33ab61ac268e5" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetMemorySize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the memory size of the packet. </p>
<p>The memory size determines how much data can be stored in the packet. Although the packet automatically increases in memory size as data is added, it is best to set the memory size initially to avoid unnecessary reallocation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the memory size of the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f8b463f4a6a05a984fde1e5aea119e7"></a><!-- doxytag: member="mn::GetModeTCP" ref="a7f8b463f4a6a05a984fde1e5aea119e7" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetModeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP mode in use. </p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964" title="Describes the protocol mode in use.">NetMode::ProtocolMode</a> value indicating the TCP mode in use. Note that the return value will only be a TCP mode, not any other mode type. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d1f3ad5255ffc87da23a5fdbe965736"></a><!-- doxytag: member="mn::GetModeUDP" ref="a2d1f3ad5255ffc87da23a5fdbe965736" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetModeUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP mode in use. </p>
<p>This command can be used only on an active UDP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964" title="Describes the protocol mode in use.">NetMode::ProtocolMode</a> value indicating the UDP mode in use. Note that the return value will only be a UDP mode, not any other mode type. </dd></dl>

</div>
</div>
<a class="anchor" id="aedb6bc9412d06ec6d088175141793497"></a><!-- doxytag: member="mn::GetNagleEnabledTCP" ref="aedb6bc9412d06ec6d088175141793497" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the nagle algorithm is enabled. </p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the nagle algorithm is enabled. </dd>
<dd>
0 if the nagle algorithm is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a3132d0d328f9bbdd4fccbd36fc6dff3d"></a><!-- doxytag: member="mn::GetNumInstances" ref="a3132d0d328f9bbdd4fccbd36fc6dff3d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetNumInstances </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of instances available (including inactive ones). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of instances available, included in this number are both inactive and active instances. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9394252d9c10089e465248ff97a0b17"></a><!-- doxytag: member="mn::GetOperation" ref="ac9394252d9c10089e465248ff97a0b17" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetOperation </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the operation ID of the specified packet, indicating what operation the packet was received on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>operation that packet was received via. This is set when receiving in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ef3d1df4730cc5bf008979274154b99"></a><!-- doxytag: member="mn::GetPacketRemainder" ref="a0ef3d1df4730cc5bf008979274154b99" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetPacketRemainder </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the number of unread bytes in the specified packet. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of unread bytes in the specified packet. The calculation used is <a class="el" href="namespacemn.html#aea5a6460be64a0d83240fd2c234cd4ed" title="Retrieves the used size of the packet.">mn::GetUsedSize()</a> - <a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7413d0cbb69dc342c868d68395143dd8"></a><!-- doxytag: member="mn::GetPercentTCP" ref="a7413d0cbb69dc342c868d68395143dd8" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL double mn::GetPercentTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines how much of the packet currently being receives has been received as a percentage. </p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the percentage of the partial packet that has been received i.e. Between 0 and 100 where 50 indicates that half the packet has been received and we are now waiting for the second half to be received. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a045102b8bf3bad5643f32b747f63b3ca"></a><!-- doxytag: member="mn::GetPostfixTCP" ref="a045102b8bf3bad5643f32b747f63b3ca" args="(size_t instanceID, __int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetPostfixTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP postfix in use. </p>
<p>This command copies the TCP postfix of the specified instance into <em>packet</em>.<br/>
<br/>
</p>
<p>This command can be used only on an active TCP instance in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> TCP mode.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that postfix should be copied into, overwriting any existing data in the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fbec55bb4f503c2afdd1aa48cbd141e"></a><!-- doxytag: member="mn::GetPostfixTCP" ref="a7fbec55bb4f503c2afdd1aa48cbd141e" args="(size_t instanceID, Packet &amp;packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetPostfixTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP postfix in use. </p>
<p>This command copies the TCP postfix of the specified instance into <em>packet</em>.<br/>
<br/>
</p>
<p>This command can be used only on an active TCP instance in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> TCP mode.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> that postfix should be copied into, overwriting any existing data in the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a7d5b31e606b2fad59d6c92e8f896af47"></a><!-- doxytag: member="mn::GetProfileAutoResizeTCP" ref="a7d5b31e606b2fad59d6c92e8f896af47" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the auto resize TCP option is enabled. </p>
<p>When auto resize is true, if an incoming TCP packet is too large to be received, instead of throwing an error or forcefully disconnecting that client, the. TCP receive buffer automatically resizes to allow for the TCP packet to be received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if auto resize is enabled. </dd>
<dd>
0 if auto resize is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ac03adfd09e27f61434b7a596ac09ac04"></a><!-- doxytag: member="mn::GetProfileAutoResizeTCP" ref="ac03adfd09e27f61434b7a596ac09ac04" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetProfileAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the auto resize TCP option is enabled. </p>
<p>When auto resize is true, if an incoming TCP packet is too large to be received, instead of throwing an error or forcefully disconnecting that client, the. TCP receive buffer automatically resizes to allow for the TCP packet to be received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if auto resize is enabled. </dd>
<dd>
0 if auto resize is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a638da78b6da3fa2b3f1e9c89ad20233b"></a><!-- doxytag: member="mn::GetProfileBufferSizeTCP" ref="a638da78b6da3fa2b3f1e9c89ad20233b" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileBufferSizeTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP receive buffer size set for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum size a received TCP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </dd>
<dd>
0 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a48fb0065708925bdfbaf6417fb8cf5ba"></a><!-- doxytag: member="mn::GetProfileBufferSizeTCP" ref="a48fb0065708925bdfbaf6417fb8cf5ba" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileBufferSizeTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP receive buffer size set for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum size a received TCP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abd94f490a1309bd014054ccec0a0ec37"></a><!-- doxytag: member="mn::GetProfileBufferSizeUDP" ref="abd94f490a1309bd014054ccec0a0ec37" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileBufferSizeUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP receive buffer size set for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum size a received UDP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a544aa1d33e22e88c562cca5c0024ab1f"></a><!-- doxytag: member="mn::GetProfileBufferSizeUDP" ref="a544aa1d33e22e88c562cca5c0024ab1f" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileBufferSizeUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP receive buffer size set for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum size a received UDP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </dd>
<dd>
0 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="afd73e16d7b1f93fe61ea1779350aca18"></a><!-- doxytag: member="mn::GetProfileDecryptKeyLoadedUDP" ref="afd73e16d7b1f93fe61ea1779350aca18" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileDecryptKeyLoadedUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether a decryption key has been set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if decrypt key UDP is loaded. </dd>
<dd>
0 if decrypt key is not loaded. This is the default. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a479f9bfb83337581115f69cac70ba8bd"></a><!-- doxytag: member="mn::GetProfileDecryptKeyUDP" ref="a479f9bfb83337581115f69cac70ba8bd" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL __int64 mn::GetProfileDecryptKeyUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the encryption key used to decrypt incoming UDP packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>encryption key. Note that the key is not necessarily used by. UDP instances, only if the mode in use specifically specifies in its documentation will the key ever be used. </dd></dl>

</div>
</div>
<a class="anchor" id="a395289f6266e2ee08091c3099b235302"></a><!-- doxytag: member="mn::GetProfileEnabledUDP" ref="a395289f6266e2ee08091c3099b235302" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileEnabledUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP is enabled for the specified instance profile. </p>
<p>Determines whether UDP is enabled for the specified instance profile. </p>
 
</div>
</div>
<a class="anchor" id="a1e4a81f4292c441f96a3c4570ad478f4"></a><!-- doxytag: member="mn::GetProfileEnabledUDP" ref="a1e4a81f4292c441f96a3c4570ad478f4" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetProfileEnabledUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP is enabled for the specified instance profile. </p>
<p>When UDP is disabled all UDP commands on the specified instance will fail. The handshaking process will be slightly faster and compatibility with other applications will improve.<br/>
<br/>
</p>
<p>Default return value is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if UDP will be enabled. </dd>
<dd>
0 if UDP will be disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2ee4d9e630c70d78f6e1b88aae40f08"></a><!-- doxytag: member="mn::GetProfileFunctionTCP" ref="ac2ee4d9e630c70d78f6e1b88aae40f08" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> mn::GetProfileFunctionTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP function set for the specified instance profile. </p>
<p>This TCP function is called whenever data is received on the instance. Care must be taken that the function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a> for more information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to function that can be executed when TCP data is received (NULL or 0 if none, default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="a4a14f8b971fbcb6bf71d8b0b68a3b31c"></a><!-- doxytag: member="mn::GetProfileFunctionUDP" ref="a4a14f8b971fbcb6bf71d8b0b68a3b31c" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_socket.html#a52b5f4de8d0a47fd8620f542b21c076c">NetSocket::RecvFunc</a> mn::GetProfileFunctionUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP function set for the specified instance profile. </p>
<p>This UDP function is called whenever data is received on the instance. Care must be taken that the function is thread safe. See <a class="el" href="multithreading_page.html">multithreaded usage</a> for more information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to function that can be executed when UDP data is received (NULL or 0 if none, default is <a class="el" href="class_net_instance_profile.html#a51f05ca66c76fdc588d34455d5185f6b" title="Default value for NetInstanceProfile::tcpRecvFunc and NetInstanceProfile::udpRecvFunc.">NetInstanceProfile::DEFAULT_RECV_FUNC</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="af44ffb1aa298412b6f62ab90ea11cfd8"></a><!-- doxytag: member="mn::GetProfileGracefulDisconnectEnabled" ref="af44ffb1aa298412b6f62ab90ea11cfd8" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile. </p>
<p>Default return value is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if graceful disconnect process will be enabled. </dd>
<dd>
0 if graceful disconnect process will be disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a954a7dd680e686b203ff77a77dd5ab91"></a><!-- doxytag: member="mn::GetProfileGracefulDisconnectEnabled" ref="a954a7dd680e686b203ff77a77dd5ab91" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetProfileGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile. </p>
<p>Default return value is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if graceful disconnect process will be enabled. </dd>
<dd>
0 if graceful disconnect process will be disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c8fbfebb44500e7957b551adec86059"></a><!-- doxytag: member="mn::GetProfileHandshakeEnabled" ref="a4c8fbfebb44500e7957b551adec86059" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileHandshakeEnabled </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the TCP handshake process is enabled for the specified instance profile. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Default return value is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the handshake process should be enabled. </dd>
<dd>
0 if the handshake process should be disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ab3988fac0c174c504420effad77d4060"></a><!-- doxytag: member="mn::GetProfileHandshakeEnabled" ref="ab3988fac0c174c504420effad77d4060" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetProfileHandshakeEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the TCP handshake process is enabled for the specified instance profile. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.<br/>
<br/>
</p>
<p>Default return value is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the handshake process should be enabled. </dd>
<dd>
0 if the handshake process should be disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8a6606bc8aef43bd3ca74772ee7118d"></a><!-- doxytag: member="mn::GetProfileLocalAddressTCP" ref="ae8a6606bc8aef43bd3ca74772ee7118d" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetProfileLocalAddressTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP address stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP address currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba287b3bb8e2f01357028db198d0249"></a><!-- doxytag: member="mn::GetProfileLocalAddressUDP" ref="a4ba287b3bb8e2f01357028db198d0249" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_address.html">NetAddress</a> mn::GetProfileLocalAddressUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP address stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP address currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="a523d1b974c9785f00f2e7f5b26c5c2c2"></a><!-- doxytag: member="mn::GetProfileLocalIPTCP" ref="a523d1b974c9785f00f2e7f5b26c5c2c2" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetProfileLocalIPTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP IP address stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP IP currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="aacce68da4e111d9e4633612660ed4b07"></a><!-- doxytag: member="mn::GetProfileLocalIPUDP" ref="aacce68da4e111d9e4633612660ed4b07" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL const char * mn::GetProfileLocalIPUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP IP address stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP IP currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="a689199a271d286090871df67a789b6df"></a><!-- doxytag: member="mn::GetProfileLocalPortTCP" ref="a689199a271d286090871df67a789b6df" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetProfileLocalPortTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local TCP port stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local TCP port currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="a465182dbc176f30ec2e46a0a700a69ea"></a><!-- doxytag: member="mn::GetProfileLocalPortUDP" ref="a465182dbc176f30ec2e46a0a700a69ea" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short mn::GetProfileLocalPortUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the local UDP port stored in the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the local UDP port currently loaded into the specified profile. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d39472596d65f39e019a1ca459c17c6"></a><!-- doxytag: member="mn::GetProfileModeTCP" ref="a9d39472596d65f39e019a1ca459c17c6" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetProfileModeTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP mode for the specified instance profile. </p>
<p>The TCP mode describes changes should be made to TCP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b7066e85fc1d4c14209a60e2c86bb13"></a><!-- doxytag: member="mn::GetProfileModeTCP" ref="a9b7066e85fc1d4c14209a60e2c86bb13" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetProfileModeTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP mode for the specified instance profile. </p>
<p>Retrieves the TCP mode for the specified instance profile. </p>
<p>The TCP mode describes changes should be made to TCP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TCP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>. </dd></dl>
 
</div>
</div>
<a class="anchor" id="adc65c37445c956f898dd99bf12ed83a4"></a><!-- doxytag: member="mn::GetProfileModeUDP" ref="adc65c37445c956f898dd99bf12ed83a4" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetProfileModeUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP mode for the specified instance profile. </p>
<p>Retrieves the UDP mode for the specified instance profile. </p>
<p>The UDP mode describes changes should be made to UDP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP mode option. Default is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a7487a6626a20e589983d4b513f965343"></a><!-- doxytag: member="mn::GetProfileModeUDP" ref="a7487a6626a20e589983d4b513f965343" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a> mn::GetProfileModeUDP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the UDP mode for the specified instance profile. </p>
<p>The UDP mode describes changes should be made to UDP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UDP mode option. Default is <a class="el" href="class_net_instance_profile.html#a247c5f6aeb339edcb8f01a66a592bf3c" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_MODE_UDP</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a391ffe530a30a3016f8d11e6a3d0068d"></a><!-- doxytag: member="mn::GetProfileNagleEnabledTCP" ref="a391ffe530a30a3016f8d11e6a3d0068d" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::GetProfileNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the nagle algorithm option from the specified instance profile. </p>
<p>The default return value for this command is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the nagle algorithm is enabled. </dd>
<dd>
0 if the nagle algorithm is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a367cd31a98fa72fd8a15d45ccc4376ce"></a><!-- doxytag: member="mn::GetProfileNagleEnabledTCP" ref="a367cd31a98fa72fd8a15d45ccc4376ce" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the nagle algorithm option from the specified instance profile. </p>
<p>The default return value for this command is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the nagle algorithm is enabled. </dd>
<dd>
0 if the nagle algorithm is disabled. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ada5cdd9d36f80d959853aa4fdd3e34d3"></a><!-- doxytag: member="mn::GetProfileNumOperationsUDP" ref="ada5cdd9d36f80d959853aa4fdd3e34d3" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetProfileNumOperationsUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of UDP operations set. </dd></dl>

</div>
</div>
<a class="anchor" id="a87cddb55f8b9e37e079da963fcb3ffc2"></a><!-- doxytag: member="mn::GetProfilePostfixTCP" ref="a87cddb55f8b9e37e079da963fcb3ffc2" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> mn::GetProfilePostfixTCP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the postfix option of the specified instance profile. </p>
<p>This option only apples to Instances in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>postfix, default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a75ec773a0f4496d15438bdc9b87b7836"></a><!-- doxytag: member="mn::GetProfilePostfixTCP" ref="a75ec773a0f4496d15438bdc9b87b7836" args="(__int64 profile, __int64 destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfilePostfixTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the postfix option of the specified instance profile. This option only apples to instances in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>Destination packet to store postfix, any existing contents will be overwritten. Default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aaba1cc458821e0784f123aaf44daf8e9"></a><!-- doxytag: member="mn::GetProfileReusableUDP" ref="aaba1cc458821e0784f123aaf44daf8e9" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::GetProfileReusableUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether UDP should be reusable. If reusable other applications, instances and sockets can bind to the same UDP address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if UDP is set to reusable. </dd>
<dd>
0 if UDP is not set to reusable. This is default. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b32e26ca40b7d1e7318bc3d4d9a29bc"></a><!-- doxytag: member="mn::GetProfileSendTimeout" ref="a8b32e26ca40b7d1e7318bc3d4d9a29bc" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetProfileSendTimeout </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the send timeout option for the specified instance profile. Send operations are allowed this length of time to complete before the entity that initiated them is forcefully disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of time in milliseconds to wait for a send operation to complete before disconnecting client (default = <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>). </dd></dl>
 
</div>
</div>
<a class="anchor" id="a6cbfb2045db8a67cf6d02b372512018b"></a><!-- doxytag: member="mn::GetProfileSendTimeout" ref="a6cbfb2045db8a67cf6d02b372512018b" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileSendTimeout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the send timeout option for the specified instance profile. Send operations are allowed this length of time to complete before the entity that initiated them is forcefully disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of time in milliseconds to wait for a send operation to complete before disconnecting client (default = <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="a56025854b599712a4787d1e5cd8ce502"></a><!-- doxytag: member="mn::GetProfileServerTimeout" ref="a56025854b599712a4787d1e5cd8ce502" args="(const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::GetProfileServerTimeout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed this amount of time to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a1466e9a3ae29a949efe1ce5acdd4ad5f"></a><!-- doxytag: member="mn::GetProfileServerTimeout" ref="a1466e9a3ae29a949efe1ce5acdd4ad5f" args="(__int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetProfileServerTimeout </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed this amount of time to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected. </dd>
<dd>
0 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a5065424be63fbe66753762e67f4c35e0"></a><!-- doxytag: member="mn::GetRecvSizeTCP" ref="a5065424be63fbe66753762e67f4c35e0" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetRecvSizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the TCP buffer size. </p>
<p>This command can be used only on an active TCP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the TCP receive buffer. TCP packets larger than this cannot be received unless the auto resize option is true. If the packet cannot be received then an error may occur (this happens in client state) or the problem will be silently dealt with (this happens in server state). </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2ad2574ea8e6b8d63111443be1b1bd1"></a><!-- doxytag: member="mn::GetRecvSizeUDP" ref="aa2ad2574ea8e6b8d63111443be1b1bd1" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetRecvSizeUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the size of the UDP receive buffer. </p>
<p>This command can be used only on an active UDP instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the UDP receive buffer, UDP packets larger than this size cannot be received. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a17dff75b4f61b5e954752b6f64b0cd64"></a><!-- doxytag: member="mn::GetSendTimeout" ref="a17dff75b4f61b5e954752b6f64b0cd64" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned int mn::GetSendTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the length of time that send operations are allowed to take before the entity that initiated them is disconnected forcefully. </p>
<p>This command can be used only on an active instance.<br/>
<br/>
</p>
<p>The default value for this option is <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of time in milliseconds to wait for a send operation to complete before disconnecting client. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a90e71b91823a065bb587a82939edf97d"></a><!-- doxytag: member="mn::GetServerTimeout" ref="a90e71b91823a065bb587a82939edf97d" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetServerTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed this amount of time to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.</p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a39671a53d16a304d993465efd819a57d"></a><!-- doxytag: member="mn::GetShortInt" ref="a39671a53d16a304d993465efd819a57d" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL short int mn::GetShortInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a short integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="aff4353e5aa9c8fce36fe9a88e6f9b82b"></a><!-- doxytag: member="mn::GetSignedByte" ref="aff4353e5aa9c8fce36fe9a88e6f9b82b" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL signed char mn::GetSignedByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a signed byte from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="aca38e8b5229e1e4d13a0d904685c5af8"></a><!-- doxytag: member="mn::GetSizeT" ref="aca38e8b5229e1e4d13a0d904685c5af8" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetSizeT </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned long long integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a8925f1bd923a24ad5f9576f02305c61e"></a><!-- doxytag: member="mn::GetState" ref="a8925f1bd923a24ad5f9576f02305c61e" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdc">NetInstance::Type</a> mn::GetState </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the state that the instance is in. </p>
<p>This command can be used only on an active instance.<br/>
<br/>
</p>
<p>This command is used to determine what type of instance is loaded at an instance ID.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdc" title="Possible instance types.">NetInstance::Type</a> value, indicating the type of instance loaded at ID <em>instanceID</em>. </dd>
<dd>
<a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca88c09e9cfed79e86db169ca2b8ea5457">NetInstance::INACTIVE</a> if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2db35a7c9ec4e2e1fc7abe98749c130"></a><!-- doxytag: member="mn::GetStoreAmountTCP" ref="ae2db35a7c9ec4e2e1fc7abe98749c130" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetStoreAmountTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of packets stored in the TCP received packet queue. </p>
<p>This command can be used only on an active TCP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in the TCP packet store. </dd>
<dd>
if a TCP receive function has been set using mn::SetFunction, this method will always return 0 because the queue system is not in use. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d54cf87355792acd2b5b9d2ffb4120b"></a><!-- doxytag: member="mn::GetStoreAmountUDP" ref="a8d54cf87355792acd2b5b9d2ffb4120b" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetStoreAmountUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of packets stored in the UDP received packet queue. </p>
<p>This command can be used only on an active UDP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of packets in the UDP packet store. </dd>
<dd>
if a UDP receive function has been set using mn::SetFunction, this method will always return 0 because the queue system is not in use. </dd>
<dd>
0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a68b28730fe0c294b9c9e7594617b5c7b"></a><!-- doxytag: member="mn::GetStringC" ref="a68b28730fe0c294b9c9e7594617b5c7b" args="(__int64 packet, size_t length, bool nullTerminated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL char * mn::GetStringC </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>nullTerminated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a C string from the specified packet, allocating new memory to that string. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>If 0 it is assumed that <em>packet</em> has a prefix indicating the size of the remaining data in the packet. This prefix is add by <a class="el" href="namespacemn.html#af0362f4b04ef52ae68a71e64a102e898" title="Adds a C string to the specified packet.">mn::AddStringC</a> when prefix is set to true. If &gt;0 then this is the number of bytes that will be read from the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nullTerminated</em>&nbsp;</td><td>If true a null terminator is appended to the returned string. Note that <a class="el" href="namespacemn.html#af0362f4b04ef52ae68a71e64a102e898" title="Adds a C string to the specified packet.">mn::AddStringC</a> does not ever add a null terminator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49b801f3e32ae023a557d277e76812d2"></a><!-- doxytag: member="mn::GetStringC_B" ref="a49b801f3e32ae023a557d277e76812d2" args="(__int64 packet, char *dest, size_t length, bool nullTerminated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL int mn::GetStringC_B </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>nullTerminated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a C string from the specified packet, copying into previously allocated memory. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>String to copy extracted data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>If 0 it is assumed that <em>packet</em> has a prefix indicating the size of the remaining data in the packet. This prefix is add by <a class="el" href="namespacemn.html#af0362f4b04ef52ae68a71e64a102e898" title="Adds a C string to the specified packet.">mn::AddStringC</a> when prefix is set to true. If &gt;0 then this is the number of bytes that will be read from the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nullTerminated</em>&nbsp;</td><td>If true a null terminator is appended to the returned string. Note that <a class="el" href="namespacemn.html#af0362f4b04ef52ae68a71e64a102e898" title="Adds a C string to the specified packet.">mn::AddStringC</a> does not ever add a null terminator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c5e3fe22cb5b8d539321dd2060edf35"></a><!-- doxytag: member="mn::GetStringSize" ref="a2c5e3fe22cb5b8d539321dd2060edf35" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetStringSize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the size of a string by reading its prefix. </p>
<p>The string must have a prefix or this command will return meaningless values.<br/>
<br/>
</p>
<p>The prefix is read from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is not changed by this command; this means that you can use this command and straight away use <a class="el" href="namespacemn.html#a68b28730fe0c294b9c9e7594617b5c7b" title="Retrieves a C string from the specified packet, allocating new memory to that string.">mn::GetStringC()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a05bbe5425db98835e70e03845d3ae3f2"></a><!-- doxytag: member="mn::GetThreads" ref="a05bbe5425db98835e70e03845d3ae3f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of completion port threads in operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of completion port threads in operation. </dd></dl>

</div>
</div>
<a class="anchor" id="acf8fbb993d19953809ddea61666e9798"></a><!-- doxytag: member="mn::GetUnsignedByte" ref="acf8fbb993d19953809ddea61666e9798" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned char mn::GetUnsignedByte </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned byte from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="note"><dt><b>Note:</b></dt><dd>RC table ensures <a class="el" href="namespacemn.html#a82b01bd653c6ea90546ebb31f0130fdd" title="Retrieves a byte from the specified packet.">mn::GetByte</a> = <a class="el" href="namespacemn.html#acf8fbb993d19953809ddea61666e9798" title="Retrieves an unsigned byte from the specified packet.">mn::GetUnsignedByte</a> in DarkBASIC Pro. </dd></dl>

</div>
</div>
<a class="anchor" id="a6431cbaca9a7e390377b112050ccd688"></a><!-- doxytag: member="mn::GetUnsignedInt" ref="a6431cbaca9a7e390377b112050ccd688" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned int mn::GetUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46d1c79f605b4dcb321d1618415b065a"></a><!-- doxytag: member="mn::GetUnsignedLongInt" ref="a46d1c79f605b4dcb321d1618415b065a" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL unsigned long int mn::GetUnsignedLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned long integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="aa24b3cfab35ce088892686c676fd4463"></a><!-- doxytag: member="mn::GetUnsignedLongLongInt" ref="aa24b3cfab35ce088892686c676fd4463" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPP_DLL unsigned long long int mn::GetUnsignedLongLongInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned long long integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="a3d09a445de8ecd6241d758b218426cd5"></a><!-- doxytag: member="mn::GetUnsignedShortInt" ref="a3d09a445de8ecd6241d758b218426cd5" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL unsigned short int mn::GetUnsignedShortInt </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an unsigned short integer from the specified packet. </p>
<p>Data is retrieved from the packet's data buffer starting at the cursor position (<a class="el" href="namespacemn.html#a5e5f17a4f67ee287b3cb90295c5177d0" title="Retrieves the cursor position of the specified packet.">mn::GetCursor</a>). The cursor position is moved along by the amount of data extracted. Used size and memory size are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to extract data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>extracted data. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If retrieving data would cause the cursor position to be more than the used size. </td></tr>
  </table>
  </dd>
</dl>
 
</div>
</div>
<a class="anchor" id="aea5a6460be64a0d83240fd2c234cd4ed"></a><!-- doxytag: member="mn::GetUsedSize" ref="aea5a6460be64a0d83240fd2c234cd4ed" args="(__int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::GetUsedSize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the used size of the packet. </p>
<p>The used size indicates how much of the memory size is in use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the used size. </dd></dl>

</div>
</div>
<a class="anchor" id="a33f31fabf86b8a77c70215819b77f7fc"></a><!-- doxytag: member="mn::GetVersion" ref="a33f31fabf86b8a77c70215819b77f7fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mn::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a string containing version information for this API. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p>The version that this project is currently at. </p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a30c227a71645e05ea87051ce801152d6"></a><!-- doxytag: member="mn::Insert" ref="a30c227a71645e05ea87051ce801152d6" args="(__int64 packet, size_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Insert </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>amount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an empty space in the packet at the cursor position, increasing used size by the amount inserted. </p>
<p>Cursor position is not changed, which means that data can be written to the empty space straight away without worrying about the cursor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amount</em>&nbsp;</td><td>Number of bytes to insert at cursor position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f6e329576ac7a8c036f2040bd6314a3"></a><!-- doxytag: member="mn::PollConnect" ref="a3f6e329576ac7a8c036f2040bd6314a3" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL <a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6d">NetUtility::ConnectionStatus</a> mn::PollConnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the status of the <a class="el" href="handshake_page.html">handshaking process</a>. </p>
<p>Can only be used in <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a> state.</p>
<p>This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da86caa623f8ffc60da40df3c2ab17532c">NetUtility::STILL_CONNECTING</a> if the handshaking process is in progress still. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da9c07ac24fb9bdd4157ace978968721fd">NetUtility::CONNECTED</a> if the handshaking process completed successfully and the client is now fully connected. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da319e02f6059b4b08edd70c16fa5206fd">NetUtility::TIMED_OUT</a> if the handshaking process timed out. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6da7c6b34544a99c4c264366f2fed4f0973">NetUtility::CONNECTION_ERROR</a> if an error occurred. </dd>
<dd>
<a class="el" href="class_net_utility.html#a7eae52138f8bd597ffc67ebf07e86b6dabc894c2de7a4404e353f3bcc1193e90b">NetUtility::REFUSED</a> if the server is full and so the connection attempt failed. </dd></dl>

</div>
</div>
<a class="anchor" id="adfe8471ae07cd596fe9215a890faac69"></a><!-- doxytag: member="mn::RecvTCP" ref="adfe8471ae07cd596fe9215a890faac69" args="(size_t instanceID, __int64 destinationPacket, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::RecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>destinationPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a TCP packet from the TCP received packet queue. </p>
<p>When TCP packets are received and a TCP receive function has not been set (using mn::SetFunction), they are put into a queue and retrieved using this command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destinationPacket</em>&nbsp;</td><td>Received packet will be copied into this location, overwriting any existing data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no packet was received. </dd>
<dd>
&gt;0 if a packet was received, this is the number of packets in the receive queue before this command was called. </dd></dl>
 
</div>
</div>
<a class="anchor" id="af95cb95140c98a5eeb54d7ef29ff1480"></a><!-- doxytag: member="mn::RecvTCP" ref="af95cb95140c98a5eeb54d7ef29ff1480" args="(size_t instanceID, Packet &amp;destinationPacket, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::RecvTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destinationPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a TCP packet from the TCP received packet queue. </p>
<p>When TCP packets are received and a TCP receive function has not been set (using mn::SetFunction), they are put into a queue and retrieved using this command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destinationPacket</em>&nbsp;</td><td>Received packet will be copied into this location, overwriting any existing data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no packet was received. </dd>
<dd>
&gt;0 if a packet was received, this is the number of packets in the receive queue before this command was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff7c0406f00568fbe51571ba3f87be1"></a><!-- doxytag: member="mn::RecvUDP" ref="a7ff7c0406f00568fbe51571ba3f87be1" args="(size_t instanceID, Packet &amp;destinationPacket, size_t clientID, size_t operationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mn::RecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destinationPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a UDP packet from the UDP received packet queue. </p>
<p>When UDP packets are received and a UDP receive function has not been set (using mn::SetFunction), they are put into a queue or store and retrieved using this command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to check, only valid in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> UDP mode. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destinationPacket</em>&nbsp;</td><td>Received packet will be copied into this location, overwriting any existing data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no packet was received. </dd>
<dd>
&gt;0 if a packet was received, this is the number of packets in the receive queue before this command was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a62627020941d9c6cdd1e3e3d1919c28b"></a><!-- doxytag: member="mn::RecvUDP" ref="a62627020941d9c6cdd1e3e3d1919c28b" args="(size_t instanceID, __int64 destinationPacket, size_t clientID, size_t operationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL size_t mn::RecvUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>destinationPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>operationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a UDP packet from the UDP received packet queue. </p>
<p>When UDP packets are received and a UDP receive function has not been set (using mn::SetFunction), they are put into a queue or store and retrieved using this command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operationID</em>&nbsp;</td><td>ID of operation to check, only valid in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetMode::UDP_PER_CLIENT_PER_OPERATION</a> UDP mode. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>destinationPacket</em>&nbsp;</td><td>Received packet will be copied into this location, overwriting any existing data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no packet was received. </dd>
<dd>
&gt;0 if a packet was received, this is the number of packets in the receive queue before this command was called. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a908c1d799a28850891e7432d7ad08d54"></a><!-- doxytag: member="mn::SendAllTCP" ref="a908c1d799a28850891e7432d7ad08d54" args="(size_t instanceID, __int64 packet, bool keep, bool block, size_t clientExcludeID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SendAllTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientExcludeID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a TCP packet to all clients on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExcludeID</em>&nbsp;</td><td>ID of client to exclude, the packet will be sent to all clients except one with this ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a0294004c6f4549d4c1dc403551ccd6d1"></a><!-- doxytag: member="mn::SendAllTCP" ref="a0294004c6f4549d4c1dc403551ccd6d1" args="(size_t instanceID, Packet &amp;packet, bool keep, bool block, size_t clientExcludeID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SendAllTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientExcludeID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a TCP packet to all clients on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExcludeID</em>&nbsp;</td><td>ID of client to exclude, the packet will be sent to all clients except one with this ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="adbcf7335bfdbdcc3a2fbb7e9de792256"></a><!-- doxytag: member="mn::SendAllUDP" ref="adbcf7335bfdbdcc3a2fbb7e9de792256" args="(size_t instanceID, __int64 packet, bool keep, bool block, size_t clientExcludeID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SendAllUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientExcludeID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a UDP packet to all clients on the specified instance. </p>
<p>Sends a UDP packet to all clients on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExcludeID</em>&nbsp;</td><td>ID of client to exclude, the packet will be sent to all clients except one with this ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a83608bf51559da75a3ea3411d2a386ad"></a><!-- doxytag: member="mn::SendAllUDP" ref="a83608bf51559da75a3ea3411d2a386ad" args="(size_t instanceID, Packet &amp;packet, bool keep, bool block, size_t clientExcludeID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SendAllUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientExcludeID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a UDP packet to all clients on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientExcludeID</em>&nbsp;</td><td>ID of client to exclude, the packet will be sent to all clients except one with this ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a93916238ec8d933a6e874660f7d3cc47"></a><!-- doxytag: member="mn::SendTCP" ref="a93916238ec8d933a6e874660f7d3cc47" args="(size_t instanceID, Packet &amp;packet, size_t clientID, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> mn::SendTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends TCP data to a client on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="a6f052556b3373d7c8b39f8c93514850d"></a><!-- doxytag: member="mn::SendTCP" ref="a6f052556b3373d7c8b39f8c93514850d" args="(size_t instanceID, __int64 packet, size_t clientID, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SendTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends TCP data to a client on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>
 
</div>
</div>
<a class="anchor" id="a24c13b82fd717671e16d1d4dd9f5e16d"></a><!-- doxytag: member="mn::SendToUDP" ref="a24c13b82fd717671e16d1d4dd9f5e16d" args="(size_t instanceID, Packet &amp;packet, const NetAddress &amp;address, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> mn::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends UDP data to an unconnected entity, identified only by its remote address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Address to send packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="a4576cc65008a1552f1185340b7c3e581"></a><!-- doxytag: member="mn::SendToUDP" ref="a4576cc65008a1552f1185340b7c3e581" args="(size_t instanceID, __int64 packet, const char *addrIP, unsigned short addrPort, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SendToUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addrIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>addrPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends UDP data to an unconnected entity, identified only by its remote address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrIP</em>&nbsp;</td><td>IP address to send packet to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrPort</em>&nbsp;</td><td>Port to send packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="ad57dddf4d781b354113e5e3d74dc3a5a"></a><!-- doxytag: member="mn::SendUDP" ref="ad57dddf4d781b354113e5e3d74dc3a5a" args="(size_t instanceID, Packet &amp;packet, size_t clientID, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736">NetUtility::SendStatus</a> mn::SendUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends UDP data to a client on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>

</div>
</div>
<a class="anchor" id="af9ce5db9b08f558c31f581c791ae422c"></a><!-- doxytag: member="mn::SendUDP" ref="af9ce5db9b08f558c31f581c791ae422c" args="(size_t instanceID, __int64 packet, size_t clientID, bool keep, bool block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SendUDP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends UDP data to a client on the specified instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client to receive from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keep</em>&nbsp;</td><td>If false <em>packet's</em> contents will be erased, if true no modifications to <em>packet</em> will be made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>If false the command will return immediately without waiting for the send operation to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736acec16f03b79a6de35d6ab9d5ceb58ff7">NetUtility::SEND_COMPLETED</a> if the send operation completed successfully instantly. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a802cb48d857d70f62624326eea294406">NetUtility::SEND_IN_PROGRESS</a> if the send operation was started, but has not yet completed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736a27389038f252e2ad34e12b28c9f93a00">NetUtility::SEND_FAILED</a> if the send operation failed. </dd>
<dd>
<a class="el" href="class_net_utility.html#a8051eca61204ffd818281419bbf44736abc96a939bc1f0dfffc56f4568ce9dad4">NetUtility::SEND_FAILED_KILL</a> if the send operation failed and an entity was killed as a result (e.g. Client disconnected). </dd></dl>
 
</div>
</div>
<a class="anchor" id="aaba22ec864ee20e4c2811bb2ad2ec3bf"></a><!-- doxytag: member="mn::SetAutoResizeTCP" ref="aaba22ec864ee20e4c2811bb2ad2ec3bf" args="(size_t instanceID, size_t clientID, bool autoResize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoResize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the auto resize TCP option. </p>
<p>When auto resize is true, if an incoming TCP packet is too large to be received, instead of throwing an error or forcefully disconnecting that client, the. TCP receive buffer automatically resizes to allow for the TCP packet to be received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>autoResize</em>&nbsp;</td><td>True if the TCP receive buffer should automatically resize, false if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a46a0362cea289b80f8ae8bffda655fd8"></a><!-- doxytag: member="mn::SetCursor" ref="a46a0362cea289b80f8ae8bffda655fd8" args="(__int64 packet, size_t cursor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetCursor </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the cursor position of the specified packet. </p>
<p>If the new cursor position is more than the used size then an error will occur.<br/>
<br/>
</p>
<p>The cursor indicates where Get commands that extract data should begin reading from and where add commands that add data should begin adding data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td>New cursor position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e2a2ce91d0eb804d0ee01a68e5f9ccc"></a><!-- doxytag: member="mn::SetErrorMode" ref="a6e2a2ce91d0eb804d0ee01a68e5f9ccc" args="(int errorMode, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetErrorMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errorMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables an error mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to modify. See <a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683" title="Error mode describes how errors should be dealt with.">ErrorReport::ErrorMode</a> values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>True to enable, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9e7e2b2efefe79f68bb72dca9212fd2"></a><!-- doxytag: member="mn::SetErrorMode" ref="af9e7e2b2efefe79f68bb72dca9212fd2" args="(ErrorReport::ErrorMode errorMode, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a>&nbsp;</td>
          <td class="paramname"> <em>errorMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables an error mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>True to enable, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c01a84cc17bd2b5e7b78a471c1d7b18"></a><!-- doxytag: member="mn::SetMemorySize" ref="a7c01a84cc17bd2b5e7b78a471c1d7b18" args="(__int64 packet, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetMemorySize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the memory size of the packet, overwriting any packet data in the process. </p>
<p><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> options such as clock value or instanceID are not lost after using this command. Only memory size, cursor position and used size are changes.<br/>
<br/>
</p>
<p>The memory size determines how much data can be stored in the packet. Although the packet automatically increases in memory size as data is added, it is best to set the memory size initially to avoid unnecessary reallocation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>New memory size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ab410089cf457da4cb7ba8e56b8c8b013"></a><!-- doxytag: member="mn::SetProfileAutoResizeTCP" ref="ab410089cf457da4cb7ba8e56b8c8b013" args="(__int64 profile, bool autoResize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoResize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the auto resize TCP option. </p>
<p>Changes the auto resize TCP option. </p>
 
</div>
</div>
<a class="anchor" id="a8119c03dd576a92ae38d126c56595f60"></a><!-- doxytag: member="mn::SetProfileAutoResizeTCP" ref="a8119c03dd576a92ae38d126c56595f60" args="(NetInstanceProfile &amp;profile, bool autoResize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileAutoResizeTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoResize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the auto resize TCP option. </p>
<p>When auto resize is true, if an incoming TCP packet is too large to be received, instead of throwing an error or forcefully disconnecting that client, the. TCP receive buffer automatically resizes to allow for the TCP packet to be received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>autoResize</em>&nbsp;</td><td>True if the TCP receive buffer should automatically resize, false if not. Default is <a class="el" href="class_net_instance_profile.html#ae0797a8d2fdfb3f67a7b67a103a99fcb" title="Default value for NetInstanceProfile::autoResizeTCP.">NetInstanceProfile::DEFAULT_AUTO_RESIZE_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e91e83b9cc8642ff935854764820c2"></a><!-- doxytag: member="mn::SetProfileBufferSizes" ref="aa0e91e83b9cc8642ff935854764820c2" args="(__int64 profile, size_t recvSizeTCP, size_t recvSizeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileBufferSizes </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSizeTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSizeUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifies the specified instance profile, loading it with buffer sizes. </p>
<p>If these buffer sizes are too small, an error will not be thrown until an attempt is made to activate an instance. This is because what is defined as 'too small' differs between instance types.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvSizeTCP</em>&nbsp;</td><td>Maximum size a received TCP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvSizeUDP</em>&nbsp;</td><td>Maximum size a received UDP packet can be without throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a55055a7e62d51d95aa6532f730d0a581"></a><!-- doxytag: member="mn::SetProfileBufferSizes" ref="a55055a7e62d51d95aa6532f730d0a581" args="(NetInstanceProfile &amp;profile, size_t recvSizeTCP, size_t recvSizeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileBufferSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSizeTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recvSizeUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifies the specified instance profile, loading it with buffer sizes. </p>
<p>If these buffer sizes are too small, an error will not be thrown until an attempt is made to activate an instance. This is because what is defined as 'too small' differs between instance types.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvSizeTCP</em>&nbsp;</td><td>Maximum size a received TCP packet can be without increasing the buffer size or throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvSizeUDP</em>&nbsp;</td><td>Maximum size a received UDP packet can be without throwing an error (default is <a class="el" href="class_net_instance_profile.html#a285d88534b9936cc603e778aa70d8ec3" title="Default number of bytes to allocate to receive buffers.">NetInstanceProfile::DEFAULT_BUFFER_SIZE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d64e3c108c8aab36271ac4751dd0c56"></a><!-- doxytag: member="mn::SetProfileDecryptKeyUDP" ref="a9d64e3c108c8aab36271ac4751dd0c56" args="(__int64 profile, __int64 key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileDecryptKeyUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the encryption key used to decrypt incoming UDP packets. </p>
<p>Note that the key is not necessarily used by. UDP instances, only if the mode in use specifically specifies in its documentation will the key ever be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key to use. 0 to unload the currently loaded encryption key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2fa263955d14ec167e70a857af2aaab"></a><!-- doxytag: member="mn::SetProfileEnabledUDP" ref="ad2fa263955d14ec167e70a857af2aaab" args="(__int64 profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileEnabledUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables or enables UDP. </p>
<p>When UDP is disabled all UDP commands will fail. The handshaking process will be slightly faster and compatibility with other applications will improve.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>If true UDP will be enabled, if false UDP will be disabled. Default is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a4ab287e14e0b6bc85f580ce81b756261"></a><!-- doxytag: member="mn::SetProfileEnabledUDP" ref="a4ab287e14e0b6bc85f580ce81b756261" args="(NetInstanceProfile &amp;profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileEnabledUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables or enables UDP. </p>
<p>When UDP is disabled all UDP commands will fail. The handshaking process will be slightly faster and compatibility with other applications will improve.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>If true UDP will be enabled, if false UDP will be disabled. Default is <a class="el" href="class_net_instance_profile.html#aceaa7353038094829951787fcb7ce2b8" title="Default value for NetInstanceProfile::enabledUDP.">NetInstanceProfile::DEFAULT_ENABLED_UDP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abfa7ac2dada8b706375f283e6ca7d9c8"></a><!-- doxytag: member="mn::SetProfileGracefulDisconnectEnabled" ref="abfa7ac2dada8b706375f283e6ca7d9c8" args="(__int64 profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>True if graceful disconnect process should be enabled, false if not. Default is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="acd97640f8602438193812c272b829dd1"></a><!-- doxytag: member="mn::SetProfileGracefulDisconnectEnabled" ref="acd97640f8602438193812c272b829dd1" args="(NetInstanceProfile &amp;profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileGracefulDisconnectEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the <a class="el" href="graceful_disconnect_page.html">graceful disconnect process</a> for the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>True if graceful disconnect process should be enabled, false if not. Default is <a class="el" href="class_net_instance_profile.html#ada7dfa96aa2fd6c205dc1137f2aad30d" title="Default value for NetInstanceProfile::gracefulDisconnect.">NetInstanceProfile::DEFAULT_GRACEFUL_DISCONNECT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a0599cc2661f22695799eb75861133737"></a><!-- doxytag: member="mn::SetProfileHandshakeEnabled" ref="a0599cc2661f22695799eb75861133737" args="(__int64 profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileHandshakeEnabled </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables or enables the handshaking option for the specified instance profile. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>True if the TCP handshake process should be enabled. Default is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a7c1a4cfa1663b13abfaed2b1b8476780"></a><!-- doxytag: member="mn::SetProfileHandshakeEnabled" ref="a7c1a4cfa1663b13abfaed2b1b8476780" args="(NetInstanceProfile &amp;profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileHandshakeEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables or enables the handshaking option for the specified instance profile. </p>
<p>For more information see <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>True if the TCP handshake process should be enabled. Default is <a class="el" href="class_net_instance_profile.html#a28c3283c29676e4dfbc7ea2428df32b5" title="Default value for NetInstanceProfile::handshakeEnabled.">NetInstanceProfile::DEFAULT_HANDSHAKE_ENABLED</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3a68a1529a25353794e70ac1892b016"></a><!-- doxytag: member="mn::SetProfileLocal" ref="ab3a68a1529a25353794e70ac1892b016" args="(__int64 profile, const char *IP_TCP, unsigned short portTCP, const char *IP_UDP, unsigned short portUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileLocal </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP_TCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>portTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP_UDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>portUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local TCP and UDP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IP_TCP</em>&nbsp;</td><td>The TCP IP address to load into the profile, overwriting any existing TCP IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portTCP</em>&nbsp;</td><td>The TCP port to load into the profile, overwriting any existing TCP port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IP_UDP</em>&nbsp;</td><td>The UDP IP address to load into the profile, overwriting any existing UDP IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portUDP</em>&nbsp;</td><td>The UDP port to load into the profile, overwriting any existing UDP port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a93163a023edd6728be16cc372102410e"></a><!-- doxytag: member="mn::SetProfileLocal" ref="a93163a023edd6728be16cc372102410e" args="(NetInstanceProfile &amp;profile, const NetAddress &amp;addressTCP, const NetAddress &amp;addressUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressTCP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local TCP and UDP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressTCP</em>&nbsp;</td><td>The TCP address to load into the profile, overwriting any existing TCP address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressUDP</em>&nbsp;</td><td>The UDP address to load into the profile, overwriting any existing UDP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a0764e70a254c557b528e1fa4a9d16a4d"></a><!-- doxytag: member="mn::SetProfileLocalTCP" ref="a0764e70a254c557b528e1fa4a9d16a4d" args="(__int64 profile, const char *IP, unsigned short port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileLocalTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local TCP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IP</em>&nbsp;</td><td>The TCP IP address to load into the profile, overwriting any existing TCP IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The TCP port to load into the profile, overwriting any existing TCP port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dd58ab1e4ed9f76eca562f3da2b4f8e"></a><!-- doxytag: member="mn::SetProfileLocalTCP" ref="a5dd58ab1e4ed9f76eca562f3da2b4f8e" args="(NetInstanceProfile &amp;profile, const NetAddress &amp;addressTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileLocalTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local TCP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressTCP</em>&nbsp;</td><td>The TCP address to load into the profile, overwriting any existing TCP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0972b0ace59cbdec2c987d1028ae2e2"></a><!-- doxytag: member="mn::SetProfileLocalUDP" ref="ac0972b0ace59cbdec2c987d1028ae2e2" args="(__int64 profile, const char *IP, unsigned short port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileLocalUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local UDP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IP</em>&nbsp;</td><td>The UDP IP address to load into the profile, overwriting any existing UDP IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The UDP port to load into the profile, overwriting any existing UDP port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0959be09dc2abd364d9c209fe6296b6"></a><!-- doxytag: member="mn::SetProfileLocalUDP" ref="ac0959be09dc2abd364d9c209fe6296b6" args="(NetInstanceProfile &amp;profile, const NetAddress &amp;addressUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileLocalUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addressUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the local UDP address of the specified instance profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addressUDP</em>&nbsp;</td><td>The UDP address to load into the profile, overwriting any existing UDP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eef27da5b215a832d533e3f23ec17b2"></a><!-- doxytag: member="mn::SetProfileModeTCP" ref="a6eef27da5b215a832d533e3f23ec17b2" args="(__int64 profile, char modeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileModeTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>modeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP mode for the specified instance profile. </p>
<p>The TCP mode describes changes should be made to TCP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modeTCP</em>&nbsp;</td><td>TCP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>modeTCP</em> is not a TCP mode. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="note"><dt><b>Note:</b></dt><dd><em>modeTCP</em> is the value of <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964" title="Describes the protocol mode in use.">NetMode::ProtocolMode</a> e.g. For TCP_PREFIX_SIZE <em>modeTCP</em> should be 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ae56c4d95f9ecc254b04cccd03f4a8a88"></a><!-- doxytag: member="mn::SetProfileModeTCP" ref="ae56c4d95f9ecc254b04cccd03f4a8a88" args="(NetInstanceProfile &amp;profile, NetMode::ProtocolMode modeTCP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileModeTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>modeTCP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP mode for the specified instance profile. </p>
<p>The TCP mode describes changes should be made to TCP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modeTCP</em>&nbsp;</td><td>TCP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>modeTCP</em> is not a TCP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad500886a9ca404e1fd2a4c4568e42a4b"></a><!-- doxytag: member="mn::SetProfileModeUDP" ref="ad500886a9ca404e1fd2a4c4568e42a4b" args="(NetInstanceProfile &amp;profile, NetMode::ProtocolMode modeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileModeUDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964">NetMode::ProtocolMode</a>&nbsp;</td>
          <td class="paramname"> <em>modeUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the UDP mode for the specified instance profile. </p>
<p>The UDP mode describes changes should be made to UDP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modeUDP</em>&nbsp;</td><td>UDP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>modeUDP</em> is not a UDP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26e692b76b3c7de234bdc106241bb0ec"></a><!-- doxytag: member="mn::SetProfileModeUDP" ref="a26e692b76b3c7de234bdc106241bb0ec" args="(__int64 profile, char modeUDP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileModeUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>modeUDP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the UDP mode for the specified instance profile. </p>
<p>The UDP mode describes changes should be made to UDP packets sent and how data is split into packets when received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modeUDP</em>&nbsp;</td><td>UDP mode option. Default is <a class="el" href="class_net_instance_profile.html#ad1d027ea1d01003564961be529fd5766" title="Default value for NetInstanceProfile::modeTCP.">NetInstanceProfile::DEFAULT_MODE_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If <em>modeUDP</em> is not a UDP mode. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="note"><dt><b>Note:</b></dt><dd><em>modeUDP</em> is the value of <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964" title="Describes the protocol mode in use.">NetMode::ProtocolMode</a> e.g. For UDP_CATCH_ALL <em>modeUDP</em> should be 4. </dd></dl>

</div>
</div>
<a class="anchor" id="ae50662bc5a7f605697468cd7f65fc7ab"></a><!-- doxytag: member="mn::SetProfileNagleEnabledTCP" ref="ae50662bc5a7f605697468cd7f65fc7ab" args="(__int64 profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command changes the nagle algorithm option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>If true the nagle algorithm is enabled, if false the nagle algorithm is disabled. Default is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="aaf460a06d05ca0a65cd284aeb02b7f89"></a><!-- doxytag: member="mn::SetProfileNagleEnabledTCP" ref="aaf460a06d05ca0a65cd284aeb02b7f89" args="(NetInstanceProfile &amp;profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileNagleEnabledTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command changes the nagle algorithm option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>If true the nagle algorithm is enabled, if false the nagle algorithm is disabled. Default is <a class="el" href="class_net_instance_profile.html#a0f709c306b12e5572df975b10d6c748f" title="Default value for NetInstanceProfile::nagleEnabled.">NetInstanceProfile::DEFAULT_NAGLE_ENABLED</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abdc6d771977a7314824360236da3e966"></a><!-- doxytag: member="mn::SetProfileNumOperationsUDP" ref="abdc6d771977a7314824360236da3e966" args="(__int64 profile, size_t numOperations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileNumOperationsUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numOperations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies the number of UDP operations in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964a947fd0828716fc0442ea546cce111c27">NetModeUdp::UDP_PER_CLIENT_PER_OPERATION</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numOperations</em>&nbsp;</td><td>Number of operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a1934cbe74210d9d2911170ded6a0a978"></a><!-- doxytag: member="mn::SetProfilePostfixTCP" ref="a1934cbe74210d9d2911170ded6a0a978" args="(__int64 profile, __int64 packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfilePostfixTCP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command changes the postfix option of the specified instance profile. </p>
<p>This has no impact on instances not in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>New postfix, default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a751e72752dfd6b8fe814951f0580bd38"></a><!-- doxytag: member="mn::SetProfilePostfixTCP" ref="a751e72752dfd6b8fe814951f0580bd38" args="(NetInstanceProfile &amp;profile, const Packet &amp;packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfilePostfixTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command changes the postfix option of the specified instance profile. </p>
<p>This has no impact on instances not in <a class="el" href="class_net_mode.html#a43cfa55ee6a4db66a8d7d6c27f766964abe08876125a416186e74c901f6d29ce4">NetMode::TCP_POSTFIX</a> mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>New postfix, default is <a class="el" href="class_net_instance_profile.html#a309f6b2f32bd9dcbb9bd5e15e7381de2" title="Default value for NetInstanceProfile::postFixTCP.">NetInstanceProfile::DEFAULT_POSTFIX_TCP</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ae8c0e5371300f58773ee06e0a24484ae"></a><!-- doxytag: member="mn::SetProfileReusableUDP" ref="ae8c0e5371300f58773ee06e0a24484ae" args="(__int64 profile, bool option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileReusableUDP </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reusable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the reusable UDP option. If reusable other applications, instances and sockets can bind to the same UDP address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reusable</em>&nbsp;</td><td>True to enable, false to disable the option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="afdce8fa11b7c1689deb1c2274e5f5f38"></a><!-- doxytag: member="mn::SetProfileSendTimeout" ref="afdce8fa11b7c1689deb1c2274e5f5f38" args="(__int64 profile, unsigned int timeoutMilliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileSendTimeout </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the send timeout option for the specified instance profile. Send operations are allowed this amount of time to complete before the entity that initiated the operation is dropped. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Length of time in milliseconds to wait for a send operation to complete before disconnecting client (default = <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="abc9793b165372548ed3c10b470244efd"></a><!-- doxytag: member="mn::SetProfileSendTimeout" ref="abc9793b165372548ed3c10b470244efd" args="(NetInstanceProfile &amp;profile, unsigned int timeoutMilliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileSendTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the send timeout option for the specified instance profile. Send operations are allowed this amount of time to complete before the entity that initiated the operation is dropped. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Length of time in milliseconds to wait for a send operation to complete before disconnecting client (default = <a class="el" href="class_net_instance_profile.html#a7a3abeb53ed94ac5a75c408f2684e909" title="Default value for NetInstanceProfile::sendTimeout.">NetInstanceProfile::DEFAULT_SEND_TIMEOUT</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a8efc5de6466f9709510161e20a8375ff"></a><!-- doxytag: member="mn::SetProfileServerTimeout" ref="a8efc5de6466f9709510161e20a8375ff" args="(NetInstanceProfile &amp;profile, size_t timeoutMilliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::SetProfileServerTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed <em>timeoutMilliseconds</em> to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.<br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c3118c75c09780b67a93126237385d6"></a><!-- doxytag: member="mn::SetProfileServerTimeout" ref="a9c3118c75c09780b67a93126237385d6" args="(__int64 profile, size_t timeoutMilliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetProfileServerTimeout </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed <em>timeoutMilliseconds</em> to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.<br/>
<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>
 
</div>
</div>
<a class="anchor" id="a214c9fac7be21f994a50f11f6dbd1fd5"></a><!-- doxytag: member="mn::SetServerTimeout" ref="a214c9fac7be21f994a50f11f6dbd1fd5" args="(size_t instanceID, size_t timeoutMilliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetServerTimeout </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMilliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the amount of time that clients are allowed to spend handshaking with the server before being dropped. </p>
<p>See <a class="el" href="handshake_page.html#handshakeSecurityConnectionTimeout">server/client handshaking process connection timeout</a> for more information. <br/>
<br/>
</p>
<p>From the moment that a client first communicates with the server, it is allowed <em>timeoutMilliseconds</em> to complete the handshaking process before the process is aborted and the client is forcefully silently disconnected. Note that <a class="el" href="namespacemn.html#a24fc1fbd520a0e0095810ad6fec20c5a" title="Keeps track of who has disconnected recently.">mn::ClientLeft</a> will not receive notification since <a class="el" href="namespacemn.html#aa88fef80cdb3574c2b6ba46931f8a133" title="Manages incoming connections from clients.">mn::ClientJoined</a> will not have. <br/>
<br/>
</p>
<p>The default value is <a class="el" href="class_net_instance_server.html#ace7e83c6a82f0810cee2c7c638bb9397" title="Default time in milliseconds that a connection attempt will be waited on before giving up...">NetInstanceServer::DEFAULT_CONNECTION_TIMEOUT</a>.<br/>
<br/>
</p>
<p>This command can be used only on an active server instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMilliseconds</em>&nbsp;</td><td>Number of milliseconds that connection attempts should be allowed to complete before entity is forcefully disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ad552a2a89165470686778f966d65bdc9"></a><!-- doxytag: member="mn::SetUsedSize" ref="ad552a2a89165470686778f966d65bdc9" args="(__int64 packet, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::SetUsedSize </td>
          <td>(</td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the used size of the packet. </p>
<p>The used size indicates how much of the memory size is in use. If an attempt is made to change the used size to be more than the memory size, then the memory size is increased as necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td><a class="el" href="class_packet.html" title="Efficiently and safely stores and manipulates data.">Packet</a> to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>New used size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aabf2e7fc125113e54f60f4b018faa8a5"></a><!-- doxytag: member="mn::ShutdownClient" ref="aabf2e7fc125113e54f60f4b018faa8a5" args="(size_t instanceID, size_t clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ShutdownClient </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins the graceful disconnection process. </p>
<p>After using this command all send commands will fail, receiving will still operate as normal however. All data sent up till now will be received by recipient. <br/>
</p>
<p>See the <a class="el" href="graceful_disconnect_page.html">graceful disconnection page</a> for more information. <br/>
<br/>
</p>
<p>Can only be used on an active TCP instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientID</em>&nbsp;</td><td>ID of client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_error_report.html" title="Stores an error report.">ErrorReport</a></em>&nbsp;</td><td>If graceful disconnect is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4452d09215e972009fc5985a61ae7d04"></a><!-- doxytag: member="mn::Start" ref="a4452d09215e972009fc5985a61ae7d04" args="(size_t numInstances, size_t numThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::Start </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numInstances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numThreads</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts up the networking module. </p>
<p>If the module is already active then the module will be restarted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numInstances</em>&nbsp;</td><td>Number of instances to be created but not setup. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numThreads</em>&nbsp;</td><td>Number of threads to be created to manage data being received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no error occurred. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b85e7da0cf4c6a1cf5ff67f580b29b5"></a><!-- doxytag: member="mn::StartBroadcast" ref="a2b85e7da0cf4c6a1cf5ff67f580b29b5" args="(size_t instanceID, const char *connectAddressIP, unsigned short connectAddressPort, bool sendEnabled, bool recvEnabled, __int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::StartBroadcast </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connectAddressIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>connectAddressPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recvEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a broadcasting instance into the specified instance ID. </p>
<p>This instance is capable of communicating with entities on a common local area network without first forming a direct connection. Messages sent to the router are broadcasted to all other entities connected to that router using this instance. This is useful for e.g. Detecting a server on a network, and then later making a direct connection to that server. Due to the simplicity of this instance, it is possible to use it with applications not based on this module.</p>
<p>If you are receiving broadcast packets then using the instance profile you should specify the local IP that is on the LAN that you expect to receive broadcast packets from. The local port should be the port that the broadcaster is broadcasting to.<br/>
<br/>
</p>
<p>Use <a class="el" href="namespacemn.html#a62627020941d9c6cdd1e3e3d1919c28b" title="Retrieves a UDP packet from the UDP received packet queue.">mn::RecvUDP</a> to receive data if receiving is enabled. Use <a class="el" href="namespacemn.html#af9ce5db9b08f558c31f581c791ae422c" title="Sends UDP data to a client on the specified instance.">mn::SendUDP</a> to send broadcast packets if sending is enabled.<br/>
<br/>
</p>
<p>Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectAddressIP</em>&nbsp;</td><td>Address to broadcast to. Set this to 255.255.255.255 to broadcast to all entities connected to the local area network, or specify a subnet to broadcast to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectAddressPort</em>&nbsp;</td><td>Set this to the port that entities should listen. for broadcast packets on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendEnabled</em>&nbsp;</td><td>True if this instance should be capable of sending broadcast packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvEnabled</em>&nbsp;</td><td>True if this instance should be capable of receiving broadcast packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Pointer (cast to __int64) to instance profile containing additional instance settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the instance was started successfully. </dd>
<dd>
-1 if the instance failed to start. </dd></dl>

</div>
</div>
<a class="anchor" id="a286e995f3afa08292c38838bb3908fb9"></a><!-- doxytag: member="mn::StartBroadcast" ref="a286e995f3afa08292c38838bb3908fb9" args="(size_t instanceID, const NetAddress &amp;connectAddress, bool sendEnabled, bool recvEnabled, const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::StartBroadcast </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_address.html">NetAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connectAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recvEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a broadcasting instance into the specified instance ID. </p>
<p>This instance is capable of communicating with entities on a common local area network without first forming a direct connection. Messages sent to the router are broadcasted to all other entities connected to that router using this instance. This is useful for e.g. Detecting a server on a network, and then later making a direct connection to that server. Due to the simplicity of this instance, it is possible to use it with applications not based on this module.</p>
<p>If you are receiving broadcast packets then using the instance profile you should specify the local IP that is on the LAN that you expect to receive broadcast packets from. The local port should be the port that the broadcaster is broadcasting to.<br/>
<br/>
</p>
<p>Use <a class="el" href="namespacemn.html#a62627020941d9c6cdd1e3e3d1919c28b" title="Retrieves a UDP packet from the UDP received packet queue.">mn::RecvUDP</a> to receive data if receiving is enabled. Use <a class="el" href="namespacemn.html#af9ce5db9b08f558c31f581c791ae422c" title="Sends UDP data to a client on the specified instance.">mn::SendUDP</a> to send broadcast packets if sending is enabled.<br/>
<br/>
</p>
<p>Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectAddress</em>&nbsp;</td><td>Address to broadcast to. Set the IP to 255.255.255.255 to broadcast to all entities connected to the local area network, or specify a subnet to broadcast to. Set the port to the port that entities should listen for broadcast packets on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sendEnabled</em>&nbsp;</td><td>True if this instance should be capable of sending broadcast packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvEnabled</em>&nbsp;</td><td>True if this instance should be capable of receiving broadcast packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile containing additional instance settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the instance was started successfully. </dd>
<dd>
-1 if the instance failed to start. </dd></dl>

</div>
</div>
<a class="anchor" id="ac35052139b0152c092a1097d065e0c2f"></a><!-- doxytag: member="mn::StartServer" ref="ac35052139b0152c092a1097d065e0c2f" args="(size_t instanceID, size_t maxClients, __int64 profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::StartServer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__int64&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a server instance into the specified instance ID. </p>
<p>The instance is fully active and clients can connect after this command has been called. Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxClients</em>&nbsp;</td><td>Maximum number of clients that can be connected to server at any one time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile containing additional instance settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the server was started successfully. </dd>
<dd>
-1 if the server failed to start. </dd></dl>
 
</div>
</div>
<a class="anchor" id="ae6efe6a55174aa31805c0d7768f3e08c"></a><!-- doxytag: member="mn::StartServer" ref="ae6efe6a55174aa31805c0d7768f3e08c" args="(size_t instanceID, size_t maxClients, const NetInstanceProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::StartServer </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxClients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_net_instance_profile.html">NetInstanceProfile</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a server instance into the specified instance ID. </p>
<p>The instance is fully active and clients can connect after this command has been called. Any instance already loaded into the specified instance ID will be deactivated and overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxClients</em>&nbsp;</td><td>Maximum number of clients that can be connected to server at any one time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>Instance profile containing additional instance settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the server was started successfully. </dd>
<dd>
-1 if the server failed to start. </dd></dl>

</div>
</div>
<a class="anchor" id="a384075204fa1db1a7fdd21a0219662ba"></a><!-- doxytag: member="mn::StopConnect" ref="a384075204fa1db1a7fdd21a0219662ba" args="(size_t instanceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::StopConnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>instanceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels the <a class="el" href="handshake_page.html">handshaking process</a>. </p>
<p>Can only be used in <a class="el" href="class_net_instance.html#a0ec01a76d9b78794cfbdeab10a436cdca508124ab62368682064b3426f41042fd">NetInstance::CLIENT</a> state.</p>
<p>The handshaking must be in progress otherwise this command will fail. This method is part of the <a class="el" href="handshake_page.html">server/client handshaking process</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>PollConnect should not be used after this command, it will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instanceID</em>&nbsp;</td><td>Unique identifier for instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the command completed successfully. </dd>
<dd>
-1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="aae72e4f0b526ae1d6b187c2bbe13dadc"></a><!-- doxytag: member="mn::TestClass" ref="aae72e4f0b526ae1d6b187c2bbe13dadc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mn::TestClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if no problems while testing were found, false if not. Note that not all tests automatically check for problems so some tests require manual verification. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a01e895d4f298c3ed9481d1f544cfef"></a><!-- doxytag: member="mn::ToggleErrorMode" ref="a0a01e895d4f298c3ed9481d1f544cfef" args="(ErrorReport::ErrorMode errorMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mn::ToggleErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683">ErrorReport::ErrorMode</a>&nbsp;</td>
          <td class="paramname"> <em>errorMode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Toggles error mode. </p>
<p>If the error mode was enabled, it will be disabled and visa versa.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to toggle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dbb56094130ab288e1379defacb3f90"></a><!-- doxytag: member="mn::ToggleErrorMode" ref="a7dbb56094130ab288e1379defacb3f90" args="(int errorMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBP_CPP_DLL int mn::ToggleErrorMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errorMode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Toggles error mode. </p>
<p>If the error mode was enabled, it will be disabled and visa versa.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorMode</em>&nbsp;</td><td>The error mode to toggle. See <a class="el" href="class_error_report.html#ab70777b4cf64240281ddd4217664f683" title="Error mode describes how errors should be dealt with.">ErrorReport::ErrorMode</a> values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Sep 25 2010 22:10:27 for DarkNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
